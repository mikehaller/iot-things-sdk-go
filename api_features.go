/*
 * Bosch IoT Things HTTP API
 *
 * Bosch IoT Things enables applications to manage digital twins of IoT device assets in a simple, convenient, robust, and secure way.  These descriptions focus on the JSON-based, REST-like **HTTP API 2** of the Bosch IoT Things service.  Find details in our [documentation](https://docs.bosch-iot-suite.com/things/).  The Bosch IoT Things HTTP API uses response status codes     (see [RFC 7231](https://tools.ietf.org/html/rfc7231#section-6))     to indicate whether a specific request has been successfully completed, or not. However, the descriptions we provide additionally to the status code (e.g. in our API docs, or error codes like. \"solutions:transaction.count.exceeded\") might change without advance notice. These are not be considered as official API, and must therefore not be applied in your applications or tests.
 *
 * API version: 2
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package iotthings

import (
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
	"github.com/antihax/optional"
)

// Linger please
var (
	_ _context.Context
)

// FeaturesApiService FeaturesApi service
type FeaturesApiService service

// ThingsThingIdFeaturesDeleteOpts Optional parameters for the method 'ThingsThingIdFeaturesDelete'
type ThingsThingIdFeaturesDeleteOpts struct {
    IfMatch optional.String
    IfNoneMatch optional.String
    RequestedAcks optional.String
    Timeout optional.String
    ResponseRequired optional.Bool
}

/*
ThingsThingIdFeaturesDelete Delete all features of a specific thing
Deletes all features of the thing identified by the &#x60;thingId&#x60; path parameter.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param thingId The ID of a thing needs to follow the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).  The namespace needs to be registered for your solution
 * @param optional nil or *ThingsThingIdFeaturesDeleteOpts - Optional Parameters:
 * @param "IfMatch" (optional.String) -  The `If-Match` header which has to conform to RFC-7232 (Conditional Requests). Common usages are:   * optimistic locking by specifying the `ETag` from a previous HTTP response, e.g. `If-Match: \"hash:a75ece4e\"`   * retrieving or modifying a resource only if it already exists, e.g. `If-Match: *`
 * @param "IfNoneMatch" (optional.String) -  The `If-None-Match` header, which has to conform to RFC-7232 (Conditional Requests). A common usage scenario is to modify a resource only if it does not yet exist, thus to create it, by specifying `If-None-Match: *`.
 * @param "RequestedAcks" (optional.String) -  Contains the \"requested acknowledgements\" for this modifying request as comma separated list. The HTTP call will block until all requested acknowledgements were aggregated or will time out based on the specified `timeout` parameter.  The default (if omitted) requested acks is `requested-acks=twin-persisted` which will block the HTTP call until the change was persited to the twin.
 * @param "Timeout" (optional.String) -  Defines how long the backend should wait for completion of the request, e.g. applied when waiting for requested acknowledgements via the `requested-acks` param. Can be specified without unit (then seconds are assumed) or together with `s`, `ms` or `m` unit. Example: `42s`, `1m`.  The default (if omitted) timeout is `10s`. Maximum value: `60s`.  A value of `0` applies fire and forget semantics for the command resulting in setting `response-required=false`.
 * @param "ResponseRequired" (optional.Bool) -  Defines whether a response is required to the API call or not - if set to `false` the response will directly sent back with a status code of `202` (Accepted).  The default (if ommited) response is `true`.
*/
func (a *FeaturesApiService) ThingsThingIdFeaturesDelete(ctx _context.Context, thingId string, localVarOptionals *ThingsThingIdFeaturesDeleteOpts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/things/{thingId}/features"
	localVarPath = strings.Replace(localVarPath, "{"+"thingId"+"}", _neturl.QueryEscape(parameterToString(thingId, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.RequestedAcks.IsSet() {
		localVarQueryParams.Add("requested-acks", parameterToString(localVarOptionals.RequestedAcks.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Timeout.IsSet() {
		localVarQueryParams.Add("timeout", parameterToString(localVarOptionals.Timeout.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ResponseRequired.IsSet() {
		localVarQueryParams.Add("response-required", parameterToString(localVarOptionals.ResponseRequired.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.IfMatch.IsSet() {
		localVarHeaderParams["If-Match"] = parameterToString(localVarOptionals.IfMatch.Value(), "")
	}
	if localVarOptionals != nil && localVarOptionals.IfNoneMatch.IsSet() {
		localVarHeaderParams["If-None-Match"] = parameterToString(localVarOptionals.IfNoneMatch.Value(), "")
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-cr-api-token"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 402 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 412 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// ThingsThingIdFeaturesFeatureIdDefinitionDeleteOpts Optional parameters for the method 'ThingsThingIdFeaturesFeatureIdDefinitionDelete'
type ThingsThingIdFeaturesFeatureIdDefinitionDeleteOpts struct {
    IfMatch optional.String
    IfNoneMatch optional.String
    RequestedAcks optional.String
    Timeout optional.String
    ResponseRequired optional.Bool
}

/*
ThingsThingIdFeaturesFeatureIdDefinitionDelete Delete the definition of a feature
Deletes the complete definition of the feature identified by the &#x60;thingId&#x60; and &#x60;featureId&#x60; path parameter.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param thingId The ID of a thing needs to follow the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).  The namespace needs to be registered for your solution
 * @param featureId The ID of the feature - has to conform to RFC-3986 (URI)
 * @param optional nil or *ThingsThingIdFeaturesFeatureIdDefinitionDeleteOpts - Optional Parameters:
 * @param "IfMatch" (optional.String) -  The `If-Match` header which has to conform to RFC-7232 (Conditional Requests). Common usages are:   * optimistic locking by specifying the `ETag` from a previous HTTP response, e.g. `If-Match: \"hash:a75ece4e\"`   * retrieving or modifying a resource only if it already exists, e.g. `If-Match: *`
 * @param "IfNoneMatch" (optional.String) -  The `If-None-Match` header, which has to conform to RFC-7232 (Conditional Requests). A common usage scenario is to modify a resource only if it does not yet exist, thus to create it, by specifying `If-None-Match: *`.
 * @param "RequestedAcks" (optional.String) -  Contains the \"requested acknowledgements\" for this modifying request as comma separated list. The HTTP call will block until all requested acknowledgements were aggregated or will time out based on the specified `timeout` parameter.  The default (if omitted) requested acks is `requested-acks=twin-persisted` which will block the HTTP call until the change was persited to the twin.
 * @param "Timeout" (optional.String) -  Defines how long the backend should wait for completion of the request, e.g. applied when waiting for requested acknowledgements via the `requested-acks` param. Can be specified without unit (then seconds are assumed) or together with `s`, `ms` or `m` unit. Example: `42s`, `1m`.  The default (if omitted) timeout is `10s`. Maximum value: `60s`.  A value of `0` applies fire and forget semantics for the command resulting in setting `response-required=false`.
 * @param "ResponseRequired" (optional.Bool) -  Defines whether a response is required to the API call or not - if set to `false` the response will directly sent back with a status code of `202` (Accepted).  The default (if ommited) response is `true`.
*/
func (a *FeaturesApiService) ThingsThingIdFeaturesFeatureIdDefinitionDelete(ctx _context.Context, thingId string, featureId string, localVarOptionals *ThingsThingIdFeaturesFeatureIdDefinitionDeleteOpts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/things/{thingId}/features/{featureId}/definition"
	localVarPath = strings.Replace(localVarPath, "{"+"thingId"+"}", _neturl.QueryEscape(parameterToString(thingId, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"featureId"+"}", _neturl.QueryEscape(parameterToString(featureId, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.RequestedAcks.IsSet() {
		localVarQueryParams.Add("requested-acks", parameterToString(localVarOptionals.RequestedAcks.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Timeout.IsSet() {
		localVarQueryParams.Add("timeout", parameterToString(localVarOptionals.Timeout.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ResponseRequired.IsSet() {
		localVarQueryParams.Add("response-required", parameterToString(localVarOptionals.ResponseRequired.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.IfMatch.IsSet() {
		localVarHeaderParams["If-Match"] = parameterToString(localVarOptionals.IfMatch.Value(), "")
	}
	if localVarOptionals != nil && localVarOptionals.IfNoneMatch.IsSet() {
		localVarHeaderParams["If-None-Match"] = parameterToString(localVarOptionals.IfNoneMatch.Value(), "")
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-cr-api-token"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 402 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 412 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// ThingsThingIdFeaturesFeatureIdDefinitionGetOpts Optional parameters for the method 'ThingsThingIdFeaturesFeatureIdDefinitionGet'
type ThingsThingIdFeaturesFeatureIdDefinitionGetOpts struct {
    IfMatch optional.String
    IfNoneMatch optional.String
    Timeout optional.String
}

/*
ThingsThingIdFeaturesFeatureIdDefinitionGet List the definition of a feature
Returns the complete definition field of the feature identified by the &#x60;thingId&#x60; and &#x60;featureId&#x60; path parameter.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param thingId The ID of a thing needs to follow the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).  The namespace needs to be registered for your solution
 * @param featureId The ID of the feature - has to conform to RFC-3986 (URI)
 * @param optional nil or *ThingsThingIdFeaturesFeatureIdDefinitionGetOpts - Optional Parameters:
 * @param "IfMatch" (optional.String) -  The `If-Match` header which has to conform to RFC-7232 (Conditional Requests). Common usages are:   * optimistic locking by specifying the `ETag` from a previous HTTP response, e.g. `If-Match: \"hash:a75ece4e\"`   * retrieving or modifying a resource only if it already exists, e.g. `If-Match: *`
 * @param "IfNoneMatch" (optional.String) -  The `If-None-Match` header, which has to conform to RFC-7232 (Conditional Requests). A common usage scenario is to modify a resource only if it does not yet exist, thus to create it, by specifying `If-None-Match: *`.
 * @param "Timeout" (optional.String) -  Defines how long the backend should wait for completion of the request, e.g. applied when waiting for requested acknowledgements via the `requested-acks` param. Can be specified without unit (then seconds are assumed) or together with `s`, `ms` or `m` unit. Example: `42s`, `1m`.  The default (if omitted) timeout is `10s`. Maximum value: `60s`.  A value of `0` applies fire and forget semantics for the command resulting in setting `response-required=false`.
@return []string
*/
func (a *FeaturesApiService) ThingsThingIdFeaturesFeatureIdDefinitionGet(ctx _context.Context, thingId string, featureId string, localVarOptionals *ThingsThingIdFeaturesFeatureIdDefinitionGetOpts) ([]string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []string
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/things/{thingId}/features/{featureId}/definition"
	localVarPath = strings.Replace(localVarPath, "{"+"thingId"+"}", _neturl.QueryEscape(parameterToString(thingId, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"featureId"+"}", _neturl.QueryEscape(parameterToString(featureId, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Timeout.IsSet() {
		localVarQueryParams.Add("timeout", parameterToString(localVarOptionals.Timeout.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.IfMatch.IsSet() {
		localVarHeaderParams["If-Match"] = parameterToString(localVarOptionals.IfMatch.Value(), "")
	}
	if localVarOptionals != nil && localVarOptionals.IfNoneMatch.IsSet() {
		localVarHeaderParams["If-None-Match"] = parameterToString(localVarOptionals.IfNoneMatch.Value(), "")
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-cr-api-token"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 402 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 412 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// ThingsThingIdFeaturesFeatureIdDefinitionPutOpts Optional parameters for the method 'ThingsThingIdFeaturesFeatureIdDefinitionPut'
type ThingsThingIdFeaturesFeatureIdDefinitionPutOpts struct {
    IfMatch optional.String
    IfNoneMatch optional.String
    RequestedAcks optional.String
    Timeout optional.String
    ResponseRequired optional.Bool
}

/*
ThingsThingIdFeaturesFeatureIdDefinitionPut Create or update the definition of a feature
Create or update the complete definition of a feature identified by the &#x60;thingId&#x60; and &#x60;featureId&#x60; path parameter.  The definition field will be overwritten with the JSON array set in the request body
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param thingId The ID of a thing needs to follow the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).  The namespace needs to be registered for your solution
 * @param featureId The ID of the feature - has to conform to RFC-3986 (URI)
 * @param requestBody JSON array of the complete definition to be updated. Consider that the value has to be a JSON array or `null`.  The content of the JSON array are strings in the format `\"namespace:name:version\"` which is enforced.
 * @param optional nil or *ThingsThingIdFeaturesFeatureIdDefinitionPutOpts - Optional Parameters:
 * @param "IfMatch" (optional.String) -  The `If-Match` header which has to conform to RFC-7232 (Conditional Requests). Common usages are:   * optimistic locking by specifying the `ETag` from a previous HTTP response, e.g. `If-Match: \"hash:a75ece4e\"`   * retrieving or modifying a resource only if it already exists, e.g. `If-Match: *`
 * @param "IfNoneMatch" (optional.String) -  The `If-None-Match` header, which has to conform to RFC-7232 (Conditional Requests). A common usage scenario is to modify a resource only if it does not yet exist, thus to create it, by specifying `If-None-Match: *`.
 * @param "RequestedAcks" (optional.String) -  Contains the \"requested acknowledgements\" for this modifying request as comma separated list. The HTTP call will block until all requested acknowledgements were aggregated or will time out based on the specified `timeout` parameter.  The default (if omitted) requested acks is `requested-acks=twin-persisted` which will block the HTTP call until the change was persited to the twin.
 * @param "Timeout" (optional.String) -  Defines how long the backend should wait for completion of the request, e.g. applied when waiting for requested acknowledgements via the `requested-acks` param. Can be specified without unit (then seconds are assumed) or together with `s`, `ms` or `m` unit. Example: `42s`, `1m`.  The default (if omitted) timeout is `10s`. Maximum value: `60s`.  A value of `0` applies fire and forget semantics for the command resulting in setting `response-required=false`.
 * @param "ResponseRequired" (optional.Bool) -  Defines whether a response is required to the API call or not - if set to `false` the response will directly sent back with a status code of `202` (Accepted).  The default (if ommited) response is `true`.
@return []string
*/
func (a *FeaturesApiService) ThingsThingIdFeaturesFeatureIdDefinitionPut(ctx _context.Context, thingId string, featureId string, requestBody []string, localVarOptionals *ThingsThingIdFeaturesFeatureIdDefinitionPutOpts) ([]string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []string
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/things/{thingId}/features/{featureId}/definition"
	localVarPath = strings.Replace(localVarPath, "{"+"thingId"+"}", _neturl.QueryEscape(parameterToString(thingId, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"featureId"+"}", _neturl.QueryEscape(parameterToString(featureId, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.RequestedAcks.IsSet() {
		localVarQueryParams.Add("requested-acks", parameterToString(localVarOptionals.RequestedAcks.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Timeout.IsSet() {
		localVarQueryParams.Add("timeout", parameterToString(localVarOptionals.Timeout.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ResponseRequired.IsSet() {
		localVarQueryParams.Add("response-required", parameterToString(localVarOptionals.ResponseRequired.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.IfMatch.IsSet() {
		localVarHeaderParams["If-Match"] = parameterToString(localVarOptionals.IfMatch.Value(), "")
	}
	if localVarOptionals != nil && localVarOptionals.IfNoneMatch.IsSet() {
		localVarHeaderParams["If-None-Match"] = parameterToString(localVarOptionals.IfNoneMatch.Value(), "")
	}
	// body params
	localVarPostBody = &requestBody
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-cr-api-token"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 402 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 412 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 413 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// ThingsThingIdFeaturesFeatureIdDeleteOpts Optional parameters for the method 'ThingsThingIdFeaturesFeatureIdDelete'
type ThingsThingIdFeaturesFeatureIdDeleteOpts struct {
    IfMatch optional.String
    IfNoneMatch optional.String
    RequestedAcks optional.String
    Timeout optional.String
    ResponseRequired optional.Bool
}

/*
ThingsThingIdFeaturesFeatureIdDelete Delete a specific feature of a specific thing
Deletes a specific feature identified by the &#x60;featureId&#x60; path parameter of the thing identified by the &#x60;thingId&#x60; path parameter.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param thingId The ID of a thing needs to follow the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).  The namespace needs to be registered for your solution
 * @param featureId The ID of the feature - has to conform to RFC-3986 (URI)
 * @param optional nil or *ThingsThingIdFeaturesFeatureIdDeleteOpts - Optional Parameters:
 * @param "IfMatch" (optional.String) -  The `If-Match` header which has to conform to RFC-7232 (Conditional Requests). Common usages are:   * optimistic locking by specifying the `ETag` from a previous HTTP response, e.g. `If-Match: \"hash:a75ece4e\"`   * retrieving or modifying a resource only if it already exists, e.g. `If-Match: *`
 * @param "IfNoneMatch" (optional.String) -  The `If-None-Match` header, which has to conform to RFC-7232 (Conditional Requests). A common usage scenario is to modify a resource only if it does not yet exist, thus to create it, by specifying `If-None-Match: *`.
 * @param "RequestedAcks" (optional.String) -  Contains the \"requested acknowledgements\" for this modifying request as comma separated list. The HTTP call will block until all requested acknowledgements were aggregated or will time out based on the specified `timeout` parameter.  The default (if omitted) requested acks is `requested-acks=twin-persisted` which will block the HTTP call until the change was persited to the twin.
 * @param "Timeout" (optional.String) -  Defines how long the backend should wait for completion of the request, e.g. applied when waiting for requested acknowledgements via the `requested-acks` param. Can be specified without unit (then seconds are assumed) or together with `s`, `ms` or `m` unit. Example: `42s`, `1m`.  The default (if omitted) timeout is `10s`. Maximum value: `60s`.  A value of `0` applies fire and forget semantics for the command resulting in setting `response-required=false`.
 * @param "ResponseRequired" (optional.Bool) -  Defines whether a response is required to the API call or not - if set to `false` the response will directly sent back with a status code of `202` (Accepted).  The default (if ommited) response is `true`.
*/
func (a *FeaturesApiService) ThingsThingIdFeaturesFeatureIdDelete(ctx _context.Context, thingId string, featureId string, localVarOptionals *ThingsThingIdFeaturesFeatureIdDeleteOpts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/things/{thingId}/features/{featureId}"
	localVarPath = strings.Replace(localVarPath, "{"+"thingId"+"}", _neturl.QueryEscape(parameterToString(thingId, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"featureId"+"}", _neturl.QueryEscape(parameterToString(featureId, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.RequestedAcks.IsSet() {
		localVarQueryParams.Add("requested-acks", parameterToString(localVarOptionals.RequestedAcks.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Timeout.IsSet() {
		localVarQueryParams.Add("timeout", parameterToString(localVarOptionals.Timeout.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ResponseRequired.IsSet() {
		localVarQueryParams.Add("response-required", parameterToString(localVarOptionals.ResponseRequired.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.IfMatch.IsSet() {
		localVarHeaderParams["If-Match"] = parameterToString(localVarOptionals.IfMatch.Value(), "")
	}
	if localVarOptionals != nil && localVarOptionals.IfNoneMatch.IsSet() {
		localVarHeaderParams["If-None-Match"] = parameterToString(localVarOptionals.IfNoneMatch.Value(), "")
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-cr-api-token"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 402 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 412 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// ThingsThingIdFeaturesFeatureIdGetOpts Optional parameters for the method 'ThingsThingIdFeaturesFeatureIdGet'
type ThingsThingIdFeaturesFeatureIdGetOpts struct {
    Fields optional.String
    IfMatch optional.String
    IfNoneMatch optional.String
    Timeout optional.String
}

/*
ThingsThingIdFeaturesFeatureIdGet Retrieve a specific feature of a specific thing
Returns a specific feature identified by the &#x60;featureId&#x60; path parameter of the thing identified by the &#x60;thingId&#x60; path parameter.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param thingId The ID of a thing needs to follow the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).  The namespace needs to be registered for your solution
 * @param featureId The ID of the feature - has to conform to RFC-3986 (URI)
 * @param optional nil or *ThingsThingIdFeaturesFeatureIdGetOpts - Optional Parameters:
 * @param "Fields" (optional.String) -  Contains a comma-separated list of fields from the selected feature to be included in the returned JSON.  #### Selectable fields  * `properties`    Supports selecting arbitrary sub-fields by using a comma-separated list:     * several properties paths can be passed as a comma-separated list of JSON pointers (RFC-6901)        For example:         * `?fields=properties/color` would select only `color` property value (if present)         * `?fields=properties/color,properties/brightness` would select only `color` and `brightness` property values (if present)    Supports selecting arbitrary sub-fields of objects by wrapping sub-fields inside parentheses `( )`:     * a comma-separated list of sub-fields (a sub-field is a JSON pointer (RFC-6901) separated with `/`) to select     * sub-selectors can be used to request only specific sub-fields by placing expressions in parentheses `( )` after a selected subfield        For example:        * `?fields=properties(color,brightness)` would select only `color` and `brightness` property values (if present)        * `?fields=properties(location/longitude)` would select the `longitude` value inside the `location` object  #### Examples  * `?fields=properties(color,brightness)`
 * @param "IfMatch" (optional.String) -  The `If-Match` header which has to conform to RFC-7232 (Conditional Requests). Common usages are:   * optimistic locking by specifying the `ETag` from a previous HTTP response, e.g. `If-Match: \"hash:a75ece4e\"`   * retrieving or modifying a resource only if it already exists, e.g. `If-Match: *`
 * @param "IfNoneMatch" (optional.String) -  The `If-None-Match` header, which has to conform to RFC-7232 (Conditional Requests). A common usage scenario is to modify a resource only if it does not yet exist, thus to create it, by specifying `If-None-Match: *`.
 * @param "Timeout" (optional.String) -  Defines how long the backend should wait for completion of the request, e.g. applied when waiting for requested acknowledgements via the `requested-acks` param. Can be specified without unit (then seconds are assumed) or together with `s`, `ms` or `m` unit. Example: `42s`, `1m`.  The default (if omitted) timeout is `10s`. Maximum value: `60s`.  A value of `0` applies fire and forget semantics for the command resulting in setting `response-required=false`.
@return Feature
*/
func (a *FeaturesApiService) ThingsThingIdFeaturesFeatureIdGet(ctx _context.Context, thingId string, featureId string, localVarOptionals *ThingsThingIdFeaturesFeatureIdGetOpts) (Feature, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Feature
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/things/{thingId}/features/{featureId}"
	localVarPath = strings.Replace(localVarPath, "{"+"thingId"+"}", _neturl.QueryEscape(parameterToString(thingId, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"featureId"+"}", _neturl.QueryEscape(parameterToString(featureId, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Timeout.IsSet() {
		localVarQueryParams.Add("timeout", parameterToString(localVarOptionals.Timeout.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.IfMatch.IsSet() {
		localVarHeaderParams["If-Match"] = parameterToString(localVarOptionals.IfMatch.Value(), "")
	}
	if localVarOptionals != nil && localVarOptionals.IfNoneMatch.IsSet() {
		localVarHeaderParams["If-None-Match"] = parameterToString(localVarOptionals.IfNoneMatch.Value(), "")
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-cr-api-token"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 402 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 412 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// ThingsThingIdFeaturesFeatureIdPropertiesDeleteOpts Optional parameters for the method 'ThingsThingIdFeaturesFeatureIdPropertiesDelete'
type ThingsThingIdFeaturesFeatureIdPropertiesDeleteOpts struct {
    IfMatch optional.String
    IfNoneMatch optional.String
    RequestedAcks optional.String
    Timeout optional.String
    ResponseRequired optional.Bool
}

/*
ThingsThingIdFeaturesFeatureIdPropertiesDelete Delete all properties of a feature
Deletes all properties of the feature identified by the &#x60;thingId&#x60; and &#x60;featureId&#x60; path parameter.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param thingId The ID of a thing needs to follow the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).  The namespace needs to be registered for your solution
 * @param featureId The ID of the feature - has to conform to RFC-3986 (URI)
 * @param optional nil or *ThingsThingIdFeaturesFeatureIdPropertiesDeleteOpts - Optional Parameters:
 * @param "IfMatch" (optional.String) -  The `If-Match` header which has to conform to RFC-7232 (Conditional Requests). Common usages are:   * optimistic locking by specifying the `ETag` from a previous HTTP response, e.g. `If-Match: \"hash:a75ece4e\"`   * retrieving or modifying a resource only if it already exists, e.g. `If-Match: *`
 * @param "IfNoneMatch" (optional.String) -  The `If-None-Match` header, which has to conform to RFC-7232 (Conditional Requests). A common usage scenario is to modify a resource only if it does not yet exist, thus to create it, by specifying `If-None-Match: *`.
 * @param "RequestedAcks" (optional.String) -  Contains the \"requested acknowledgements\" for this modifying request as comma separated list. The HTTP call will block until all requested acknowledgements were aggregated or will time out based on the specified `timeout` parameter.  The default (if omitted) requested acks is `requested-acks=twin-persisted` which will block the HTTP call until the change was persited to the twin.
 * @param "Timeout" (optional.String) -  Defines how long the backend should wait for completion of the request, e.g. applied when waiting for requested acknowledgements via the `requested-acks` param. Can be specified without unit (then seconds are assumed) or together with `s`, `ms` or `m` unit. Example: `42s`, `1m`.  The default (if omitted) timeout is `10s`. Maximum value: `60s`.  A value of `0` applies fire and forget semantics for the command resulting in setting `response-required=false`.
 * @param "ResponseRequired" (optional.Bool) -  Defines whether a response is required to the API call or not - if set to `false` the response will directly sent back with a status code of `202` (Accepted).  The default (if ommited) response is `true`.
*/
func (a *FeaturesApiService) ThingsThingIdFeaturesFeatureIdPropertiesDelete(ctx _context.Context, thingId string, featureId string, localVarOptionals *ThingsThingIdFeaturesFeatureIdPropertiesDeleteOpts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/things/{thingId}/features/{featureId}/properties"
	localVarPath = strings.Replace(localVarPath, "{"+"thingId"+"}", _neturl.QueryEscape(parameterToString(thingId, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"featureId"+"}", _neturl.QueryEscape(parameterToString(featureId, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.RequestedAcks.IsSet() {
		localVarQueryParams.Add("requested-acks", parameterToString(localVarOptionals.RequestedAcks.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Timeout.IsSet() {
		localVarQueryParams.Add("timeout", parameterToString(localVarOptionals.Timeout.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ResponseRequired.IsSet() {
		localVarQueryParams.Add("response-required", parameterToString(localVarOptionals.ResponseRequired.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.IfMatch.IsSet() {
		localVarHeaderParams["If-Match"] = parameterToString(localVarOptionals.IfMatch.Value(), "")
	}
	if localVarOptionals != nil && localVarOptionals.IfNoneMatch.IsSet() {
		localVarHeaderParams["If-None-Match"] = parameterToString(localVarOptionals.IfNoneMatch.Value(), "")
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-cr-api-token"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 402 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 412 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// ThingsThingIdFeaturesFeatureIdPropertiesGetOpts Optional parameters for the method 'ThingsThingIdFeaturesFeatureIdPropertiesGet'
type ThingsThingIdFeaturesFeatureIdPropertiesGetOpts struct {
    Fields optional.String
    IfMatch optional.String
    IfNoneMatch optional.String
    Timeout optional.String
}

/*
ThingsThingIdFeaturesFeatureIdPropertiesGet List all properties of a feature
Returns all properties of the feature identified by the &#x60;thingId&#x60; and &#x60;featureId&#x60; path parameter.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param thingId The ID of a thing needs to follow the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).  The namespace needs to be registered for your solution
 * @param featureId The ID of the feature - has to conform to RFC-3986 (URI)
 * @param optional nil or *ThingsThingIdFeaturesFeatureIdPropertiesGetOpts - Optional Parameters:
 * @param "Fields" (optional.String) -  Contains a comma-separated list of fields from the properties to be included in the returned JSON.  #### Selectable fields  Supports selecting arbitrary sub-fields as defined in the properties by using a comma-separated list:   * several properties paths can be passed as a comma-separated list of JSON pointers (RFC-6901)      For example:       * `?fields=temperature` would select only `temperature` property value (if present)       * `?fields=temperature,humidity` would select only `temperature` and `humidity` property values (if present)  Supports selecting arbitrary sub-fields of objects by wrapping sub-fields inside parentheses `( )`:   * a comma-separated list of sub-fields (a sub-field is a JSON pointer (RFC-6901) separated with `/`) to select   * sub-selectors can be used to request only specific sub-fields by placing expressions in parentheses `( )` after a selected subfield      For example:      * `?fields=location(longitude,latitude)` would select the `longitude` and `latitude` value inside the `location` property  #### Examples  * `?fields=temperature,humidity,location(longitude,latitude)`  * `?fields=configuration,status(powerConsumption/watts)`
 * @param "IfMatch" (optional.String) -  The `If-Match` header which has to conform to RFC-7232 (Conditional Requests). Common usages are:   * optimistic locking by specifying the `ETag` from a previous HTTP response, e.g. `If-Match: \"hash:a75ece4e\"`   * retrieving or modifying a resource only if it already exists, e.g. `If-Match: *`
 * @param "IfNoneMatch" (optional.String) -  The `If-None-Match` header, which has to conform to RFC-7232 (Conditional Requests). A common usage scenario is to modify a resource only if it does not yet exist, thus to create it, by specifying `If-None-Match: *`.
 * @param "Timeout" (optional.String) -  Defines how long the backend should wait for completion of the request, e.g. applied when waiting for requested acknowledgements via the `requested-acks` param. Can be specified without unit (then seconds are assumed) or together with `s`, `ms` or `m` unit. Example: `42s`, `1m`.  The default (if omitted) timeout is `10s`. Maximum value: `60s`.  A value of `0` applies fire and forget semantics for the command resulting in setting `response-required=false`.
@return map[string]interface{}
*/
func (a *FeaturesApiService) ThingsThingIdFeaturesFeatureIdPropertiesGet(ctx _context.Context, thingId string, featureId string, localVarOptionals *ThingsThingIdFeaturesFeatureIdPropertiesGetOpts) (map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  map[string]interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/things/{thingId}/features/{featureId}/properties"
	localVarPath = strings.Replace(localVarPath, "{"+"thingId"+"}", _neturl.QueryEscape(parameterToString(thingId, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"featureId"+"}", _neturl.QueryEscape(parameterToString(featureId, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Timeout.IsSet() {
		localVarQueryParams.Add("timeout", parameterToString(localVarOptionals.Timeout.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.IfMatch.IsSet() {
		localVarHeaderParams["If-Match"] = parameterToString(localVarOptionals.IfMatch.Value(), "")
	}
	if localVarOptionals != nil && localVarOptionals.IfNoneMatch.IsSet() {
		localVarHeaderParams["If-None-Match"] = parameterToString(localVarOptionals.IfNoneMatch.Value(), "")
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-cr-api-token"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 402 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 412 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// ThingsThingIdFeaturesFeatureIdPropertiesPropertyPathDeleteOpts Optional parameters for the method 'ThingsThingIdFeaturesFeatureIdPropertiesPropertyPathDelete'
type ThingsThingIdFeaturesFeatureIdPropertiesPropertyPathDeleteOpts struct {
    IfMatch optional.String
    IfNoneMatch optional.String
    RequestedAcks optional.String
    Timeout optional.String
    ResponseRequired optional.Bool
}

/*
ThingsThingIdFeaturesFeatureIdPropertiesPropertyPathDelete Delete a specific property of a feature
Deletes a specific property of the feature identified by the &#x60;thingId&#x60; and &#x60;featureId&#x60; path parameter.  The property (JSON) can be referenced hierarchically, by applying JSON Pointer notation (RFC-6901)  ### Example To delete the value of the brewingTemp in the water-tank of our coffeemaker example the full path is:  &#x60;/things/{thingId}/features/water-tank/properties/configuration/brewingTemp&#x60;
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param thingId The ID of a thing needs to follow the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).  The namespace needs to be registered for your solution
 * @param featureId The ID of the feature - has to conform to RFC-3986 (URI)
 * @param propertyPath The path to the property
 * @param optional nil or *ThingsThingIdFeaturesFeatureIdPropertiesPropertyPathDeleteOpts - Optional Parameters:
 * @param "IfMatch" (optional.String) -  The `If-Match` header which has to conform to RFC-7232 (Conditional Requests). Common usages are:   * optimistic locking by specifying the `ETag` from a previous HTTP response, e.g. `If-Match: \"hash:a75ece4e\"`   * retrieving or modifying a resource only if it already exists, e.g. `If-Match: *`
 * @param "IfNoneMatch" (optional.String) -  The `If-None-Match` header, which has to conform to RFC-7232 (Conditional Requests). A common usage scenario is to modify a resource only if it does not yet exist, thus to create it, by specifying `If-None-Match: *`.
 * @param "RequestedAcks" (optional.String) -  Contains the \"requested acknowledgements\" for this modifying request as comma separated list. The HTTP call will block until all requested acknowledgements were aggregated or will time out based on the specified `timeout` parameter.  The default (if omitted) requested acks is `requested-acks=twin-persisted` which will block the HTTP call until the change was persited to the twin.
 * @param "Timeout" (optional.String) -  Defines how long the backend should wait for completion of the request, e.g. applied when waiting for requested acknowledgements via the `requested-acks` param. Can be specified without unit (then seconds are assumed) or together with `s`, `ms` or `m` unit. Example: `42s`, `1m`.  The default (if omitted) timeout is `10s`. Maximum value: `60s`.  A value of `0` applies fire and forget semantics for the command resulting in setting `response-required=false`.
 * @param "ResponseRequired" (optional.Bool) -  Defines whether a response is required to the API call or not - if set to `false` the response will directly sent back with a status code of `202` (Accepted).  The default (if ommited) response is `true`.
*/
func (a *FeaturesApiService) ThingsThingIdFeaturesFeatureIdPropertiesPropertyPathDelete(ctx _context.Context, thingId string, featureId string, propertyPath string, localVarOptionals *ThingsThingIdFeaturesFeatureIdPropertiesPropertyPathDeleteOpts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/things/{thingId}/features/{featureId}/properties/{propertyPath}"
	localVarPath = strings.Replace(localVarPath, "{"+"thingId"+"}", _neturl.QueryEscape(parameterToString(thingId, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"featureId"+"}", _neturl.QueryEscape(parameterToString(featureId, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"propertyPath"+"}", _neturl.QueryEscape(parameterToString(propertyPath, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.RequestedAcks.IsSet() {
		localVarQueryParams.Add("requested-acks", parameterToString(localVarOptionals.RequestedAcks.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Timeout.IsSet() {
		localVarQueryParams.Add("timeout", parameterToString(localVarOptionals.Timeout.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ResponseRequired.IsSet() {
		localVarQueryParams.Add("response-required", parameterToString(localVarOptionals.ResponseRequired.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.IfMatch.IsSet() {
		localVarHeaderParams["If-Match"] = parameterToString(localVarOptionals.IfMatch.Value(), "")
	}
	if localVarOptionals != nil && localVarOptionals.IfNoneMatch.IsSet() {
		localVarHeaderParams["If-None-Match"] = parameterToString(localVarOptionals.IfNoneMatch.Value(), "")
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-cr-api-token"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 402 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 412 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// ThingsThingIdFeaturesFeatureIdPropertiesPropertyPathGetOpts Optional parameters for the method 'ThingsThingIdFeaturesFeatureIdPropertiesPropertyPathGet'
type ThingsThingIdFeaturesFeatureIdPropertiesPropertyPathGetOpts struct {
    IfMatch optional.String
    IfNoneMatch optional.String
    Timeout optional.String
}

/*
ThingsThingIdFeaturesFeatureIdPropertiesPropertyPathGet Retrieve a specific property of a feature
Returns the a specific property path of the feature identified by the &#x60;thingId&#x60; and &#x60;featureId&#x60; path parameter.  The property (JSON) can be referenced hierarchically, by applying JSON Pointer notation (RFC-6901)  ### Example To retrieve the value of the &#x60;brewingTemp&#x60; in the &#x60;water-tank&#x60; of our coffeemaker example the full path is:  &#x60;/things/{thingId}/features/water-tank/properties/configuration/brewingTemp&#x60;
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param thingId The ID of a thing needs to follow the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).  The namespace needs to be registered for your solution
 * @param featureId The ID of the feature - has to conform to RFC-3986 (URI)
 * @param propertyPath The path to the property
 * @param optional nil or *ThingsThingIdFeaturesFeatureIdPropertiesPropertyPathGetOpts - Optional Parameters:
 * @param "IfMatch" (optional.String) -  The `If-Match` header which has to conform to RFC-7232 (Conditional Requests). Common usages are:   * optimistic locking by specifying the `ETag` from a previous HTTP response, e.g. `If-Match: \"hash:a75ece4e\"`   * retrieving or modifying a resource only if it already exists, e.g. `If-Match: *`
 * @param "IfNoneMatch" (optional.String) -  The `If-None-Match` header, which has to conform to RFC-7232 (Conditional Requests). A common usage scenario is to modify a resource only if it does not yet exist, thus to create it, by specifying `If-None-Match: *`.
 * @param "Timeout" (optional.String) -  Defines how long the backend should wait for completion of the request, e.g. applied when waiting for requested acknowledgements via the `requested-acks` param. Can be specified without unit (then seconds are assumed) or together with `s`, `ms` or `m` unit. Example: `42s`, `1m`.  The default (if omitted) timeout is `10s`. Maximum value: `60s`.  A value of `0` applies fire and forget semantics for the command resulting in setting `response-required=false`.
*/
func (a *FeaturesApiService) ThingsThingIdFeaturesFeatureIdPropertiesPropertyPathGet(ctx _context.Context, thingId string, featureId string, propertyPath string, localVarOptionals *ThingsThingIdFeaturesFeatureIdPropertiesPropertyPathGetOpts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/things/{thingId}/features/{featureId}/properties/{propertyPath}"
	localVarPath = strings.Replace(localVarPath, "{"+"thingId"+"}", _neturl.QueryEscape(parameterToString(thingId, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"featureId"+"}", _neturl.QueryEscape(parameterToString(featureId, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"propertyPath"+"}", _neturl.QueryEscape(parameterToString(propertyPath, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Timeout.IsSet() {
		localVarQueryParams.Add("timeout", parameterToString(localVarOptionals.Timeout.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.IfMatch.IsSet() {
		localVarHeaderParams["If-Match"] = parameterToString(localVarOptionals.IfMatch.Value(), "")
	}
	if localVarOptionals != nil && localVarOptionals.IfNoneMatch.IsSet() {
		localVarHeaderParams["If-None-Match"] = parameterToString(localVarOptionals.IfNoneMatch.Value(), "")
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-cr-api-token"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 402 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 412 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// ThingsThingIdFeaturesFeatureIdPropertiesPropertyPathPutOpts Optional parameters for the method 'ThingsThingIdFeaturesFeatureIdPropertiesPropertyPathPut'
type ThingsThingIdFeaturesFeatureIdPropertiesPropertyPathPutOpts struct {
    IfMatch optional.String
    IfNoneMatch optional.String
    RequestedAcks optional.String
    Timeout optional.String
    ResponseRequired optional.Bool
}

/*
ThingsThingIdFeaturesFeatureIdPropertiesPropertyPathPut Create or update a specific property of a feature
Create or update a specific property of a feature identified by the &#x60;thingId&#x60; and &#x60;featureId&#x60; path parameter.  The property will be created if it doesn&#39;t exist or else updated.  The property (JSON) can be referenced hierarchically, by applying JSON Pointer notation (RFC-6901),  ### Example To set the value of the brewingTemp in the water-tank of our coffeemaker example the full path is:  &#x60;/things/{thingId}/features/water-tank/properties/configuration/brewingTemp&#x60;
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param thingId The ID of a thing needs to follow the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).  The namespace needs to be registered for your solution
 * @param featureId The ID of the feature - has to conform to RFC-3986 (URI)
 * @param propertyPath The path to the property
 * @param body JSON representation of the value to be created/updated. This may be as well `null` or an empty object.  Consider that the value has to be a JSON value, examples:    * for a number, the JSON value is the number: `42`    * for a string, the JSON value must be quoted: `\"aString\"`    * for a boolean, the JSON value is the boolean: `true`    * for an object, the JSON value is the object: `{ \"key\": \"value\"}` -} We strongly recommend to use a restricted set of characters for the key (identifier). Currently these identifiers should follow the pattern: [_a-zA-Z][_a-zA-Z0-9\\-]*    * for an list, the JSON value is the list: `[ 1,2,3 ]`
 * @param optional nil or *ThingsThingIdFeaturesFeatureIdPropertiesPropertyPathPutOpts - Optional Parameters:
 * @param "IfMatch" (optional.String) -  The `If-Match` header which has to conform to RFC-7232 (Conditional Requests). Common usages are:   * optimistic locking by specifying the `ETag` from a previous HTTP response, e.g. `If-Match: \"hash:a75ece4e\"`   * retrieving or modifying a resource only if it already exists, e.g. `If-Match: *`
 * @param "IfNoneMatch" (optional.String) -  The `If-None-Match` header, which has to conform to RFC-7232 (Conditional Requests). A common usage scenario is to modify a resource only if it does not yet exist, thus to create it, by specifying `If-None-Match: *`.
 * @param "RequestedAcks" (optional.String) -  Contains the \"requested acknowledgements\" for this modifying request as comma separated list. The HTTP call will block until all requested acknowledgements were aggregated or will time out based on the specified `timeout` parameter.  The default (if omitted) requested acks is `requested-acks=twin-persisted` which will block the HTTP call until the change was persited to the twin.
 * @param "Timeout" (optional.String) -  Defines how long the backend should wait for completion of the request, e.g. applied when waiting for requested acknowledgements via the `requested-acks` param. Can be specified without unit (then seconds are assumed) or together with `s`, `ms` or `m` unit. Example: `42s`, `1m`.  The default (if omitted) timeout is `10s`. Maximum value: `60s`.  A value of `0` applies fire and forget semantics for the command resulting in setting `response-required=false`.
 * @param "ResponseRequired" (optional.Bool) -  Defines whether a response is required to the API call or not - if set to `false` the response will directly sent back with a status code of `202` (Accepted).  The default (if ommited) response is `true`.
*/
func (a *FeaturesApiService) ThingsThingIdFeaturesFeatureIdPropertiesPropertyPathPut(ctx _context.Context, thingId string, featureId string, propertyPath string, body map[string]interface{}, localVarOptionals *ThingsThingIdFeaturesFeatureIdPropertiesPropertyPathPutOpts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/things/{thingId}/features/{featureId}/properties/{propertyPath}"
	localVarPath = strings.Replace(localVarPath, "{"+"thingId"+"}", _neturl.QueryEscape(parameterToString(thingId, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"featureId"+"}", _neturl.QueryEscape(parameterToString(featureId, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"propertyPath"+"}", _neturl.QueryEscape(parameterToString(propertyPath, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.RequestedAcks.IsSet() {
		localVarQueryParams.Add("requested-acks", parameterToString(localVarOptionals.RequestedAcks.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Timeout.IsSet() {
		localVarQueryParams.Add("timeout", parameterToString(localVarOptionals.Timeout.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ResponseRequired.IsSet() {
		localVarQueryParams.Add("response-required", parameterToString(localVarOptionals.ResponseRequired.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.IfMatch.IsSet() {
		localVarHeaderParams["If-Match"] = parameterToString(localVarOptionals.IfMatch.Value(), "")
	}
	if localVarOptionals != nil && localVarOptionals.IfNoneMatch.IsSet() {
		localVarHeaderParams["If-None-Match"] = parameterToString(localVarOptionals.IfNoneMatch.Value(), "")
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-cr-api-token"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 402 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 412 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 413 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// ThingsThingIdFeaturesFeatureIdPropertiesPutOpts Optional parameters for the method 'ThingsThingIdFeaturesFeatureIdPropertiesPut'
type ThingsThingIdFeaturesFeatureIdPropertiesPutOpts struct {
    IfMatch optional.String
    IfNoneMatch optional.String
    RequestedAcks optional.String
    Timeout optional.String
    ResponseRequired optional.Bool
}

/*
ThingsThingIdFeaturesFeatureIdPropertiesPut Create or update all properties of a feature at once
Create or update the properties of a feature identified by the &#x60;thingId&#x60; and &#x60;featureId&#x60; path parameter.  The properties will be overwritten with the JSON content from the request body.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param thingId The ID of a thing needs to follow the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).  The namespace needs to be registered for your solution
 * @param featureId The ID of the feature - has to conform to RFC-3986 (URI)
 * @param body JSON object of all properties to be updated at once.  Consider that the value has to be a JSON object or `null`. We strongly recommend to use a restricted set of characters for the key (identifier).  Currently these identifiers should follow the pattern: [_a-zA-Z][_a-zA-Z0-9\\-]*
 * @param optional nil or *ThingsThingIdFeaturesFeatureIdPropertiesPutOpts - Optional Parameters:
 * @param "IfMatch" (optional.String) -  The `If-Match` header which has to conform to RFC-7232 (Conditional Requests). Common usages are:   * optimistic locking by specifying the `ETag` from a previous HTTP response, e.g. `If-Match: \"hash:a75ece4e\"`   * retrieving or modifying a resource only if it already exists, e.g. `If-Match: *`
 * @param "IfNoneMatch" (optional.String) -  The `If-None-Match` header, which has to conform to RFC-7232 (Conditional Requests). A common usage scenario is to modify a resource only if it does not yet exist, thus to create it, by specifying `If-None-Match: *`.
 * @param "RequestedAcks" (optional.String) -  Contains the \"requested acknowledgements\" for this modifying request as comma separated list. The HTTP call will block until all requested acknowledgements were aggregated or will time out based on the specified `timeout` parameter.  The default (if omitted) requested acks is `requested-acks=twin-persisted` which will block the HTTP call until the change was persited to the twin.
 * @param "Timeout" (optional.String) -  Defines how long the backend should wait for completion of the request, e.g. applied when waiting for requested acknowledgements via the `requested-acks` param. Can be specified without unit (then seconds are assumed) or together with `s`, `ms` or `m` unit. Example: `42s`, `1m`.  The default (if omitted) timeout is `10s`. Maximum value: `60s`.  A value of `0` applies fire and forget semantics for the command resulting in setting `response-required=false`.
 * @param "ResponseRequired" (optional.Bool) -  Defines whether a response is required to the API call or not - if set to `false` the response will directly sent back with a status code of `202` (Accepted).  The default (if ommited) response is `true`.
@return map[string]interface{}
*/
func (a *FeaturesApiService) ThingsThingIdFeaturesFeatureIdPropertiesPut(ctx _context.Context, thingId string, featureId string, body map[string]interface{}, localVarOptionals *ThingsThingIdFeaturesFeatureIdPropertiesPutOpts) (map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  map[string]interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/things/{thingId}/features/{featureId}/properties"
	localVarPath = strings.Replace(localVarPath, "{"+"thingId"+"}", _neturl.QueryEscape(parameterToString(thingId, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"featureId"+"}", _neturl.QueryEscape(parameterToString(featureId, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.RequestedAcks.IsSet() {
		localVarQueryParams.Add("requested-acks", parameterToString(localVarOptionals.RequestedAcks.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Timeout.IsSet() {
		localVarQueryParams.Add("timeout", parameterToString(localVarOptionals.Timeout.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ResponseRequired.IsSet() {
		localVarQueryParams.Add("response-required", parameterToString(localVarOptionals.ResponseRequired.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.IfMatch.IsSet() {
		localVarHeaderParams["If-Match"] = parameterToString(localVarOptionals.IfMatch.Value(), "")
	}
	if localVarOptionals != nil && localVarOptionals.IfNoneMatch.IsSet() {
		localVarHeaderParams["If-None-Match"] = parameterToString(localVarOptionals.IfNoneMatch.Value(), "")
	}
	// body params
	localVarPostBody = &body
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-cr-api-token"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 402 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 412 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 413 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// ThingsThingIdFeaturesFeatureIdPutOpts Optional parameters for the method 'ThingsThingIdFeaturesFeatureIdPut'
type ThingsThingIdFeaturesFeatureIdPutOpts struct {
    IfMatch optional.String
    IfNoneMatch optional.String
    RequestedAcks optional.String
    Timeout optional.String
    ResponseRequired optional.Bool
}

/*
ThingsThingIdFeaturesFeatureIdPut Create or modify a specific feature of a specific thing
Create or modify a specific feature identified by the &#x60;featureId&#x60; path parameter of the thing identified by the &#x60;thingId&#x60; path parameter.  ### Create feature If the feature ID is new, the feature and all content from the JSON body will be created  ### Update feature If the feature ID is used already in this thing, the feature will be overwrittern with the content from the JSON body.  Example: Set the &#x60;featureId&#x60; to **coffee-brewer** and all properties in the body part.  &#x60;&#x60;&#x60; {   \&quot;definition\&quot;: [\&quot;com.acme:coffeebrewer:0.1.0\&quot;],   \&quot;properties\&quot;: {     \&quot;brewed-coffees\&quot;: 42   } } &#x60;&#x60;&#x60;
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param thingId The ID of a thing needs to follow the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).  The namespace needs to be registered for your solution
 * @param featureId The ID of the feature - has to conform to RFC-3986 (URI)
 * @param feature JSON representation of the feature to be created/modified. Consider that the value has to be a JSON object or null.  Examples: * an empty object: {} - would just create the featureID but would delete all content of the feature * a nested object with multiple model definitions and multiple properties as shown in the example value field
 * @param optional nil or *ThingsThingIdFeaturesFeatureIdPutOpts - Optional Parameters:
 * @param "IfMatch" (optional.String) -  The `If-Match` header which has to conform to RFC-7232 (Conditional Requests). Common usages are:   * optimistic locking by specifying the `ETag` from a previous HTTP response, e.g. `If-Match: \"hash:a75ece4e\"`   * retrieving or modifying a resource only if it already exists, e.g. `If-Match: *`
 * @param "IfNoneMatch" (optional.String) -  The `If-None-Match` header, which has to conform to RFC-7232 (Conditional Requests). A common usage scenario is to modify a resource only if it does not yet exist, thus to create it, by specifying `If-None-Match: *`.
 * @param "RequestedAcks" (optional.String) -  Contains the \"requested acknowledgements\" for this modifying request as comma separated list. The HTTP call will block until all requested acknowledgements were aggregated or will time out based on the specified `timeout` parameter.  The default (if omitted) requested acks is `requested-acks=twin-persisted` which will block the HTTP call until the change was persited to the twin.
 * @param "Timeout" (optional.String) -  Defines how long the backend should wait for completion of the request, e.g. applied when waiting for requested acknowledgements via the `requested-acks` param. Can be specified without unit (then seconds are assumed) or together with `s`, `ms` or `m` unit. Example: `42s`, `1m`.  The default (if omitted) timeout is `10s`. Maximum value: `60s`.  A value of `0` applies fire and forget semantics for the command resulting in setting `response-required=false`.
 * @param "ResponseRequired" (optional.Bool) -  Defines whether a response is required to the API call or not - if set to `false` the response will directly sent back with a status code of `202` (Accepted).  The default (if ommited) response is `true`.
@return Feature
*/
func (a *FeaturesApiService) ThingsThingIdFeaturesFeatureIdPut(ctx _context.Context, thingId string, featureId string, feature Feature, localVarOptionals *ThingsThingIdFeaturesFeatureIdPutOpts) (Feature, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Feature
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/things/{thingId}/features/{featureId}"
	localVarPath = strings.Replace(localVarPath, "{"+"thingId"+"}", _neturl.QueryEscape(parameterToString(thingId, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"featureId"+"}", _neturl.QueryEscape(parameterToString(featureId, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.RequestedAcks.IsSet() {
		localVarQueryParams.Add("requested-acks", parameterToString(localVarOptionals.RequestedAcks.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Timeout.IsSet() {
		localVarQueryParams.Add("timeout", parameterToString(localVarOptionals.Timeout.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ResponseRequired.IsSet() {
		localVarQueryParams.Add("response-required", parameterToString(localVarOptionals.ResponseRequired.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.IfMatch.IsSet() {
		localVarHeaderParams["If-Match"] = parameterToString(localVarOptionals.IfMatch.Value(), "")
	}
	if localVarOptionals != nil && localVarOptionals.IfNoneMatch.IsSet() {
		localVarHeaderParams["If-None-Match"] = parameterToString(localVarOptionals.IfNoneMatch.Value(), "")
	}
	// body params
	localVarPostBody = &feature
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-cr-api-token"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 402 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 412 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 413 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// ThingsThingIdFeaturesGetOpts Optional parameters for the method 'ThingsThingIdFeaturesGet'
type ThingsThingIdFeaturesGetOpts struct {
    Fields optional.String
    IfMatch optional.String
    IfNoneMatch optional.String
    Timeout optional.String
}

/*
ThingsThingIdFeaturesGet List all features of a specific thing
Returns all features of the thing identified by the &#x60;thingId&#x60; path parameter.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param thingId The ID of a thing needs to follow the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).  The namespace needs to be registered for your solution
 * @param optional nil or *ThingsThingIdFeaturesGetOpts - Optional Parameters:
 * @param "Fields" (optional.String) -  Contains a comma-separated list of fields from one or more features to be included in the returned JSON.  #### Selectable fields  * `{featureId}` The ID of the feature to select properties in   * `properties`     Supports selecting arbitrary sub-fields by using a comma-separated list:       * several properties paths can be passed as a comma-separated list of JSON pointers (RFC-6901)         For example:           * `?fields={featureId}/properties/color` would select only `color` property value (if present) of the feature identified with `{featureId}`           * `?fields={featureId}/properties/color,properties/brightness` would select only `color` and `brightness` property values (if present) of the feature identified with `{featureId}`     Supports selecting arbitrary sub-fields of objects by wrapping sub-fields inside parentheses `( )`:       * a comma-separated list of sub-fields (a sub-field is a JSON pointer (RFC-6901) separated with `/`) to select       * sub-selectors can be used to request only specific sub-fields by placing expressions in parentheses `( )` after a selected subfield         For example:          * `?fields={featureId}/properties(color,brightness)` would select only `color` and `brightness` property values (if present) of the feature identified with `{featureId}`          * `?fields={featureId}/properties(location/longitude)` would select the `longitude` value inside the `location` object of the feature identified with `{featureId}`   #### Examples * `?fields=EnvironmentScanner/properties(temperature,humidity)` * `?fields=EnvironmentScanner/properties(temperature,humidity),Vehicle/properties/configuration`
 * @param "IfMatch" (optional.String) -  The `If-Match` header which has to conform to RFC-7232 (Conditional Requests). Common usages are:   * optimistic locking by specifying the `ETag` from a previous HTTP response, e.g. `If-Match: \"hash:a75ece4e\"`   * retrieving or modifying a resource only if it already exists, e.g. `If-Match: *`
 * @param "IfNoneMatch" (optional.String) -  The `If-None-Match` header, which has to conform to RFC-7232 (Conditional Requests). A common usage scenario is to modify a resource only if it does not yet exist, thus to create it, by specifying `If-None-Match: *`.
 * @param "Timeout" (optional.String) -  Defines how long the backend should wait for completion of the request, e.g. applied when waiting for requested acknowledgements via the `requested-acks` param. Can be specified without unit (then seconds are assumed) or together with `s`, `ms` or `m` unit. Example: `42s`, `1m`.  The default (if omitted) timeout is `10s`. Maximum value: `60s`.  A value of `0` applies fire and forget semantics for the command resulting in setting `response-required=false`.
@return map[string]Feature
*/
func (a *FeaturesApiService) ThingsThingIdFeaturesGet(ctx _context.Context, thingId string, localVarOptionals *ThingsThingIdFeaturesGetOpts) (map[string]Feature, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  map[string]Feature
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/things/{thingId}/features"
	localVarPath = strings.Replace(localVarPath, "{"+"thingId"+"}", _neturl.QueryEscape(parameterToString(thingId, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Timeout.IsSet() {
		localVarQueryParams.Add("timeout", parameterToString(localVarOptionals.Timeout.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.IfMatch.IsSet() {
		localVarHeaderParams["If-Match"] = parameterToString(localVarOptionals.IfMatch.Value(), "")
	}
	if localVarOptionals != nil && localVarOptionals.IfNoneMatch.IsSet() {
		localVarHeaderParams["If-None-Match"] = parameterToString(localVarOptionals.IfNoneMatch.Value(), "")
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-cr-api-token"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 402 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 412 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// ThingsThingIdFeaturesPutOpts Optional parameters for the method 'ThingsThingIdFeaturesPut'
type ThingsThingIdFeaturesPutOpts struct {
    IfMatch optional.String
    IfNoneMatch optional.String
    RequestedAcks optional.String
    Timeout optional.String
    ResponseRequired optional.Bool
}

/*
ThingsThingIdFeaturesPut Create or modify all features of a specific thing at once
Create or modify all features of a thing identified by the &#x60;thingId&#x60; path parameter. ### Create all features at once In case at the initial creation of your thing you have not specified any features, these can be created here.  ### Update all features at once To update all features at once prepare the JSON body accordingly.  Note: In contrast to the \&quot;PUT thing\&quot; request, a partial update is not supported here, but the content will be **overwritten**. If you need to update single features or their paths, please use the sub-resources instead.  Example:  &#x60;&#x60;&#x60; {      \&quot;coffee-brewer\&quot;: {        \&quot;definition\&quot;: [\&quot;com.acme:coffeebrewer:0.1.0\&quot;],        \&quot;properties\&quot;: {          \&quot;brewed-coffees\&quot;: 0        }      },      \&quot;water-tank\&quot;: {        \&quot;properties\&quot;: {          \&quot;configuration\&quot;: {            \&quot;smartMode\&quot;: true,            \&quot;brewingTemp\&quot;: 87,            \&quot;tempToHold\&quot;: 44,            \&quot;timeoutSeconds\&quot;: 6000          },          \&quot;status\&quot;: {            \&quot;waterAmount\&quot;: 731,            \&quot;temperature\&quot;: 44          }        }      } } &#x60;&#x60;&#x60;
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param thingId The ID of a thing needs to follow the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).  The namespace needs to be registered for your solution
 * @param requestBody JSON object of all features to be modified at once. Consider that the value has to be a JSON object or null.  Examples: * an empty object: {} - would just delete all old features * an empty feature: { \"featureId\": {} } - We strongly recommend to use a restricted set of characters   for the `featureId`, as it might be needed for the (URL) path later.    Currently these identifiers should follow the pattern: [_a-zA-Z][_a-zA-Z0-9-]*  * a nested object with multiple features as shown in the example value field
 * @param optional nil or *ThingsThingIdFeaturesPutOpts - Optional Parameters:
 * @param "IfMatch" (optional.String) -  The `If-Match` header which has to conform to RFC-7232 (Conditional Requests). Common usages are:   * optimistic locking by specifying the `ETag` from a previous HTTP response, e.g. `If-Match: \"hash:a75ece4e\"`   * retrieving or modifying a resource only if it already exists, e.g. `If-Match: *`
 * @param "IfNoneMatch" (optional.String) -  The `If-None-Match` header, which has to conform to RFC-7232 (Conditional Requests). A common usage scenario is to modify a resource only if it does not yet exist, thus to create it, by specifying `If-None-Match: *`.
 * @param "RequestedAcks" (optional.String) -  Contains the \"requested acknowledgements\" for this modifying request as comma separated list. The HTTP call will block until all requested acknowledgements were aggregated or will time out based on the specified `timeout` parameter.  The default (if omitted) requested acks is `requested-acks=twin-persisted` which will block the HTTP call until the change was persited to the twin.
 * @param "Timeout" (optional.String) -  Defines how long the backend should wait for completion of the request, e.g. applied when waiting for requested acknowledgements via the `requested-acks` param. Can be specified without unit (then seconds are assumed) or together with `s`, `ms` or `m` unit. Example: `42s`, `1m`.  The default (if omitted) timeout is `10s`. Maximum value: `60s`.  A value of `0` applies fire and forget semantics for the command resulting in setting `response-required=false`.
 * @param "ResponseRequired" (optional.Bool) -  Defines whether a response is required to the API call or not - if set to `false` the response will directly sent back with a status code of `202` (Accepted).  The default (if ommited) response is `true`.
@return map[string]Feature
*/
func (a *FeaturesApiService) ThingsThingIdFeaturesPut(ctx _context.Context, thingId string, requestBody map[string]Feature, localVarOptionals *ThingsThingIdFeaturesPutOpts) (map[string]Feature, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  map[string]Feature
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/things/{thingId}/features"
	localVarPath = strings.Replace(localVarPath, "{"+"thingId"+"}", _neturl.QueryEscape(parameterToString(thingId, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.RequestedAcks.IsSet() {
		localVarQueryParams.Add("requested-acks", parameterToString(localVarOptionals.RequestedAcks.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Timeout.IsSet() {
		localVarQueryParams.Add("timeout", parameterToString(localVarOptionals.Timeout.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ResponseRequired.IsSet() {
		localVarQueryParams.Add("response-required", parameterToString(localVarOptionals.ResponseRequired.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.IfMatch.IsSet() {
		localVarHeaderParams["If-Match"] = parameterToString(localVarOptionals.IfMatch.Value(), "")
	}
	if localVarOptionals != nil && localVarOptionals.IfNoneMatch.IsSet() {
		localVarHeaderParams["If-None-Match"] = parameterToString(localVarOptionals.IfNoneMatch.Value(), "")
	}
	// body params
	localVarPostBody = &requestBody
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-cr-api-token"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 402 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 412 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 413 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
