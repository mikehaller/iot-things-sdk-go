/*
 * Bosch IoT Things HTTP API
 *
 * Bosch IoT Things enables applications to manage digital twins of IoT device assets in a simple, convenient, robust, and secure way.  These descriptions focus on the JSON-based, REST-like **HTTP API 2** of the Bosch IoT Things service.  Find details in our [documentation](https://docs.bosch-iot-suite.com/things/).  The Bosch IoT Things HTTP API uses response status codes     (see [RFC 7231](https://tools.ietf.org/html/rfc7231#section-6))     to indicate whether a specific request has been successfully completed, or not. However, the descriptions we provide additionally to the status code (e.g. in our API docs, or error codes like. \"solutions:transaction.count.exceeded\") might change without advance notice. These are not be considered as official API, and must therefore not be applied in your applications or tests.
 *
 * API version: 2
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package iotthings

import (
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
	"github.com/antihax/optional"
)

// Linger please
var (
	_ _context.Context
)

// PoliciesApiService PoliciesApi service
type PoliciesApiService service

// PoliciesPolicyIdDeleteOpts Optional parameters for the method 'PoliciesPolicyIdDelete'
type PoliciesPolicyIdDeleteOpts struct {
    IfMatch optional.String
    IfNoneMatch optional.String
    Timeout optional.String
    ResponseRequired optional.Bool
}

/*
PoliciesPolicyIdDelete Delete a specific policy
Deletes the policy identified by the &#x60;policyId&#x60; path parameter. Deleting a policy does not implicitly delete other entities (e.g. things) which use this policy.  Note: Delete the respective things **before** deleting the policy, otherwise nobody has permission to read, update, or delete the things. If you accidentally run into such a scenario, re-create the policy via PUT &#x60;/policies/{policyId}&#x60;.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param policyId The ID of the policy needs to follow the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).  The namespace needs to: * conform to the reverse domain name notation * be registered for your solution
 * @param optional nil or *PoliciesPolicyIdDeleteOpts - Optional Parameters:
 * @param "IfMatch" (optional.String) -  The `If-Match` header, which has to conform to RFC-7232 (Conditional Requests). Common usages are:   * optimistic locking by specifying the `ETag` from a previous GET response, e.g. `If-Match: \"rev:4711\"`   * retrieving or modifying a resource only if it already exists, e.g. `If-Match: *`
 * @param "IfNoneMatch" (optional.String) -  The `If-None-Match` header, which has to conform to RFC-7232 (Conditional Requests). A common usage scenario is to modify a resource only if it does not yet exist, thus to create it, by specifying `If-None-Match: *`.
 * @param "Timeout" (optional.String) -  Defines how long the backend should wait for completion of the request, e.g. applied when waiting for requested acknowledgements via the `requested-acks` param. Can be specified without unit (then seconds are assumed) or together with `s`, `ms` or `m` unit. Example: `42s`, `1m`.  The default (if omitted) timeout is `10s`. Maximum value: `60s`.  A value of `0` applies fire and forget semantics for the command resulting in setting `response-required=false`.
 * @param "ResponseRequired" (optional.Bool) -  Defines whether a response is required to the API call or not - if set to `false` the response will directly sent back with a status code of `202` (Accepted).  The default (if ommited) response is `true`.
*/
func (a *PoliciesApiService) PoliciesPolicyIdDelete(ctx _context.Context, policyId string, localVarOptionals *PoliciesPolicyIdDeleteOpts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/policies/{policyId}"
	localVarPath = strings.Replace(localVarPath, "{"+"policyId"+"}", _neturl.QueryEscape(parameterToString(policyId, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Timeout.IsSet() {
		localVarQueryParams.Add("timeout", parameterToString(localVarOptionals.Timeout.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ResponseRequired.IsSet() {
		localVarQueryParams.Add("response-required", parameterToString(localVarOptionals.ResponseRequired.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.IfMatch.IsSet() {
		localVarHeaderParams["If-Match"] = parameterToString(localVarOptionals.IfMatch.Value(), "")
	}
	if localVarOptionals != nil && localVarOptionals.IfNoneMatch.IsSet() {
		localVarHeaderParams["If-None-Match"] = parameterToString(localVarOptionals.IfNoneMatch.Value(), "")
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-cr-api-token"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 402 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 412 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// PoliciesPolicyIdEntriesGetOpts Optional parameters for the method 'PoliciesPolicyIdEntriesGet'
type PoliciesPolicyIdEntriesGetOpts struct {
    IfMatch optional.String
    IfNoneMatch optional.String
    Timeout optional.String
}

/*
PoliciesPolicyIdEntriesGet Retrieve the entries of a specific policy
Returns all policy entries of the policy identified by the &#x60;policyId&#x60; path parameter.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param policyId The ID of the policy needs to follow the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).  The namespace needs to: * conform to the reverse domain name notation * be registered for your solution
 * @param optional nil or *PoliciesPolicyIdEntriesGetOpts - Optional Parameters:
 * @param "IfMatch" (optional.String) -  The `If-Match` header which has to conform to RFC-7232 (Conditional Requests). Common usages are:   * optimistic locking by specifying the `ETag` from a previous HTTP response, e.g. `If-Match: \"hash:a75ece4e\"`   * retrieving or modifying a resource only if it already exists, e.g. `If-Match: *`
 * @param "IfNoneMatch" (optional.String) -  The `If-None-Match` header, which has to conform to RFC-7232 (Conditional Requests). A common usage scenario is to modify a resource only if it does not yet exist, thus to create it, by specifying `If-None-Match: *`.
 * @param "Timeout" (optional.String) -  Defines how long the backend should wait for completion of the request, e.g. applied when waiting for requested acknowledgements via the `requested-acks` param. Can be specified without unit (then seconds are assumed) or together with `s`, `ms` or `m` unit. Example: `42s`, `1m`.  The default (if omitted) timeout is `10s`. Maximum value: `60s`.  A value of `0` applies fire and forget semantics for the command resulting in setting `response-required=false`.
@return PolicyEntries
*/
func (a *PoliciesApiService) PoliciesPolicyIdEntriesGet(ctx _context.Context, policyId string, localVarOptionals *PoliciesPolicyIdEntriesGetOpts) (PolicyEntries, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PolicyEntries
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/policies/{policyId}/entries"
	localVarPath = strings.Replace(localVarPath, "{"+"policyId"+"}", _neturl.QueryEscape(parameterToString(policyId, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Timeout.IsSet() {
		localVarQueryParams.Add("timeout", parameterToString(localVarOptionals.Timeout.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.IfMatch.IsSet() {
		localVarHeaderParams["If-Match"] = parameterToString(localVarOptionals.IfMatch.Value(), "")
	}
	if localVarOptionals != nil && localVarOptionals.IfNoneMatch.IsSet() {
		localVarHeaderParams["If-None-Match"] = parameterToString(localVarOptionals.IfNoneMatch.Value(), "")
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-cr-api-token"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 402 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 412 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// PoliciesPolicyIdEntriesLabelDeleteOpts Optional parameters for the method 'PoliciesPolicyIdEntriesLabelDelete'
type PoliciesPolicyIdEntriesLabelDeleteOpts struct {
    IfMatch optional.String
    IfNoneMatch optional.String
    Timeout optional.String
    ResponseRequired optional.Bool
}

/*
PoliciesPolicyIdEntriesLabelDelete Delete the entries of a specific Label of a specific policy
Deletes the entry of the policy identified by the &#x60;policyId&#x60; path parameter and with the label identified by the &#x60;label&#x60; path parameter.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param policyId The ID of the policy needs to follow the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).  The namespace needs to: * conform to the reverse domain name notation * be registered for your solution
 * @param label The label of a policy entry
 * @param optional nil or *PoliciesPolicyIdEntriesLabelDeleteOpts - Optional Parameters:
 * @param "IfMatch" (optional.String) -  The `If-Match` header which has to conform to RFC-7232 (Conditional Requests). Common usages are:   * optimistic locking by specifying the `ETag` from a previous HTTP response, e.g. `If-Match: \"hash:a75ece4e\"`   * retrieving or modifying a resource only if it already exists, e.g. `If-Match: *`
 * @param "IfNoneMatch" (optional.String) -  The `If-None-Match` header, which has to conform to RFC-7232 (Conditional Requests). A common usage scenario is to modify a resource only if it does not yet exist, thus to create it, by specifying `If-None-Match: *`.
 * @param "Timeout" (optional.String) -  Defines how long the backend should wait for completion of the request, e.g. applied when waiting for requested acknowledgements via the `requested-acks` param. Can be specified without unit (then seconds are assumed) or together with `s`, `ms` or `m` unit. Example: `42s`, `1m`.  The default (if omitted) timeout is `10s`. Maximum value: `60s`.  A value of `0` applies fire and forget semantics for the command resulting in setting `response-required=false`.
 * @param "ResponseRequired" (optional.Bool) -  Defines whether a response is required to the API call or not - if set to `false` the response will directly sent back with a status code of `202` (Accepted).  The default (if ommited) response is `true`.
*/
func (a *PoliciesApiService) PoliciesPolicyIdEntriesLabelDelete(ctx _context.Context, policyId string, label string, localVarOptionals *PoliciesPolicyIdEntriesLabelDeleteOpts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/policies/{policyId}/entries/{label}"
	localVarPath = strings.Replace(localVarPath, "{"+"policyId"+"}", _neturl.QueryEscape(parameterToString(policyId, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"label"+"}", _neturl.QueryEscape(parameterToString(label, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Timeout.IsSet() {
		localVarQueryParams.Add("timeout", parameterToString(localVarOptionals.Timeout.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ResponseRequired.IsSet() {
		localVarQueryParams.Add("response-required", parameterToString(localVarOptionals.ResponseRequired.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.IfMatch.IsSet() {
		localVarHeaderParams["If-Match"] = parameterToString(localVarOptionals.IfMatch.Value(), "")
	}
	if localVarOptionals != nil && localVarOptionals.IfNoneMatch.IsSet() {
		localVarHeaderParams["If-None-Match"] = parameterToString(localVarOptionals.IfNoneMatch.Value(), "")
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-cr-api-token"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 402 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 412 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// PoliciesPolicyIdEntriesLabelGetOpts Optional parameters for the method 'PoliciesPolicyIdEntriesLabelGet'
type PoliciesPolicyIdEntriesLabelGetOpts struct {
    IfMatch optional.String
    IfNoneMatch optional.String
    Timeout optional.String
}

/*
PoliciesPolicyIdEntriesLabelGet Retrieve the entries of a specific Label of a specific policy
Returns all entries (subjects, resources, etc.) of the policy identified by the &#x60;policyId&#x60; path parameter, and by the &#x60;label&#x60; path parameter. Example label: DEFAULT.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param policyId The ID of the policy needs to follow the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).  The namespace needs to: * conform to the reverse domain name notation * be registered for your solution
 * @param label The label of a policy entry
 * @param optional nil or *PoliciesPolicyIdEntriesLabelGetOpts - Optional Parameters:
 * @param "IfMatch" (optional.String) -  The `If-Match` header which has to conform to RFC-7232 (Conditional Requests). Common usages are:   * optimistic locking by specifying the `ETag` from a previous HTTP response, e.g. `If-Match: \"hash:a75ece4e\"`   * retrieving or modifying a resource only if it already exists, e.g. `If-Match: *`
 * @param "IfNoneMatch" (optional.String) -  The `If-None-Match` header, which has to conform to RFC-7232 (Conditional Requests). A common usage scenario is to modify a resource only if it does not yet exist, thus to create it, by specifying `If-None-Match: *`.
 * @param "Timeout" (optional.String) -  Defines how long the backend should wait for completion of the request, e.g. applied when waiting for requested acknowledgements via the `requested-acks` param. Can be specified without unit (then seconds are assumed) or together with `s`, `ms` or `m` unit. Example: `42s`, `1m`.  The default (if omitted) timeout is `10s`. Maximum value: `60s`.  A value of `0` applies fire and forget semantics for the command resulting in setting `response-required=false`.
@return PolicyEntry
*/
func (a *PoliciesApiService) PoliciesPolicyIdEntriesLabelGet(ctx _context.Context, policyId string, label string, localVarOptionals *PoliciesPolicyIdEntriesLabelGetOpts) (PolicyEntry, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PolicyEntry
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/policies/{policyId}/entries/{label}"
	localVarPath = strings.Replace(localVarPath, "{"+"policyId"+"}", _neturl.QueryEscape(parameterToString(policyId, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"label"+"}", _neturl.QueryEscape(parameterToString(label, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Timeout.IsSet() {
		localVarQueryParams.Add("timeout", parameterToString(localVarOptionals.Timeout.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.IfMatch.IsSet() {
		localVarHeaderParams["If-Match"] = parameterToString(localVarOptionals.IfMatch.Value(), "")
	}
	if localVarOptionals != nil && localVarOptionals.IfNoneMatch.IsSet() {
		localVarHeaderParams["If-None-Match"] = parameterToString(localVarOptionals.IfNoneMatch.Value(), "")
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-cr-api-token"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 402 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 412 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// PoliciesPolicyIdEntriesLabelPutOpts Optional parameters for the method 'PoliciesPolicyIdEntriesLabelPut'
type PoliciesPolicyIdEntriesLabelPutOpts struct {
    IfMatch optional.String
    IfNoneMatch optional.String
    Timeout optional.String
    ResponseRequired optional.Bool
}

/*
PoliciesPolicyIdEntriesLabelPut Create or modify the entries of a specific Label of a specific policy
Create or modify the policy entry identified by the &#x60;policyId&#x60; path parameter and with the label identified by the &#x60;label&#x60; path parameter. * If you specify a new label, the respective policy entry will be created * If you specify an existig label, the respective policy entry will be updated
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param policyId The ID of the policy needs to follow the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).  The namespace needs to: * conform to the reverse domain name notation * be registered for your solution
 * @param label The label of a policy entry
 * @param policyEntry JSON representation of the policy entry. Use the placeholder `{{ request:subjectId }}` in order to let the backend insert the authenticated subjectId of the HTTP request.  ### Example Given your policy \"com.acme.coffeemaker:policy-01\" only has the DEFAULT entry, and you want to add a \"Consumer\" section which additionally allows USER-01 (managed within a Bosch IoT Permissions service instance) to *read* the thing and to trigger a \"makeCoffee\" operation (i.e. POST such a message - see POST /things/{thingId}/inbox/messages/{messageSubject}).  Set the label value to **Consumer** and the following request body: ``` {    \"subjects\": {      \"iot-permissions:USER-01\": {        \"type\": \"iot-permissions-userid\"      },    },    \"resources\": {      \"thing:/\": {        \"grant\": [          \"READ\"        ],        \"revoke\": []      },      \"message:/\": {        \"grant\": [          \"WRITE\"        ],        \"revoke\": []      }    }  } ```
 * @param optional nil or *PoliciesPolicyIdEntriesLabelPutOpts - Optional Parameters:
 * @param "IfMatch" (optional.String) -  The `If-Match` header which has to conform to RFC-7232 (Conditional Requests). Common usages are:   * optimistic locking by specifying the `ETag` from a previous HTTP response, e.g. `If-Match: \"hash:a75ece4e\"`   * retrieving or modifying a resource only if it already exists, e.g. `If-Match: *`
 * @param "IfNoneMatch" (optional.String) -  The `If-None-Match` header, which has to conform to RFC-7232 (Conditional Requests). A common usage scenario is to modify a resource only if it does not yet exist, thus to create it, by specifying `If-None-Match: *`.
 * @param "Timeout" (optional.String) -  Defines how long the backend should wait for completion of the request, e.g. applied when waiting for requested acknowledgements via the `requested-acks` param. Can be specified without unit (then seconds are assumed) or together with `s`, `ms` or `m` unit. Example: `42s`, `1m`.  The default (if omitted) timeout is `10s`. Maximum value: `60s`.  A value of `0` applies fire and forget semantics for the command resulting in setting `response-required=false`.
 * @param "ResponseRequired" (optional.Bool) -  Defines whether a response is required to the API call or not - if set to `false` the response will directly sent back with a status code of `202` (Accepted).  The default (if ommited) response is `true`.
@return PolicyEntry
*/
func (a *PoliciesApiService) PoliciesPolicyIdEntriesLabelPut(ctx _context.Context, policyId string, label string, policyEntry PolicyEntry, localVarOptionals *PoliciesPolicyIdEntriesLabelPutOpts) (PolicyEntry, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PolicyEntry
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/policies/{policyId}/entries/{label}"
	localVarPath = strings.Replace(localVarPath, "{"+"policyId"+"}", _neturl.QueryEscape(parameterToString(policyId, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"label"+"}", _neturl.QueryEscape(parameterToString(label, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Timeout.IsSet() {
		localVarQueryParams.Add("timeout", parameterToString(localVarOptionals.Timeout.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ResponseRequired.IsSet() {
		localVarQueryParams.Add("response-required", parameterToString(localVarOptionals.ResponseRequired.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.IfMatch.IsSet() {
		localVarHeaderParams["If-Match"] = parameterToString(localVarOptionals.IfMatch.Value(), "")
	}
	if localVarOptionals != nil && localVarOptionals.IfNoneMatch.IsSet() {
		localVarHeaderParams["If-None-Match"] = parameterToString(localVarOptionals.IfNoneMatch.Value(), "")
	}
	// body params
	localVarPostBody = &policyEntry
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-cr-api-token"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 402 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 412 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 413 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// PoliciesPolicyIdEntriesLabelResourcesGetOpts Optional parameters for the method 'PoliciesPolicyIdEntriesLabelResourcesGet'
type PoliciesPolicyIdEntriesLabelResourcesGetOpts struct {
    IfMatch optional.String
    IfNoneMatch optional.String
    Timeout optional.String
}

/*
PoliciesPolicyIdEntriesLabelResourcesGet Retrieve all Resources for a specific Label of a specific policy
Returns all resource entries of the policy identified by the &#x60;policyId&#x60; path parameter, and by the &#x60;label&#x60; path parameter.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param policyId The ID of the policy needs to follow the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).  The namespace needs to: * conform to the reverse domain name notation * be registered for your solution
 * @param label The label of a policy entry
 * @param optional nil or *PoliciesPolicyIdEntriesLabelResourcesGetOpts - Optional Parameters:
 * @param "IfMatch" (optional.String) -  The `If-Match` header which has to conform to RFC-7232 (Conditional Requests). Common usages are:   * optimistic locking by specifying the `ETag` from a previous HTTP response, e.g. `If-Match: \"hash:a75ece4e\"`   * retrieving or modifying a resource only if it already exists, e.g. `If-Match: *`
 * @param "IfNoneMatch" (optional.String) -  The `If-None-Match` header, which has to conform to RFC-7232 (Conditional Requests). A common usage scenario is to modify a resource only if it does not yet exist, thus to create it, by specifying `If-None-Match: *`.
 * @param "Timeout" (optional.String) -  Defines how long the backend should wait for completion of the request, e.g. applied when waiting for requested acknowledgements via the `requested-acks` param. Can be specified without unit (then seconds are assumed) or together with `s`, `ms` or `m` unit. Example: `42s`, `1m`.  The default (if omitted) timeout is `10s`. Maximum value: `60s`.  A value of `0` applies fire and forget semantics for the command resulting in setting `response-required=false`.
@return Resources
*/
func (a *PoliciesApiService) PoliciesPolicyIdEntriesLabelResourcesGet(ctx _context.Context, policyId string, label string, localVarOptionals *PoliciesPolicyIdEntriesLabelResourcesGetOpts) (Resources, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Resources
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/policies/{policyId}/entries/{label}/resources"
	localVarPath = strings.Replace(localVarPath, "{"+"policyId"+"}", _neturl.QueryEscape(parameterToString(policyId, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"label"+"}", _neturl.QueryEscape(parameterToString(label, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Timeout.IsSet() {
		localVarQueryParams.Add("timeout", parameterToString(localVarOptionals.Timeout.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.IfMatch.IsSet() {
		localVarHeaderParams["If-Match"] = parameterToString(localVarOptionals.IfMatch.Value(), "")
	}
	if localVarOptionals != nil && localVarOptionals.IfNoneMatch.IsSet() {
		localVarHeaderParams["If-None-Match"] = parameterToString(localVarOptionals.IfNoneMatch.Value(), "")
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-cr-api-token"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 402 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 412 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// PoliciesPolicyIdEntriesLabelResourcesPutOpts Optional parameters for the method 'PoliciesPolicyIdEntriesLabelResourcesPut'
type PoliciesPolicyIdEntriesLabelResourcesPutOpts struct {
    IfMatch optional.String
    IfNoneMatch optional.String
    Timeout optional.String
    ResponseRequired optional.Bool
}

/*
PoliciesPolicyIdEntriesLabelResourcesPut Create or modify all Resources for a specific Label of a specific policy
Create or modify all resources of the policy identified by the &#x60;policyId&#x60; path parameter, and by the &#x60;label&#x60; path parameter.  ### Delete all resource entries  Set the empty body part, if you need to delete all resource entries: { }  ### Set max permissions on all ressources &#x60;&#x60;&#x60; {           \&quot;policy:/\&quot;: {                   \&quot;grant\&quot;: [                     \&quot;READ\&quot;,                     \&quot;WRITE\&quot;                   ],                   \&quot;revoke\&quot;: []                 },          \&quot;thing:/\&quot;: {                   \&quot;grant\&quot;: [                     \&quot;READ\&quot;,                     \&quot;WRITE\&quot;                   ],                   \&quot;revoke\&quot;: []                 },          \&quot;message:/\&quot;: {                   \&quot;grant\&quot;: [                     \&quot;READ\&quot;,                     \&quot;WRITE\&quot;                   ],                   \&quot;revoke\&quot;: []                 }               }   }   &#x60;&#x60;&#x60;   ### Allow to read all parts of a thing except the \&quot;confidential\&quot; feature   &#x60;&#x60;&#x60;   {           \&quot;thing:/\&quot;: {                     \&quot;grant\&quot;: [ \&quot;READ\&quot; ],                     \&quot;revoke\&quot;: []           },           \&quot;things:/{thingId}/features/confidential:/\&quot;: {                     \&quot;grant\&quot;: [],                     \&quot;revoke\&quot;: [ \&quot;READ\&quot;]           },   }   &#x60;&#x60;&#x60;
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param policyId The ID of the policy needs to follow the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).  The namespace needs to: * conform to the reverse domain name notation * be registered for your solution
 * @param label The label of a policy entry
 * @param resources JSON representation of the Resources
 * @param optional nil or *PoliciesPolicyIdEntriesLabelResourcesPutOpts - Optional Parameters:
 * @param "IfMatch" (optional.String) -  The `If-Match` header which has to conform to RFC-7232 (Conditional Requests). Common usages are:   * optimistic locking by specifying the `ETag` from a previous HTTP response, e.g. `If-Match: \"hash:a75ece4e\"`   * retrieving or modifying a resource only if it already exists, e.g. `If-Match: *`
 * @param "IfNoneMatch" (optional.String) -  The `If-None-Match` header, which has to conform to RFC-7232 (Conditional Requests). A common usage scenario is to modify a resource only if it does not yet exist, thus to create it, by specifying `If-None-Match: *`.
 * @param "Timeout" (optional.String) -  Defines how long the backend should wait for completion of the request, e.g. applied when waiting for requested acknowledgements via the `requested-acks` param. Can be specified without unit (then seconds are assumed) or together with `s`, `ms` or `m` unit. Example: `42s`, `1m`.  The default (if omitted) timeout is `10s`. Maximum value: `60s`.  A value of `0` applies fire and forget semantics for the command resulting in setting `response-required=false`.
 * @param "ResponseRequired" (optional.Bool) -  Defines whether a response is required to the API call or not - if set to `false` the response will directly sent back with a status code of `202` (Accepted).  The default (if ommited) response is `true`.
*/
func (a *PoliciesApiService) PoliciesPolicyIdEntriesLabelResourcesPut(ctx _context.Context, policyId string, label string, resources Resources, localVarOptionals *PoliciesPolicyIdEntriesLabelResourcesPutOpts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/policies/{policyId}/entries/{label}/resources"
	localVarPath = strings.Replace(localVarPath, "{"+"policyId"+"}", _neturl.QueryEscape(parameterToString(policyId, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"label"+"}", _neturl.QueryEscape(parameterToString(label, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Timeout.IsSet() {
		localVarQueryParams.Add("timeout", parameterToString(localVarOptionals.Timeout.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ResponseRequired.IsSet() {
		localVarQueryParams.Add("response-required", parameterToString(localVarOptionals.ResponseRequired.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.IfMatch.IsSet() {
		localVarHeaderParams["If-Match"] = parameterToString(localVarOptionals.IfMatch.Value(), "")
	}
	if localVarOptionals != nil && localVarOptionals.IfNoneMatch.IsSet() {
		localVarHeaderParams["If-None-Match"] = parameterToString(localVarOptionals.IfNoneMatch.Value(), "")
	}
	// body params
	localVarPostBody = &resources
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-cr-api-token"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 402 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 412 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 413 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// PoliciesPolicyIdEntriesLabelResourcesResourcePathDeleteOpts Optional parameters for the method 'PoliciesPolicyIdEntriesLabelResourcesResourcePathDelete'
type PoliciesPolicyIdEntriesLabelResourcesResourcePathDeleteOpts struct {
    IfMatch optional.String
    IfNoneMatch optional.String
    Timeout optional.String
    ResponseRequired optional.Bool
}

/*
PoliciesPolicyIdEntriesLabelResourcesResourcePathDelete Delete one specific Resource for a specific Label of a specific policy
Deletes the resource with path &#x60;resourcePath&#x60; from the policy identified by the the &#x60;policyId&#x60; path parameter, and by the &#x60;label&#x60; path parameter.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param policyId The ID of the policy needs to follow the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).  The namespace needs to: * conform to the reverse domain name notation * be registered for your solution
 * @param label The label of a policy entry
 * @param resourcePath The path of an (Authorization) Resource
 * @param optional nil or *PoliciesPolicyIdEntriesLabelResourcesResourcePathDeleteOpts - Optional Parameters:
 * @param "IfMatch" (optional.String) -  The `If-Match` header which has to conform to RFC-7232 (Conditional Requests). Common usages are:   * optimistic locking by specifying the `ETag` from a previous HTTP response, e.g. `If-Match: \"hash:a75ece4e\"`   * retrieving or modifying a resource only if it already exists, e.g. `If-Match: *`
 * @param "IfNoneMatch" (optional.String) -  The `If-None-Match` header, which has to conform to RFC-7232 (Conditional Requests). A common usage scenario is to modify a resource only if it does not yet exist, thus to create it, by specifying `If-None-Match: *`.
 * @param "Timeout" (optional.String) -  Defines how long the backend should wait for completion of the request, e.g. applied when waiting for requested acknowledgements via the `requested-acks` param. Can be specified without unit (then seconds are assumed) or together with `s`, `ms` or `m` unit. Example: `42s`, `1m`.  The default (if omitted) timeout is `10s`. Maximum value: `60s`.  A value of `0` applies fire and forget semantics for the command resulting in setting `response-required=false`.
 * @param "ResponseRequired" (optional.Bool) -  Defines whether a response is required to the API call or not - if set to `false` the response will directly sent back with a status code of `202` (Accepted).  The default (if ommited) response is `true`.
*/
func (a *PoliciesApiService) PoliciesPolicyIdEntriesLabelResourcesResourcePathDelete(ctx _context.Context, policyId string, label string, resourcePath string, localVarOptionals *PoliciesPolicyIdEntriesLabelResourcesResourcePathDeleteOpts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/policies/{policyId}/entries/{label}/resources/{resourcePath}"
	localVarPath = strings.Replace(localVarPath, "{"+"policyId"+"}", _neturl.QueryEscape(parameterToString(policyId, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"label"+"}", _neturl.QueryEscape(parameterToString(label, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"resourcePath"+"}", _neturl.QueryEscape(parameterToString(resourcePath, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Timeout.IsSet() {
		localVarQueryParams.Add("timeout", parameterToString(localVarOptionals.Timeout.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ResponseRequired.IsSet() {
		localVarQueryParams.Add("response-required", parameterToString(localVarOptionals.ResponseRequired.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.IfMatch.IsSet() {
		localVarHeaderParams["If-Match"] = parameterToString(localVarOptionals.IfMatch.Value(), "")
	}
	if localVarOptionals != nil && localVarOptionals.IfNoneMatch.IsSet() {
		localVarHeaderParams["If-None-Match"] = parameterToString(localVarOptionals.IfNoneMatch.Value(), "")
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-cr-api-token"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 402 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 412 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// PoliciesPolicyIdEntriesLabelResourcesResourcePathGetOpts Optional parameters for the method 'PoliciesPolicyIdEntriesLabelResourcesResourcePathGet'
type PoliciesPolicyIdEntriesLabelResourcesResourcePathGetOpts struct {
    IfMatch optional.String
    IfNoneMatch optional.String
    Timeout optional.String
}

/*
PoliciesPolicyIdEntriesLabelResourcesResourcePathGet Retrieve one specific Resource for a specific Label of a specific policy
Returns the resource with path &#x60;resourcePath&#x60; of the policy identified by the &#x60;policyId&#x60; path parameter, and by the &#x60;label&#x60; path parameter.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param policyId The ID of the policy needs to follow the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).  The namespace needs to: * conform to the reverse domain name notation * be registered for your solution
 * @param label The label of a policy entry
 * @param resourcePath The path of an (Authorization) Resource
 * @param optional nil or *PoliciesPolicyIdEntriesLabelResourcesResourcePathGetOpts - Optional Parameters:
 * @param "IfMatch" (optional.String) -  The `If-Match` header which has to conform to RFC-7232 (Conditional Requests). Common usages are:   * optimistic locking by specifying the `ETag` from a previous HTTP response, e.g. `If-Match: \"hash:a75ece4e\"`   * retrieving or modifying a resource only if it already exists, e.g. `If-Match: *`
 * @param "IfNoneMatch" (optional.String) -  The `If-None-Match` header, which has to conform to RFC-7232 (Conditional Requests). A common usage scenario is to modify a resource only if it does not yet exist, thus to create it, by specifying `If-None-Match: *`.
 * @param "Timeout" (optional.String) -  Defines how long the backend should wait for completion of the request, e.g. applied when waiting for requested acknowledgements via the `requested-acks` param. Can be specified without unit (then seconds are assumed) or together with `s`, `ms` or `m` unit. Example: `42s`, `1m`.  The default (if omitted) timeout is `10s`. Maximum value: `60s`.  A value of `0` applies fire and forget semantics for the command resulting in setting `response-required=false`.
@return ResourceEntry
*/
func (a *PoliciesApiService) PoliciesPolicyIdEntriesLabelResourcesResourcePathGet(ctx _context.Context, policyId string, label string, resourcePath string, localVarOptionals *PoliciesPolicyIdEntriesLabelResourcesResourcePathGetOpts) (ResourceEntry, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ResourceEntry
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/policies/{policyId}/entries/{label}/resources/{resourcePath}"
	localVarPath = strings.Replace(localVarPath, "{"+"policyId"+"}", _neturl.QueryEscape(parameterToString(policyId, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"label"+"}", _neturl.QueryEscape(parameterToString(label, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"resourcePath"+"}", _neturl.QueryEscape(parameterToString(resourcePath, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Timeout.IsSet() {
		localVarQueryParams.Add("timeout", parameterToString(localVarOptionals.Timeout.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.IfMatch.IsSet() {
		localVarHeaderParams["If-Match"] = parameterToString(localVarOptionals.IfMatch.Value(), "")
	}
	if localVarOptionals != nil && localVarOptionals.IfNoneMatch.IsSet() {
		localVarHeaderParams["If-None-Match"] = parameterToString(localVarOptionals.IfNoneMatch.Value(), "")
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-cr-api-token"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 402 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 412 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// PoliciesPolicyIdEntriesLabelResourcesResourcePathPutOpts Optional parameters for the method 'PoliciesPolicyIdEntriesLabelResourcesResourcePathPut'
type PoliciesPolicyIdEntriesLabelResourcesResourcePathPutOpts struct {
    IfMatch optional.String
    IfNoneMatch optional.String
    Timeout optional.String
    ResponseRequired optional.Bool
}

/*
PoliciesPolicyIdEntriesLabelResourcesResourcePathPut Create or modify one specific Resource for a specific Label of a specific policy
Create or modify the Resource with path &#x60;resourcePath&#x60; of the policy entry identified by the &#x60;label&#x60; path parameter belonging to the policy identified by the &#x60;policyId&#x60; path parameter.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param policyId The ID of the policy needs to follow the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).  The namespace needs to: * conform to the reverse domain name notation * be registered for your solution
 * @param label The label of a policy entry
 * @param resourcePath The path of an (Authorization) Resource
 * @param resourceEntry JSON representation of the Resource
 * @param optional nil or *PoliciesPolicyIdEntriesLabelResourcesResourcePathPutOpts - Optional Parameters:
 * @param "IfMatch" (optional.String) -  The `If-Match` header which has to conform to RFC-7232 (Conditional Requests). Common usages are:   * optimistic locking by specifying the `ETag` from a previous HTTP response, e.g. `If-Match: \"hash:a75ece4e\"`   * retrieving or modifying a resource only if it already exists, e.g. `If-Match: *`
 * @param "IfNoneMatch" (optional.String) -  The `If-None-Match` header, which has to conform to RFC-7232 (Conditional Requests). A common usage scenario is to modify a resource only if it does not yet exist, thus to create it, by specifying `If-None-Match: *`.
 * @param "Timeout" (optional.String) -  Defines how long the backend should wait for completion of the request, e.g. applied when waiting for requested acknowledgements via the `requested-acks` param. Can be specified without unit (then seconds are assumed) or together with `s`, `ms` or `m` unit. Example: `42s`, `1m`.  The default (if omitted) timeout is `10s`. Maximum value: `60s`.  A value of `0` applies fire and forget semantics for the command resulting in setting `response-required=false`.
 * @param "ResponseRequired" (optional.Bool) -  Defines whether a response is required to the API call or not - if set to `false` the response will directly sent back with a status code of `202` (Accepted).  The default (if ommited) response is `true`.
@return ResourceEntry
*/
func (a *PoliciesApiService) PoliciesPolicyIdEntriesLabelResourcesResourcePathPut(ctx _context.Context, policyId string, label string, resourcePath string, resourceEntry ResourceEntry, localVarOptionals *PoliciesPolicyIdEntriesLabelResourcesResourcePathPutOpts) (ResourceEntry, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ResourceEntry
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/policies/{policyId}/entries/{label}/resources/{resourcePath}"
	localVarPath = strings.Replace(localVarPath, "{"+"policyId"+"}", _neturl.QueryEscape(parameterToString(policyId, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"label"+"}", _neturl.QueryEscape(parameterToString(label, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"resourcePath"+"}", _neturl.QueryEscape(parameterToString(resourcePath, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Timeout.IsSet() {
		localVarQueryParams.Add("timeout", parameterToString(localVarOptionals.Timeout.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ResponseRequired.IsSet() {
		localVarQueryParams.Add("response-required", parameterToString(localVarOptionals.ResponseRequired.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.IfMatch.IsSet() {
		localVarHeaderParams["If-Match"] = parameterToString(localVarOptionals.IfMatch.Value(), "")
	}
	if localVarOptionals != nil && localVarOptionals.IfNoneMatch.IsSet() {
		localVarHeaderParams["If-None-Match"] = parameterToString(localVarOptionals.IfNoneMatch.Value(), "")
	}
	// body params
	localVarPostBody = &resourceEntry
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-cr-api-token"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 402 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 412 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 413 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// PoliciesPolicyIdEntriesLabelSubjectsGetOpts Optional parameters for the method 'PoliciesPolicyIdEntriesLabelSubjectsGet'
type PoliciesPolicyIdEntriesLabelSubjectsGetOpts struct {
    IfMatch optional.String
    IfNoneMatch optional.String
    Timeout optional.String
}

/*
PoliciesPolicyIdEntriesLabelSubjectsGet Retrieve all Subjects for a specific Label of a specific policy
Returns all subject entries of the policy identified by the &#x60;policyId&#x60; path parameter, and by the &#x60;label&#x60; path parameter.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param policyId The ID of the policy needs to follow the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).  The namespace needs to: * conform to the reverse domain name notation * be registered for your solution
 * @param label The label of a policy entry
 * @param optional nil or *PoliciesPolicyIdEntriesLabelSubjectsGetOpts - Optional Parameters:
 * @param "IfMatch" (optional.String) -  The `If-Match` header which has to conform to RFC-7232 (Conditional Requests). Common usages are:   * optimistic locking by specifying the `ETag` from a previous HTTP response, e.g. `If-Match: \"hash:a75ece4e\"`   * retrieving or modifying a resource only if it already exists, e.g. `If-Match: *`
 * @param "IfNoneMatch" (optional.String) -  The `If-None-Match` header, which has to conform to RFC-7232 (Conditional Requests). A common usage scenario is to modify a resource only if it does not yet exist, thus to create it, by specifying `If-None-Match: *`.
 * @param "Timeout" (optional.String) -  Defines how long the backend should wait for completion of the request, e.g. applied when waiting for requested acknowledgements via the `requested-acks` param. Can be specified without unit (then seconds are assumed) or together with `s`, `ms` or `m` unit. Example: `42s`, `1m`.  The default (if omitted) timeout is `10s`. Maximum value: `60s`.  A value of `0` applies fire and forget semantics for the command resulting in setting `response-required=false`.
@return Subjects
*/
func (a *PoliciesApiService) PoliciesPolicyIdEntriesLabelSubjectsGet(ctx _context.Context, policyId string, label string, localVarOptionals *PoliciesPolicyIdEntriesLabelSubjectsGetOpts) (Subjects, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Subjects
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/policies/{policyId}/entries/{label}/subjects"
	localVarPath = strings.Replace(localVarPath, "{"+"policyId"+"}", _neturl.QueryEscape(parameterToString(policyId, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"label"+"}", _neturl.QueryEscape(parameterToString(label, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Timeout.IsSet() {
		localVarQueryParams.Add("timeout", parameterToString(localVarOptionals.Timeout.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.IfMatch.IsSet() {
		localVarHeaderParams["If-Match"] = parameterToString(localVarOptionals.IfMatch.Value(), "")
	}
	if localVarOptionals != nil && localVarOptionals.IfNoneMatch.IsSet() {
		localVarHeaderParams["If-None-Match"] = parameterToString(localVarOptionals.IfNoneMatch.Value(), "")
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-cr-api-token"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 402 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 412 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// PoliciesPolicyIdEntriesLabelSubjectsPutOpts Optional parameters for the method 'PoliciesPolicyIdEntriesLabelSubjectsPut'
type PoliciesPolicyIdEntriesLabelSubjectsPutOpts struct {
    IfMatch optional.String
    IfNoneMatch optional.String
    Timeout optional.String
    ResponseRequired optional.Bool
}

/*
PoliciesPolicyIdEntriesLabelSubjectsPut Create or modify all Subjects for a specific Label of a specific policy
Create or modify at once ALL subjects of the policy entry identified by the &#x60;policyId&#x60; path parameter, and by the &#x60;label&#x60; path parameter.  ### Example - delete all subjects To delete all subjects set an empty body { }  ### Example - entities of Bosch IoT Permissions To add a user, a goup, and a role managed within Bosch IoT Permissions  &#x60;&#x60;&#x60; {   \&quot;iot-permissions:ID-user\&quot;: {     \&quot;type\&quot;: \&quot;iot-permissions-userid\&quot;   },   \&quot;iot-permissions:ID-group\&quot;: {     \&quot;type\&quot;: \&quot;iot-permissions-groupid\&quot;   },   \&quot;iot-permissions:ID-role\&quot;: {     \&quot;type\&quot;: \&quot;iot-permissions-roleid\&quot;   } } &#x60;&#x60;&#x60;  ### Example - technical clients To add a technical client &#x60;&#x60;&#x60; {    \&quot;iot-things:Your-Things-Solution-ID-user:your-postfix\&quot;: {      \&quot;type\&quot;: \&quot;iot-things-clientid\&quot;    },    \&quot;iot-integration:your-Things-solution-ID-user:bosch-iot-hub\&quot;: {      \&quot;type\&quot;: \&quot;hub-amqp-clientid\&quot;    },    \&quot;iot-suite:service:iot-things-eu-1:Your-Things-Solution-ID_things/full-access\&quot;: {      \&quot;type\&quot;: \&quot;suite-auth\&quot;    } } &#x60;&#x60;&#x60;
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param policyId The ID of the policy needs to follow the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).  The namespace needs to: * conform to the reverse domain name notation * be registered for your solution
 * @param label The label of a policy entry
 * @param subjects JSON representation of the Subjects.   Use the placeholder `{{ request:subjectId }}` in order to let the backend insert the authenticated subjectId of the HTTP request.
 * @param optional nil or *PoliciesPolicyIdEntriesLabelSubjectsPutOpts - Optional Parameters:
 * @param "IfMatch" (optional.String) -  The `If-Match` header which has to conform to RFC-7232 (Conditional Requests). Common usages are:   * optimistic locking by specifying the `ETag` from a previous HTTP response, e.g. `If-Match: \"hash:a75ece4e\"`   * retrieving or modifying a resource only if it already exists, e.g. `If-Match: *`
 * @param "IfNoneMatch" (optional.String) -  The `If-None-Match` header, which has to conform to RFC-7232 (Conditional Requests). A common usage scenario is to modify a resource only if it does not yet exist, thus to create it, by specifying `If-None-Match: *`.
 * @param "Timeout" (optional.String) -  Defines how long the backend should wait for completion of the request, e.g. applied when waiting for requested acknowledgements via the `requested-acks` param. Can be specified without unit (then seconds are assumed) or together with `s`, `ms` or `m` unit. Example: `42s`, `1m`.  The default (if omitted) timeout is `10s`. Maximum value: `60s`.  A value of `0` applies fire and forget semantics for the command resulting in setting `response-required=false`.
 * @param "ResponseRequired" (optional.Bool) -  Defines whether a response is required to the API call or not - if set to `false` the response will directly sent back with a status code of `202` (Accepted).  The default (if ommited) response is `true`.
*/
func (a *PoliciesApiService) PoliciesPolicyIdEntriesLabelSubjectsPut(ctx _context.Context, policyId string, label string, subjects Subjects, localVarOptionals *PoliciesPolicyIdEntriesLabelSubjectsPutOpts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/policies/{policyId}/entries/{label}/subjects"
	localVarPath = strings.Replace(localVarPath, "{"+"policyId"+"}", _neturl.QueryEscape(parameterToString(policyId, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"label"+"}", _neturl.QueryEscape(parameterToString(label, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Timeout.IsSet() {
		localVarQueryParams.Add("timeout", parameterToString(localVarOptionals.Timeout.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ResponseRequired.IsSet() {
		localVarQueryParams.Add("response-required", parameterToString(localVarOptionals.ResponseRequired.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.IfMatch.IsSet() {
		localVarHeaderParams["If-Match"] = parameterToString(localVarOptionals.IfMatch.Value(), "")
	}
	if localVarOptionals != nil && localVarOptionals.IfNoneMatch.IsSet() {
		localVarHeaderParams["If-None-Match"] = parameterToString(localVarOptionals.IfNoneMatch.Value(), "")
	}
	// body params
	localVarPostBody = &subjects
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-cr-api-token"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 402 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 412 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 413 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// PoliciesPolicyIdEntriesLabelSubjectsSubjectIdDeleteOpts Optional parameters for the method 'PoliciesPolicyIdEntriesLabelSubjectsSubjectIdDelete'
type PoliciesPolicyIdEntriesLabelSubjectsSubjectIdDeleteOpts struct {
    IfMatch optional.String
    IfNoneMatch optional.String
    Timeout optional.String
    ResponseRequired optional.Bool
}

/*
PoliciesPolicyIdEntriesLabelSubjectsSubjectIdDelete Delete one specific Subject for a specific Label of a specific policy
Deletes the subject with ID &#x60;subjectId&#x60; from the policy identified by the &#x60;policyId&#x60; path parameter and by the &#x60;label&#x60; path parameter.  Note: If the subject is used in other labels, it will not be deleted there, i.e. it will not lose those permissions, but only the permissions defined in the label specified at this path.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param policyId The ID of the policy needs to follow the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).  The namespace needs to: * conform to the reverse domain name notation * be registered for your solution
 * @param label The label of a policy entry
 * @param subjectId The ID of an (Authorization) Subject
 * @param optional nil or *PoliciesPolicyIdEntriesLabelSubjectsSubjectIdDeleteOpts - Optional Parameters:
 * @param "IfMatch" (optional.String) -  The `If-Match` header which has to conform to RFC-7232 (Conditional Requests). Common usages are:   * optimistic locking by specifying the `ETag` from a previous HTTP response, e.g. `If-Match: \"hash:a75ece4e\"`   * retrieving or modifying a resource only if it already exists, e.g. `If-Match: *`
 * @param "IfNoneMatch" (optional.String) -  The `If-None-Match` header, which has to conform to RFC-7232 (Conditional Requests). A common usage scenario is to modify a resource only if it does not yet exist, thus to create it, by specifying `If-None-Match: *`.
 * @param "Timeout" (optional.String) -  Defines how long the backend should wait for completion of the request, e.g. applied when waiting for requested acknowledgements via the `requested-acks` param. Can be specified without unit (then seconds are assumed) or together with `s`, `ms` or `m` unit. Example: `42s`, `1m`.  The default (if omitted) timeout is `10s`. Maximum value: `60s`.  A value of `0` applies fire and forget semantics for the command resulting in setting `response-required=false`.
 * @param "ResponseRequired" (optional.Bool) -  Defines whether a response is required to the API call or not - if set to `false` the response will directly sent back with a status code of `202` (Accepted).  The default (if ommited) response is `true`.
*/
func (a *PoliciesApiService) PoliciesPolicyIdEntriesLabelSubjectsSubjectIdDelete(ctx _context.Context, policyId string, label string, subjectId string, localVarOptionals *PoliciesPolicyIdEntriesLabelSubjectsSubjectIdDeleteOpts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/policies/{policyId}/entries/{label}/subjects/{subjectId}"
	localVarPath = strings.Replace(localVarPath, "{"+"policyId"+"}", _neturl.QueryEscape(parameterToString(policyId, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"label"+"}", _neturl.QueryEscape(parameterToString(label, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"subjectId"+"}", _neturl.QueryEscape(parameterToString(subjectId, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Timeout.IsSet() {
		localVarQueryParams.Add("timeout", parameterToString(localVarOptionals.Timeout.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ResponseRequired.IsSet() {
		localVarQueryParams.Add("response-required", parameterToString(localVarOptionals.ResponseRequired.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.IfMatch.IsSet() {
		localVarHeaderParams["If-Match"] = parameterToString(localVarOptionals.IfMatch.Value(), "")
	}
	if localVarOptionals != nil && localVarOptionals.IfNoneMatch.IsSet() {
		localVarHeaderParams["If-None-Match"] = parameterToString(localVarOptionals.IfNoneMatch.Value(), "")
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-cr-api-token"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 402 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 412 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// PoliciesPolicyIdEntriesLabelSubjectsSubjectIdGetOpts Optional parameters for the method 'PoliciesPolicyIdEntriesLabelSubjectsSubjectIdGet'
type PoliciesPolicyIdEntriesLabelSubjectsSubjectIdGetOpts struct {
    IfMatch optional.String
    IfNoneMatch optional.String
    Timeout optional.String
}

/*
PoliciesPolicyIdEntriesLabelSubjectsSubjectIdGet Retrieve one specific Subject for a specific Label of a specific policy
Returns the subject with ID &#x60;subjectId&#x60; of the policy entry identified by the &#x60;policyId&#x60; path parameter, and by the &#x60;label&#x60; path parameter.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param policyId The ID of the policy needs to follow the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).  The namespace needs to: * conform to the reverse domain name notation * be registered for your solution
 * @param label The label of a policy entry
 * @param subjectId The ID of an (Authorization) Subject
 * @param optional nil or *PoliciesPolicyIdEntriesLabelSubjectsSubjectIdGetOpts - Optional Parameters:
 * @param "IfMatch" (optional.String) -  The `If-Match` header which has to conform to RFC-7232 (Conditional Requests). Common usages are:   * optimistic locking by specifying the `ETag` from a previous HTTP response, e.g. `If-Match: \"hash:a75ece4e\"`   * retrieving or modifying a resource only if it already exists, e.g. `If-Match: *`
 * @param "IfNoneMatch" (optional.String) -  The `If-None-Match` header, which has to conform to RFC-7232 (Conditional Requests). A common usage scenario is to modify a resource only if it does not yet exist, thus to create it, by specifying `If-None-Match: *`.
 * @param "Timeout" (optional.String) -  Defines how long the backend should wait for completion of the request, e.g. applied when waiting for requested acknowledgements via the `requested-acks` param. Can be specified without unit (then seconds are assumed) or together with `s`, `ms` or `m` unit. Example: `42s`, `1m`.  The default (if omitted) timeout is `10s`. Maximum value: `60s`.  A value of `0` applies fire and forget semantics for the command resulting in setting `response-required=false`.
@return SubjectEntry
*/
func (a *PoliciesApiService) PoliciesPolicyIdEntriesLabelSubjectsSubjectIdGet(ctx _context.Context, policyId string, label string, subjectId string, localVarOptionals *PoliciesPolicyIdEntriesLabelSubjectsSubjectIdGetOpts) (SubjectEntry, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SubjectEntry
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/policies/{policyId}/entries/{label}/subjects/{subjectId}"
	localVarPath = strings.Replace(localVarPath, "{"+"policyId"+"}", _neturl.QueryEscape(parameterToString(policyId, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"label"+"}", _neturl.QueryEscape(parameterToString(label, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"subjectId"+"}", _neturl.QueryEscape(parameterToString(subjectId, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Timeout.IsSet() {
		localVarQueryParams.Add("timeout", parameterToString(localVarOptionals.Timeout.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.IfMatch.IsSet() {
		localVarHeaderParams["If-Match"] = parameterToString(localVarOptionals.IfMatch.Value(), "")
	}
	if localVarOptionals != nil && localVarOptionals.IfNoneMatch.IsSet() {
		localVarHeaderParams["If-None-Match"] = parameterToString(localVarOptionals.IfNoneMatch.Value(), "")
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-cr-api-token"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 402 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 412 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// PoliciesPolicyIdEntriesLabelSubjectsSubjectIdPutOpts Optional parameters for the method 'PoliciesPolicyIdEntriesLabelSubjectsSubjectIdPut'
type PoliciesPolicyIdEntriesLabelSubjectsSubjectIdPutOpts struct {
    IfMatch optional.String
    IfNoneMatch optional.String
    Timeout optional.String
    ResponseRequired optional.Bool
}

/*
PoliciesPolicyIdEntriesLabelSubjectsSubjectIdPut Create or modify one specific Subject for a specific Label of a specific policy
Create or modify the subject with ID &#x60;subjectId&#x60; of the policy identified by the &#x60;policyId&#x60; path parameter, and by the &#x60;label&#x60; path parameter.  ### Example -  add user managed within Bosch IoT Permissions To add a user managed within Bosch IoT Permissions, set the subjectId path to **iot-permissions:ID-user** and the body to  { \&quot;type\&quot;: \&quot;iot-permissions-userid\&quot; }.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param policyId The ID of the policy needs to follow the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).  The namespace needs to: * conform to the reverse domain name notation * be registered for your solution
 * @param label The label of a policy entry
 * @param subjectId The ID of an (Authorization) Subject
 * @param subjectEntry JSON representation of the Subject
 * @param optional nil or *PoliciesPolicyIdEntriesLabelSubjectsSubjectIdPutOpts - Optional Parameters:
 * @param "IfMatch" (optional.String) -  The `If-Match` header which has to conform to RFC-7232 (Conditional Requests). Common usages are:   * optimistic locking by specifying the `ETag` from a previous HTTP response, e.g. `If-Match: \"hash:a75ece4e\"`   * retrieving or modifying a resource only if it already exists, e.g. `If-Match: *`
 * @param "IfNoneMatch" (optional.String) -  The `If-None-Match` header, which has to conform to RFC-7232 (Conditional Requests). A common usage scenario is to modify a resource only if it does not yet exist, thus to create it, by specifying `If-None-Match: *`.
 * @param "Timeout" (optional.String) -  Defines how long the backend should wait for completion of the request, e.g. applied when waiting for requested acknowledgements via the `requested-acks` param. Can be specified without unit (then seconds are assumed) or together with `s`, `ms` or `m` unit. Example: `42s`, `1m`.  The default (if omitted) timeout is `10s`. Maximum value: `60s`.  A value of `0` applies fire and forget semantics for the command resulting in setting `response-required=false`.
 * @param "ResponseRequired" (optional.Bool) -  Defines whether a response is required to the API call or not - if set to `false` the response will directly sent back with a status code of `202` (Accepted).  The default (if ommited) response is `true`.
@return SubjectEntry
*/
func (a *PoliciesApiService) PoliciesPolicyIdEntriesLabelSubjectsSubjectIdPut(ctx _context.Context, policyId string, label string, subjectId string, subjectEntry SubjectEntry, localVarOptionals *PoliciesPolicyIdEntriesLabelSubjectsSubjectIdPutOpts) (SubjectEntry, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SubjectEntry
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/policies/{policyId}/entries/{label}/subjects/{subjectId}"
	localVarPath = strings.Replace(localVarPath, "{"+"policyId"+"}", _neturl.QueryEscape(parameterToString(policyId, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"label"+"}", _neturl.QueryEscape(parameterToString(label, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"subjectId"+"}", _neturl.QueryEscape(parameterToString(subjectId, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Timeout.IsSet() {
		localVarQueryParams.Add("timeout", parameterToString(localVarOptionals.Timeout.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ResponseRequired.IsSet() {
		localVarQueryParams.Add("response-required", parameterToString(localVarOptionals.ResponseRequired.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.IfMatch.IsSet() {
		localVarHeaderParams["If-Match"] = parameterToString(localVarOptionals.IfMatch.Value(), "")
	}
	if localVarOptionals != nil && localVarOptionals.IfNoneMatch.IsSet() {
		localVarHeaderParams["If-None-Match"] = parameterToString(localVarOptionals.IfNoneMatch.Value(), "")
	}
	// body params
	localVarPostBody = &subjectEntry
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-cr-api-token"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 402 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 412 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 413 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// PoliciesPolicyIdEntriesPutOpts Optional parameters for the method 'PoliciesPolicyIdEntriesPut'
type PoliciesPolicyIdEntriesPutOpts struct {
    IfMatch optional.String
    IfNoneMatch optional.String
    Timeout optional.String
    ResponseRequired optional.Bool
}

/*
PoliciesPolicyIdEntriesPut Modify the entries of a specific policy
Modify the policy entries of the policy identified by the &#x60;policyId&#x60; path parameter.  Note: Take care to not lock yourself out. Use the placeholder {{ request:subjectId }} in order to let the backend insert the authenticated subjectId of the HTTP request.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param policyId The ID of the policy needs to follow the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).  The namespace needs to: * conform to the reverse domain name notation * be registered for your solution
 * @param policyEntries JSON representation of the policy entries. Use the placeholder `{{ request:subjectId }}` in order to let the backend insert the authenticated subjectId of the HTTP request.
 * @param optional nil or *PoliciesPolicyIdEntriesPutOpts - Optional Parameters:
 * @param "IfMatch" (optional.String) -  The `If-Match` header which has to conform to RFC-7232 (Conditional Requests). Common usages are:   * optimistic locking by specifying the `ETag` from a previous HTTP response, e.g. `If-Match: \"hash:a75ece4e\"`   * retrieving or modifying a resource only if it already exists, e.g. `If-Match: *`
 * @param "IfNoneMatch" (optional.String) -  The `If-None-Match` header, which has to conform to RFC-7232 (Conditional Requests). A common usage scenario is to modify a resource only if it does not yet exist, thus to create it, by specifying `If-None-Match: *`.
 * @param "Timeout" (optional.String) -  Defines how long the backend should wait for completion of the request, e.g. applied when waiting for requested acknowledgements via the `requested-acks` param. Can be specified without unit (then seconds are assumed) or together with `s`, `ms` or `m` unit. Example: `42s`, `1m`.  The default (if omitted) timeout is `10s`. Maximum value: `60s`.  A value of `0` applies fire and forget semantics for the command resulting in setting `response-required=false`.
 * @param "ResponseRequired" (optional.Bool) -  Defines whether a response is required to the API call or not - if set to `false` the response will directly sent back with a status code of `202` (Accepted).  The default (if ommited) response is `true`.
*/
func (a *PoliciesApiService) PoliciesPolicyIdEntriesPut(ctx _context.Context, policyId string, policyEntries PolicyEntries, localVarOptionals *PoliciesPolicyIdEntriesPutOpts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/policies/{policyId}/entries"
	localVarPath = strings.Replace(localVarPath, "{"+"policyId"+"}", _neturl.QueryEscape(parameterToString(policyId, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Timeout.IsSet() {
		localVarQueryParams.Add("timeout", parameterToString(localVarOptionals.Timeout.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ResponseRequired.IsSet() {
		localVarQueryParams.Add("response-required", parameterToString(localVarOptionals.ResponseRequired.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.IfMatch.IsSet() {
		localVarHeaderParams["If-Match"] = parameterToString(localVarOptionals.IfMatch.Value(), "")
	}
	if localVarOptionals != nil && localVarOptionals.IfNoneMatch.IsSet() {
		localVarHeaderParams["If-None-Match"] = parameterToString(localVarOptionals.IfNoneMatch.Value(), "")
	}
	// body params
	localVarPostBody = &policyEntries
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-cr-api-token"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 402 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 412 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 413 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// PoliciesPolicyIdGetOpts Optional parameters for the method 'PoliciesPolicyIdGet'
type PoliciesPolicyIdGetOpts struct {
    IfMatch optional.String
    IfNoneMatch optional.String
    Timeout optional.String
}

/*
PoliciesPolicyIdGet Retrieve a specific policy
Returns the complete policy identified by the &#x60;policyId&#x60; path parameter. The response contains the policy as JSON object.  Tip: If you don&#39;t know the policy ID, request it via GET /things/{thingId}.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param policyId The ID of the policy needs to follow the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).  The namespace needs to: * conform to the reverse domain name notation * be registered for your solution
 * @param optional nil or *PoliciesPolicyIdGetOpts - Optional Parameters:
 * @param "IfMatch" (optional.String) -  The `If-Match` header, which has to conform to RFC-7232 (Conditional Requests). Common usages are:   * optimistic locking by specifying the `ETag` from a previous GET response, e.g. `If-Match: \"rev:4711\"`   * retrieving or modifying a resource only if it already exists, e.g. `If-Match: *`
 * @param "IfNoneMatch" (optional.String) -  The `If-None-Match` header, which has to conform to RFC-7232 (Conditional Requests). A common usage scenario is to modify a resource only if it does not yet exist, thus to create it, by specifying `If-None-Match: *`.
 * @param "Timeout" (optional.String) -  Defines how long the backend should wait for completion of the request, e.g. applied when waiting for requested acknowledgements via the `requested-acks` param. Can be specified without unit (then seconds are assumed) or together with `s`, `ms` or `m` unit. Example: `42s`, `1m`.  The default (if omitted) timeout is `10s`. Maximum value: `60s`.  A value of `0` applies fire and forget semantics for the command resulting in setting `response-required=false`.
@return Policy
*/
func (a *PoliciesApiService) PoliciesPolicyIdGet(ctx _context.Context, policyId string, localVarOptionals *PoliciesPolicyIdGetOpts) (Policy, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Policy
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/policies/{policyId}"
	localVarPath = strings.Replace(localVarPath, "{"+"policyId"+"}", _neturl.QueryEscape(parameterToString(policyId, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Timeout.IsSet() {
		localVarQueryParams.Add("timeout", parameterToString(localVarOptionals.Timeout.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.IfMatch.IsSet() {
		localVarHeaderParams["If-Match"] = parameterToString(localVarOptionals.IfMatch.Value(), "")
	}
	if localVarOptionals != nil && localVarOptionals.IfNoneMatch.IsSet() {
		localVarHeaderParams["If-None-Match"] = parameterToString(localVarOptionals.IfNoneMatch.Value(), "")
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-cr-api-token"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 402 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 412 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// PoliciesPolicyIdPutOpts Optional parameters for the method 'PoliciesPolicyIdPut'
type PoliciesPolicyIdPutOpts struct {
    IfMatch optional.String
    IfNoneMatch optional.String
    Timeout optional.String
    ResponseRequired optional.Bool
}

/*
PoliciesPolicyIdPut Create or update a policy with a specified ID
Create or update the policy specified by the policyId path parameter. * If you set a new policyId in the path, a new policy will be created. * If you set an existing policyId in the path, the policy will be updated.  ### Create a new policy At the initial creation of a policy, at least one valid entry is required. However, you can create a full-fledged policy all at once.  Example: To create a policy for multiple coffee maker things, which gives **yourself** all permissions on all resources, set the policyId in the path, e.g. to \&quot;com.acme.coffeemaker:policy-01\&quot; and the body part, like in the following snippet.  &#x60;&#x60;&#x60; {   \&quot;entries\&quot;: {     \&quot;DEFAULT\&quot;: {       \&quot;subjects\&quot;: {         \&quot;{{ request:subjectId }}\&quot;: {           \&quot;type\&quot;: \&quot;bosch-id\&quot;         }       },       \&quot;resources\&quot;: {         \&quot;policy:/\&quot;: {           \&quot;grant\&quot;: [             \&quot;READ\&quot;,             \&quot;WRITE\&quot;           ],           \&quot;revoke\&quot;: []         },         \&quot;thing:/\&quot;: {           \&quot;grant\&quot;: [             \&quot;READ\&quot;,             \&quot;WRITE\&quot;           ],           \&quot;revoke\&quot;: []         },         \&quot;message:/\&quot;: {           \&quot;grant\&quot;: [             \&quot;READ\&quot;,             \&quot;WRITE\&quot;           ],           \&quot;revoke\&quot;: []         }       }     }   } } &#x60;&#x60;&#x60;  ### Update an existing policy For updating an existing policy, the authorized subject needs WRITE permission on the policy&#39;s root resource.  The ID of a policy cannot be changed after creation. Any &#x60;policyId&#x60; specified in the request body is therefore ignored.  ### Partially update an existing policy Partial updates are not supported.  If you need to create or update a specific label, resource, or subject, please use the respective sub-resources.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param policyId The ID of the policy needs to follow the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).  The namespace needs to: * conform to the reverse domain name notation * be registered for your solution
 * @param policy JSON representation of the policy. Use the placeholder `{{ request:subjectId }}` in order to let the backend insert the authenticated subjectId of the HTTP request.
 * @param optional nil or *PoliciesPolicyIdPutOpts - Optional Parameters:
 * @param "IfMatch" (optional.String) -  The `If-Match` header, which has to conform to RFC-7232 (Conditional Requests). Common usages are:   * optimistic locking by specifying the `ETag` from a previous GET response, e.g. `If-Match: \"rev:4711\"`   * retrieving or modifying a resource only if it already exists, e.g. `If-Match: *`
 * @param "IfNoneMatch" (optional.String) -  The `If-None-Match` header, which has to conform to RFC-7232 (Conditional Requests). A common usage scenario is to modify a resource only if it does not yet exist, thus to create it, by specifying `If-None-Match: *`.
 * @param "Timeout" (optional.String) -  Defines how long the backend should wait for completion of the request, e.g. applied when waiting for requested acknowledgements via the `requested-acks` param. Can be specified without unit (then seconds are assumed) or together with `s`, `ms` or `m` unit. Example: `42s`, `1m`.  The default (if omitted) timeout is `10s`. Maximum value: `60s`.  A value of `0` applies fire and forget semantics for the command resulting in setting `response-required=false`.
 * @param "ResponseRequired" (optional.Bool) -  Defines whether a response is required to the API call or not - if set to `false` the response will directly sent back with a status code of `202` (Accepted).  The default (if ommited) response is `true`.
@return Policy
*/
func (a *PoliciesApiService) PoliciesPolicyIdPut(ctx _context.Context, policyId string, policy Policy, localVarOptionals *PoliciesPolicyIdPutOpts) (Policy, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Policy
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/policies/{policyId}"
	localVarPath = strings.Replace(localVarPath, "{"+"policyId"+"}", _neturl.QueryEscape(parameterToString(policyId, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Timeout.IsSet() {
		localVarQueryParams.Add("timeout", parameterToString(localVarOptionals.Timeout.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ResponseRequired.IsSet() {
		localVarQueryParams.Add("response-required", parameterToString(localVarOptionals.ResponseRequired.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.IfMatch.IsSet() {
		localVarHeaderParams["If-Match"] = parameterToString(localVarOptionals.IfMatch.Value(), "")
	}
	if localVarOptionals != nil && localVarOptionals.IfNoneMatch.IsSet() {
		localVarHeaderParams["If-None-Match"] = parameterToString(localVarOptionals.IfNoneMatch.Value(), "")
	}
	// body params
	localVarPostBody = &policy
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-cr-api-token"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 402 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 412 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 413 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
WhoamiGet Retrieve information about the current caller
Get information about the current caller, e.g. the auth subjects that are generated for the caller.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
@return WhoAmI
*/
func (a *PoliciesApiService) WhoamiGet(ctx _context.Context) (WhoAmI, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  WhoAmI
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/whoami"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-cr-api-token"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 402 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
