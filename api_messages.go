/*
 * Bosch IoT Things HTTP API
 *
 * Bosch IoT Things enables applications to manage digital twins of IoT device assets in a simple, convenient, robust, and secure way.  These descriptions focus on the JSON-based, REST-like **HTTP API 2** of the Bosch IoT Things service.  Find details in our [documentation](https://docs.bosch-iot-suite.com/things/).  The Bosch IoT Things HTTP API uses response status codes     (see [RFC 7231](https://tools.ietf.org/html/rfc7231#section-6))     to indicate whether a specific request has been successfully completed, or not. However, the descriptions we provide additionally to the status code (e.g. in our API docs, or error codes like. \"solutions:transaction.count.exceeded\") might change without advance notice. These are not be considered as official API, and must therefore not be applied in your applications or tests.
 *
 * API version: 2
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package iotthings

import (
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
	"github.com/antihax/optional"
)

// Linger please
var (
	_ _context.Context
)

// MessagesApiService MessagesApi service
type MessagesApiService service

// ThingsThingIdFeaturesFeatureIdInboxMessagesMessageSubjectPostOpts Optional parameters for the method 'ThingsThingIdFeaturesFeatureIdInboxMessagesMessageSubjectPost'
type ThingsThingIdFeaturesFeatureIdInboxMessagesMessageSubjectPostOpts struct {
    Timeout optional.Int32
    Body optional.String
}

/*
ThingsThingIdFeaturesFeatureIdInboxMessagesMessageSubjectPost Send a message TO a specific feature of a specific thing
Send a message with the subject &#x60;messageSubject&#x60; **to** the feature specified by the &#x60;featureId&#x60; and &#x60;thingId&#x60; path parameter. The request body contains the message payload and the &#x60;Content-Type&#x60; header defines its type. The API does not provide any kind of acknowledgement that the message was received by the feature.  The HTTP request blocks until a response to the message is available or until the &#x60;timeout&#x60; is expired. If many clients respond to the issued message, the first response will complete the HTTP request.  In order to handle the message in a fire and forget manner, add a query-parameter &#x60;timeout&#x3D;0&#x60; to the request.  Note that the client chooses which HTTP status code it wants to return. Things will forward the status code to you. (Also note that &#39;204 - No Content&#39; status code will never return a body, even if the client responded with a body).  ### Who You will need &#x60;WRITE&#x60; permission on the root \&quot;message:/\&quot; resource, or at least the resource &#x60;message:/features/featureId/inbox/messages/messageSubject&#x60;. The receiving device needs &#x60;READ&#x60; permission on the resource. Such permission is managed  within the policy which controls the access on the thing.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param thingId The ID of a thing needs to follow the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).  The namespace needs to be registered for your solution
 * @param featureId The ID of the feature - has to conform to RFC-3986 (URI)
 * @param messageSubject The subject of the Message - has to conform to RFC-3986 (URI)
 * @param optional nil or *ThingsThingIdFeaturesFeatureIdInboxMessagesMessageSubjectPostOpts - Optional Parameters:
 * @param "Timeout" (optional.Int32) -  Contains an optional timeout (in seconds) of how long to wait for the message response and therefore block the HTTP request. Default value (if omitted): 10 seconds. Maximum value: 60 seconds. A value of 0 seconds applies fire and forget semantics for the message.
 * @param "Body" (optional.String) -  Payload of the message with max size of 250 kB. It can be any HTTP supported content, including binary content.
*/
func (a *MessagesApiService) ThingsThingIdFeaturesFeatureIdInboxMessagesMessageSubjectPost(ctx _context.Context, thingId string, featureId string, messageSubject string, localVarOptionals *ThingsThingIdFeaturesFeatureIdInboxMessagesMessageSubjectPostOpts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/things/{thingId}/features/{featureId}/inbox/messages/{messageSubject}"
	localVarPath = strings.Replace(localVarPath, "{"+"thingId"+"}", _neturl.QueryEscape(parameterToString(thingId, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"featureId"+"}", _neturl.QueryEscape(parameterToString(featureId, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"messageSubject"+"}", _neturl.QueryEscape(parameterToString(messageSubject, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Timeout.IsSet() {
		localVarQueryParams.Add("timeout", parameterToString(localVarOptionals.Timeout.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/octet-stream", "text/plain"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {
		localVarPostBody = localVarOptionals.Body.Value()
	}

	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-cr-api-token"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 402 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 413 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// ThingsThingIdFeaturesFeatureIdOutboxMessagesMessageSubjectPostOpts Optional parameters for the method 'ThingsThingIdFeaturesFeatureIdOutboxMessagesMessageSubjectPost'
type ThingsThingIdFeaturesFeatureIdOutboxMessagesMessageSubjectPostOpts struct {
    Timeout optional.Int32
    Body optional.String
}

/*
ThingsThingIdFeaturesFeatureIdOutboxMessagesMessageSubjectPost Send a message FROM a specific feature of a specific thing
Send a message with the subject &#x60;messageSubject&#x60; **from** the feature specified by the &#x60;featureId&#x60; and &#x60;thingId&#x60; path parameter. The request body contains the message payload and the &#x60;Content-Type&#x60; header defines its type.  The HTTP request blocks until a response to the message is available or until the &#x60;timeout&#x60; is expired. If many clients respond to the issued message, the first response will complete the HTTP request.  In order to handle the message in a fire and forget manner, add a query-parameter &#x60;timeout&#x3D;0&#x60; to the request.  Note that the client chooses which HTTP status code it wants to return. Things will forward the status code to you. (Also note that &#39;204 - No Content&#39; status code will never return a body, even if the client responded with a body).  ### Who You will need &#x60;WRITE&#x60; permission on the root \&quot;message:/\&quot; resource, or at least the resource &#x60;message:/features/featureId/outbox/messages/messageSubject&#x60;. Such permission is managed  within the policy which controls the access on the thing.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param thingId The ID of a thing needs to follow the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).  The namespace needs to be registered for your solution
 * @param featureId The ID of the feature - has to conform to RFC-3986 (URI)
 * @param messageSubject The subject of the Message - has to conform to RFC-3986 (URI)
 * @param optional nil or *ThingsThingIdFeaturesFeatureIdOutboxMessagesMessageSubjectPostOpts - Optional Parameters:
 * @param "Timeout" (optional.Int32) -  Contains an optional timeout (in seconds) of how long to wait for the message response and therefore block the HTTP request. Default value (if omitted): 10 seconds. Maximum value: 60 seconds. A value of 0 seconds applies fire and forget semantics for the message.
 * @param "Body" (optional.String) -  Payload of the message with max size of 250 kB. It can be any HTTP supported content, including binary content.
*/
func (a *MessagesApiService) ThingsThingIdFeaturesFeatureIdOutboxMessagesMessageSubjectPost(ctx _context.Context, thingId string, featureId string, messageSubject string, localVarOptionals *ThingsThingIdFeaturesFeatureIdOutboxMessagesMessageSubjectPostOpts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/things/{thingId}/features/{featureId}/outbox/messages/{messageSubject}"
	localVarPath = strings.Replace(localVarPath, "{"+"thingId"+"}", _neturl.QueryEscape(parameterToString(thingId, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"featureId"+"}", _neturl.QueryEscape(parameterToString(featureId, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"messageSubject"+"}", _neturl.QueryEscape(parameterToString(messageSubject, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Timeout.IsSet() {
		localVarQueryParams.Add("timeout", parameterToString(localVarOptionals.Timeout.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/octet-stream", "text/plain"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {
		localVarPostBody = localVarOptionals.Body.Value()
	}

	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-cr-api-token"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 402 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 413 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// ThingsThingIdInboxClaimPostOpts Optional parameters for the method 'ThingsThingIdInboxClaimPost'
type ThingsThingIdInboxClaimPostOpts struct {
    Timeout optional.Int32
    Body optional.String
}

/*
ThingsThingIdInboxClaimPost Initiates claiming a specific thing in order to gain access
### Why A claiming process may enable an end-user to claim things and proof ownership thereof. Such a process is initially triggered via a claim message. This message can be sent to the things service with the HTTP API or the things-client.  ### How At this resource you can send a \&quot;claim\&quot; message to the thing identified by the &#x60;thingId&#x60; path parameter in order to gain access to it. The \&quot;claim\&quot; message is forwarded together with the request body and &#x60;Content-Type&#x60; header to client(s) which registered for Claim messages of the specific thing.  The decision whether to grant access (by setting permissions) is completely up to the client(s) which handle the \&quot;claim\&quot; message.  The HTTP request blocks until a response to the issued \&quot;claim\&quot; message is available or until the &#x60;timeout&#x60; is expired. If many clients respond to the issued message, the first response will complete the HTTP request.  Note that the client chooses which HTTP status code it wants to return. Things will forward the status code to you. (Also note that &#39;204 - No Content&#39; status code will never return a body, even if the client responded with a body).  ### Who No special permission is required to issue a claim message.  ### Example See [Claiming](https://docs.bosch-iot-suite.com/things/basic-concepts/auth/claim/) concept in detail and example in GitHub. However, in that scenario, the policy should grant you READ and WRITE permission on the \&quot;message:/\&quot; resource in order to be able to send the message and read the response. Further, the things-client which handles the \&quot;claim\&quot; message, needs permission to change the policy itself (i.e. READ and WRITE permission on the \&quot;policy:/\&quot; resource).
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param thingId The ID of a thing needs to follow the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).  The namespace needs to be registered for your solution
 * @param optional nil or *ThingsThingIdInboxClaimPostOpts - Optional Parameters:
 * @param "Timeout" (optional.Int32) -  Contains an optional timeout (in seconds) of how long to wait for the Claim response and therefore block the HTTP request. Default value (if omitted): 60 seconds. Maximum value: 600 seconds. A value of 0 seconds applies fire and forget semantics for the message.
 * @param "Body" (optional.String) -  Payload of the message with max size of 250 kB. It can be any HTTP supported content, including binary content.
*/
func (a *MessagesApiService) ThingsThingIdInboxClaimPost(ctx _context.Context, thingId string, localVarOptionals *ThingsThingIdInboxClaimPostOpts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/things/{thingId}/inbox/claim"
	localVarPath = strings.Replace(localVarPath, "{"+"thingId"+"}", _neturl.QueryEscape(parameterToString(thingId, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Timeout.IsSet() {
		localVarQueryParams.Add("timeout", parameterToString(localVarOptionals.Timeout.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/octet-stream", "text/plain"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {
		localVarPostBody = localVarOptionals.Body.Value()
	}

	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-cr-api-token"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 402 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 413 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// ThingsThingIdInboxMessagesMessageSubjectPostOpts Optional parameters for the method 'ThingsThingIdInboxMessagesMessageSubjectPost'
type ThingsThingIdInboxMessagesMessageSubjectPostOpts struct {
    Timeout optional.Int32
    Body optional.String
}

/*
ThingsThingIdInboxMessagesMessageSubjectPost Send a message TO a specific thing
### Why A message can be sent to a thing or one of its features in order to invoke an operation on the device.  ### How Send a message with a &#x60;messageSubject&#x60; **to** the thing identified by the &#x60;thingId&#x60; path parameter. The request body contains the message payload and the &#x60;Content-Type&#x60; header defines its type.  The API does not provide any kind of acknowledgement that the thing has received the message.  The HTTP request blocks until a response to the message is available or until the &#x60;timeout&#x60; is expired. If many clients respond to the issued message, the first response will complete the HTTP request.  In order to handle the message in a fire and forget manner, add a query-parameter &#x60;timeout&#x3D;0&#x60; to the request.  Note that the client chooses which HTTP status code it wants to return. Things will forward the status code to you. (Also note that &#39;204 - No Content&#39; status code will never return a body, even if the client responded with a body).  ### Who You will need &#x60;WRITE&#x60; permission on the root \&quot;message:/\&quot; resource, or at least the resource &#x60;message:/inbox/messages/messageSubject&#x60;. The receiving device needs &#x60;READ&#x60; permission on the resource. Such permission is managed within the policy which controls the access on the thing.  ### Example Given you have a \&quot;coffemaker\&quot; thing as shown in the examples for the &#x60;things&#x60; resources. The &#x60;messageSubject&#x60; understood by such a device would be \&quot;makeCoffee\&quot;.  Further, as in our example the \&quot;brewed-coffees\&quot; counter would increase as a response, you would need &#x60;WRITE&#x60; permission for the things resource, at least at the respective path  &#x60;/things/{thingId}/features/coffee-brewer/properties/brewed-coffees&#x60;
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param thingId The ID of a thing needs to follow the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).  The namespace needs to be registered for your solution
 * @param messageSubject The subject of the Message - has to conform to RFC-3986 (URI)
 * @param optional nil or *ThingsThingIdInboxMessagesMessageSubjectPostOpts - Optional Parameters:
 * @param "Timeout" (optional.Int32) -  Contains an optional timeout (in seconds) of how long to wait for the message response and therefore block the HTTP request. Default value (if omitted): 10 seconds. Maximum value: 60 seconds. A value of 0 seconds applies fire and forget semantics for the message.
 * @param "Body" (optional.String) -  Payload of the message with max size of 250 kB. It can be any HTTP supported content, including binary content.
*/
func (a *MessagesApiService) ThingsThingIdInboxMessagesMessageSubjectPost(ctx _context.Context, thingId string, messageSubject string, localVarOptionals *ThingsThingIdInboxMessagesMessageSubjectPostOpts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/things/{thingId}/inbox/messages/{messageSubject}"
	localVarPath = strings.Replace(localVarPath, "{"+"thingId"+"}", _neturl.QueryEscape(parameterToString(thingId, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"messageSubject"+"}", _neturl.QueryEscape(parameterToString(messageSubject, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Timeout.IsSet() {
		localVarQueryParams.Add("timeout", parameterToString(localVarOptionals.Timeout.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/octet-stream", "text/plain"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {
		localVarPostBody = localVarOptionals.Body.Value()
	}

	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-cr-api-token"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 402 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 413 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// ThingsThingIdOutboxMessagesMessageSubjectPostOpts Optional parameters for the method 'ThingsThingIdOutboxMessagesMessageSubjectPost'
type ThingsThingIdOutboxMessagesMessageSubjectPostOpts struct {
    Timeout optional.Int32
    Body optional.String
}

/*
ThingsThingIdOutboxMessagesMessageSubjectPost Send a message FROM a specific thing
Send a message with the subject &#x60;messageSubject&#x60; **from** the thing identified by the &#x60;thingId&#x60; path parameter. The request body contains the message payload and the &#x60;Content-Type&#x60; header defines its type.  The HTTP request blocks until a response to the message is available or until the &#x60;timeout&#x60; is expired. If many clients respond to the issued message, the first response will complete the HTTP request.  In order to handle the message in a fire and forget manner, add a query-parameter &#x60;timeout&#x3D;0&#x60; to the request.  Note that the client chooses which HTTP status code it wants to return. Things will forward the status code to you. (Also note that &#39;204 - No Content&#39; status code will never return a body, even if the client responded with a body).  ### Who You will need &#x60;WRITE&#x60; permission on the root \&quot;message:/\&quot; resource, or at least the resource &#x60;message:/outbox/messages/messageSubject&#x60;. Such permission is managed  within the policy which controls the access on the thing.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param thingId The ID of a thing needs to follow the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).  The namespace needs to be registered for your solution
 * @param messageSubject The subject of the Message - has to conform to RFC-3986 (URI)
 * @param optional nil or *ThingsThingIdOutboxMessagesMessageSubjectPostOpts - Optional Parameters:
 * @param "Timeout" (optional.Int32) -  Contains an optional timeout (in seconds) of how long to wait for the message response and therefore block the HTTP request. Default value (if omitted): 10 seconds. Maximum value: 60 seconds. A value of 0 seconds applies fire and forget semantics for the message.
 * @param "Body" (optional.String) -  Payload of the message with max size of 250 kB. It can be any HTTP supported content, including binary content.
*/
func (a *MessagesApiService) ThingsThingIdOutboxMessagesMessageSubjectPost(ctx _context.Context, thingId string, messageSubject string, localVarOptionals *ThingsThingIdOutboxMessagesMessageSubjectPostOpts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/things/{thingId}/outbox/messages/{messageSubject}"
	localVarPath = strings.Replace(localVarPath, "{"+"thingId"+"}", _neturl.QueryEscape(parameterToString(thingId, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"messageSubject"+"}", _neturl.QueryEscape(parameterToString(messageSubject, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Timeout.IsSet() {
		localVarQueryParams.Add("timeout", parameterToString(localVarOptionals.Timeout.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/octet-stream", "text/plain"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {
		localVarPostBody = localVarOptionals.Body.Value()
	}

	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["x-cr-api-token"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 402 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 413 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v AdvancedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
