openapi: 3.0.0
info:
  description: |-
    Bosch IoT Things enables applications to manage digital twins of IoT device assets in a simple, convenient, robust, and secure way.

    These descriptions focus on the JSON-based, REST-like **HTTP API 2** of the Bosch IoT Things service.

    Find details in our [documentation](https://docs.bosch-iot-suite.com/things/).

    The Bosch IoT Things HTTP API uses response status codes
        (see [RFC 7231](https://tools.ietf.org/html/rfc7231#section-6))
        to indicate whether a specific request has been successfully completed, or not. However, the descriptions we provide additionally to the status code (e.g. in our API docs, or error codes like. "solutions:transaction.count.exceeded") might change without advance notice. These are not be considered as official API, and must therefore not be applied in your applications or tests.
  title: Bosch IoT Things HTTP API
  version: "2"
servers:
- description: URL of the AWS environment
  url: https://things.eu-1.bosch-iot-suite.com/api/2
- description: URL of the BIC environment
  url: https://things.s-apps.de1.bosch-iot-cloud.com/api/2
- description: URL of the Azure environment
  url: https://things.eu-5.bosch-iot-suite.com/api/2
security:
- thingsApiToken: []
  bearerAuth: []
- thingsApiToken: []
  basicAuth: []
- thingsApiToken: []
  BoschID: []
- thingsApiToken: []
  SuiteAuth: []
tags:
- description: Manage every thing
  name: Things
- description: Structure the features of your things
  name: Features
- description: Control access to your things
  name: Policies
- description: Find every thing
  name: Things-Search
- description: Talk with your things
  name: Messages
- description: Get started with your service subscription
  name: Solutions
paths:
  /things:
    get:
      description: |-
        Returns all things passed in by the required parameter `ids`, which you (the authorized subject) are allowed to read.

        Optionally, if you want to retrieve only some of the thing's fields, you can use the specific field selectors (see parameter `fields`) .

        Tip: If you don't know the thing IDs, start with the search resource.
      parameters:
      - description: Contains a comma-separated list of `thingId`s to retrieve in
          one single request.
        explode: true
        in: query
        name: ids
        required: true
        schema:
          type: string
        style: form
      - description: |-
          Contains a comma-separated list of fields to be included in the returned
          JSON. attributes can be selected in the same manner.

          #### Selectable fields

          * `thingId`
          * `policyId`
          * `definition`
          * `attributes`

             Supports selecting arbitrary sub-fields by using a comma-separated list:
              * several attribute paths can be passed as a comma-separated list of JSON pointers (RFC-6901)

                For example:
                  * `?fields=attributes/model` would select only `model` attribute value (if present)
                  * `?fields=attributes/model,attributes/location` would select only `model` and
                     `location` attribute values (if present)

            Supports selecting arbitrary sub-fields of objects by wrapping sub-fields inside parentheses `( )`:
              * a comma-separated list of sub-fields (a sub-field is a JSON pointer (RFC-6901)
                separated with `/`) to select

              * sub-selectors can be used to request only specific sub-fields by placing expressions
                in parentheses `( )` after a selected subfield

                For example:
                 * `?fields=attributes(model,location)` would select only `model`
                    and `location` attribute values (if present)
                 * `?fields=attributes(coffeemaker/serialno)` would select the `serialno` value
                    inside the `coffeemaker` object
                 * `?fields=attributes/address/postal(city,street)` would select the `city` and
                    `street` values inside the `postal` object inside the `address` object

          * `features`

            Supports selecting arbitrary fields in features similar to `attributes` (see also features documentation for more details)

          * `_namespace`

            Specifically selects the namespace also contained in the `thingId`

          * `_revision`

            Specifically selects the revision of the thing. The revision is a counter, which is incremented on each modification of a thing.

          * `_modified`

            Specifically selects the modified timestamp of the thing in ISO-8601 UTC format. The timestamp is set on each modification of a thing.

          * `_policy`

            Specifically selects the content of the policy associated to the thing. (By default, only the policyId is returned.)

          #### Examples

          * `?fields=thingId,attributes,features`
          * `?fields=attributes(model,manufacturer),features`
        explode: true
        in: query
        name: fields
        required: false
        schema:
          type: string
        style: form
      - description: |-
          Defines how long the backend should wait for completion of the request, e.g. applied when waiting for requested
          acknowledgements via the `requested-acks` param. Can be specified without unit (then seconds are assumed) or
          together with `s`, `ms` or `m` unit. Example: `42s`, `1m`.

          The default (if omitted) timeout is `10s`. Maximum value: `60s`.

          A value of `0` applies fire and forget semantics for the command resulting in setting `response-required=false`.
        explode: true
        in: query
        name: timeout
        required: false
        schema:
          type: string
        style: form
      responses:
        "200":
          content:
            application/json:
              schema:
                items:
                  $ref: '#/components/schemas/Thing'
                type: array
          description: |-
            The successfully completed request contains as its result the first 200 things, for which the user has at
            least read permission.
            The things are sorted in the same order as the thing IDs were provided in the `ids` parameter.
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. At least one of the defined
            query parameters is invalid.
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to missing authentication.
        "402":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to exceeded transaction
            count.
        "403":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed due to a missing or invalid API
            Token.
        "414":
          description: |-
            The request could not be completed due to an URI length exceeding 8k
            characters.
      summary: Retrieve multiple things with specified IDs
      tags:
      - Things
    post:
      description: |-
        Creates a thing with a default `thingId` and a default `policyId`.

        The thing will be empty, i.e. no features, definition, attributes etc. by default.

        The default `thingId` consists of your default namespace and a UUID. Make sure a default
        namespace is registered for your solution.

        The default `policyId` is identical with the default `thingId`, and allows the currently authorized subject all permissions.

        In case you need to create a thing with a specific ID, use a *PUT* request instead, as any `thingId` specified in the request body will be ignored.
      parameters:
      - description: |-
          Contains the "requested acknowledgements" for this modifying request as comma separated list. The HTTP call will
          block until all requested acknowledgements were aggregated or will time out based on the specified `timeout`
          parameter.

          The default (if omitted) requested acks is `requested-acks=twin-persisted` which will block the
          HTTP call until the change was persited to the twin.
        explode: true
        in: query
        name: requested-acks
        required: false
        schema:
          type: string
        style: form
      - description: |-
          Defines how long the backend should wait for completion of the request, e.g. applied when waiting for requested
          acknowledgements via the `requested-acks` param. Can be specified without unit (then seconds are assumed) or
          together with `s`, `ms` or `m` unit. Example: `42s`, `1m`.

          The default (if omitted) timeout is `10s`. Maximum value: `60s`.

          A value of `0` applies fire and forget semantics for the command resulting in setting `response-required=false`.
        explode: true
        in: query
        name: timeout
        required: false
        schema:
          type: string
        style: form
      - description: |-
          Defines whether a response is required to the API call or not - if set to `false` the response will directly
          sent back with a status code of `202` (Accepted).

          The default (if ommited) response is `true`.
        explode: true
        in: query
        name: response-required
        required: false
        schema:
          type: boolean
        style: form
      requestBody:
        content:
          application/json:
            example:
              definition: com.acme:coffeebrewer:0.1.0
              attributes:
                manufacturer: ACME demo corp.
                location: Berlin, main floor
                serialno: "42"
                model: Speaking coffee machine
              features:
                coffee-brewer:
                  definition:
                  - com.acme:coffeebrewer:0.1.0
                  properties:
                    brewed-coffees: 0
                water-tank:
                  properties:
                    configuration:
                      smartMode: true
                      brewingTemp: 87
                      tempToHold: 44
                      timeoutSeconds: 6000
                    status:
                      waterAmount: 731
                      temperature: 44
            schema:
              $ref: '#/components/schemas/NewThing'
        description: JSON representation of the thing to be created. Use { } to create
          an empty thing with a default policy.
      responses:
        "201":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Thing'
          description: The thing was successfully created.
          headers:
            ETag:
              description: |-
                The (current server-side) ETag for this (sub-)resource. For top-level resources it is in the format
                "rev:[revision]", for sub-resources it has the format "hash:[calculated-hash]".
              explode: false
              schema:
                type: string
              style: simple
            Location:
              description: The location of the created thing resource
              explode: false
              schema:
                type: string
              style: simple
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. Possible reasons:

              * no default *namespace* is registered for your solution
              * the `thingId` must not be set in the request body
              * the JSON body of the thing to be created is invalid
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to missing authentication.
        "402":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to exceeded data volume
            or exceeded transaction count.
        "403":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed.
            Possible reasons:
              * the API Token is missing or invalid
              * the caller would not have access to the thing after creating it with the given policy.
              * the caller has insufficient permissions.
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. Possible reasons:
              * the referenced thing does not exist.
              * the caller had insufficient permissions to read the referenced thing.
              * the policy that should be copied does not exist.
              * the caller had insufficient permissions to read the policy that should be copied.
        "412":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            A precondition for reading or writing the (sub-)resource failed. This will happen for write requests, if you
            specified an If-Match or If-None-Match header, which fails the precondition check against the current ETag of
            the (sub-)resource. For read requests, this error may only happen for a failing If-Match header. In case of a
            failing If-None-Match header for a read request, status 304 will be returned instead.
          headers:
            ETag:
              description: |-
                The (current server-side) ETag for this (sub-)resource. For top-level resources it is in the format
                "rev:[revision]", for sub-resources it has the format "hash:[calculated-hash]".
              explode: false
              schema:
                type: string
              style: simple
        "413":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The created or modified entity is larger than the accepted
            limit of 100 kB.
      summary: Create a new thing
      tags:
      - Things
  /things/{thingId}:
    delete:
      description: |-
        Deletes the thing identified by the `thingId` path parameter.

        This will not delete the policy, which is used for controlling access to this thing.

        You can delete the policy afterwards via DELETE `/policies/{policyId}` if you don't need it for other things.
      parameters:
      - description: |-
          The ID of a thing needs to follow the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).

          The namespace needs to be registered for your solution
        explode: false
        in: path
        name: thingId
        required: true
        schema:
          type: string
        style: simple
      - description: |-
          The `If-Match` header, which has to conform to RFC-7232 (Conditional Requests). Common usages are:
            * optimistic locking by specifying the `ETag` from a previous GET response, e.g. `If-Match: "rev:4711"`
            * retrieving or modifying a resource only if it already exists, e.g. `If-Match: *`
        explode: false
        in: header
        name: If-Match
        required: false
        schema:
          type: string
        style: simple
      - description: 'The `If-None-Match` header, which has to conform to RFC-7232
          (Conditional Requests). A common usage scenario is to modify a resource
          only if it does not yet exist, thus to create it, by specifying `If-None-Match:
          *`.'
        explode: false
        in: header
        name: If-None-Match
        required: false
        schema:
          type: string
        style: simple
      - description: |-
          Contains the "requested acknowledgements" for this modifying request as comma separated list. The HTTP call will
          block until all requested acknowledgements were aggregated or will time out based on the specified `timeout`
          parameter.

          The default (if omitted) requested acks is `requested-acks=twin-persisted` which will block the
          HTTP call until the change was persited to the twin.
        explode: true
        in: query
        name: requested-acks
        required: false
        schema:
          type: string
        style: form
      - description: |-
          Defines how long the backend should wait for completion of the request, e.g. applied when waiting for requested
          acknowledgements via the `requested-acks` param. Can be specified without unit (then seconds are assumed) or
          together with `s`, `ms` or `m` unit. Example: `42s`, `1m`.

          The default (if omitted) timeout is `10s`. Maximum value: `60s`.

          A value of `0` applies fire and forget semantics for the command resulting in setting `response-required=false`.
        explode: true
        in: query
        name: timeout
        required: false
        schema:
          type: string
        style: form
      - description: |-
          Defines whether a response is required to the API call or not - if set to `false` the response will directly
          sent back with a status code of `202` (Accepted).

          The default (if ommited) response is `true`.
        explode: true
        in: query
        name: response-required
        required: false
        schema:
          type: boolean
        style: form
      responses:
        "204":
          description: The thing was successfully deleted.
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. Possible reasons:
              * the `thingId` does not conform to the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to missing authentication.
        "402":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to exceeded transaction
            count.
        "403":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. Possible reasons:
              * the API Token is missing or invalid
              * the caller had insufficient permissions.
                For deleting an existing thing, an unrestricted `WRITE` permission on the thing's root resource is required.
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. The thing with the given ID was
            not found.
        "412":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            A precondition for reading or writing the (sub-)resource failed. This will happen for write requests, if you
            specified an If-Match or If-None-Match header, which fails the precondition check against the current ETag of
            the (sub-)resource. For read requests, this error may only happen for a failing If-Match header. In case of a
            failing If-None-Match header for a read request, status 304 will be returned instead.
          headers:
            ETag:
              description: |-
                The (current server-side) ETag for this (sub-)resource. For top-level resources it is in the format
                "rev:[revision]", for sub-resources it has the format "hash:[calculated-hash]".
              explode: false
              schema:
                type: string
              style: simple
      summary: Delete a specific thing
      tags:
      - Things
    get:
      description: |-
        Returns the thing identified by the `thingId` path parameter. The
        response includes details about the thing, including the `policyId`, attributes, definition and features.

        Optionally, you can use the field selectors (see parameter `fields`) to only get specific
        fields, which you are interested in.

        Example: Use the field selector `_policy` to retrieve the content of the policy.
      parameters:
      - description: |-
          The ID of a thing needs to follow the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).

          The namespace needs to be registered for your solution
        explode: false
        in: path
        name: thingId
        required: true
        schema:
          type: string
        style: simple
      - description: |-
          Contains a comma-separated list of fields to be included in the returned
          JSON. attributes can be selected in the same manner.

          #### Selectable fields

          * `thingId`
          * `policyId`
          * `definition`
          * `attributes`

             Supports selecting arbitrary sub-fields by using a comma-separated list:
              * several attribute paths can be passed as a comma-separated list of JSON pointers (RFC-6901)

                For example:
                  * `?fields=attributes/model` would select only `model` attribute value (if present)
                  * `?fields=attributes/model,attributes/location` would select only `model` and
                     `location` attribute values (if present)

            Supports selecting arbitrary sub-fields of objects by wrapping sub-fields inside parentheses `( )`:
              * a comma-separated list of sub-fields (a sub-field is a JSON pointer (RFC-6901)
                separated with `/`) to select

              * sub-selectors can be used to request only specific sub-fields by placing expressions
                in parentheses `( )` after a selected subfield

                For example:
                 * `?fields=attributes(model,location)` would select only `model`
                    and `location` attribute values (if present)
                 * `?fields=attributes(coffeemaker/serialno)` would select the `serialno` value
                    inside the `coffeemaker` object
                 * `?fields=attributes/address/postal(city,street)` would select the `city` and
                    `street` values inside the `postal` object inside the `address` object

          * `features`

            Supports selecting arbitrary fields in features similar to `attributes` (see also features documentation for more details)

          * `_namespace`

            Specifically selects the namespace also contained in the `thingId`

          * `_revision`

            Specifically selects the revision of the thing. The revision is a counter, which is incremented on each modification of a thing.

          * `_modified`

            Specifically selects the modified timestamp of the thing in ISO-8601 UTC format. The timestamp is set on each modification of a thing.

          * `_policy`

            Specifically selects the content of the policy associated to the thing. (By default, only the policyId is returned.)

          #### Examples

          * `?fields=thingId,attributes,features`
          * `?fields=attributes(model,manufacturer),features`
        explode: true
        in: query
        name: fields
        required: false
        schema:
          type: string
        style: form
      - description: |-
          The `If-Match` header, which has to conform to RFC-7232 (Conditional Requests). Common usages are:
            * optimistic locking by specifying the `ETag` from a previous GET response, e.g. `If-Match: "rev:4711"`
            * retrieving or modifying a resource only if it already exists, e.g. `If-Match: *`
        explode: false
        in: header
        name: If-Match
        required: false
        schema:
          type: string
        style: simple
      - description: 'The `If-None-Match` header, which has to conform to RFC-7232
          (Conditional Requests). A common usage scenario is to modify a resource
          only if it does not yet exist, thus to create it, by specifying `If-None-Match:
          *`.'
        explode: false
        in: header
        name: If-None-Match
        required: false
        schema:
          type: string
        style: simple
      - description: |-
          Defines how long the backend should wait for completion of the request, e.g. applied when waiting for requested
          acknowledgements via the `requested-acks` param. Can be specified without unit (then seconds are assumed) or
          together with `s`, `ms` or `m` unit. Example: `42s`, `1m`.

          The default (if omitted) timeout is `10s`. Maximum value: `60s`.

          A value of `0` applies fire and forget semantics for the command resulting in setting `response-required=false`.
        explode: true
        in: query
        name: timeout
        required: false
        schema:
          type: string
        style: form
      responses:
        "200":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Thing'
          description: The request successfully returned the specific thing.
          headers:
            ETag:
              description: |-
                The (current server-side) ETag for this (sub-)resource. For top-level resources it is in the format
                "rev:[revision]", for sub-resources it has the format "hash:[calculated-hash]".
              explode: false
              schema:
                type: string
              style: simple
        "304":
          description: |-
            The (sub-)resource has not been modified. This happens if you specified a If-None-Match header, which
             matches the current ETag of the (sub-)resource.
          headers:
            ETag:
              description: |-
                The (current server-side) ETag for this (sub-)resource. For top-level resources it is in the format
                "rev:[revision]", for sub-resources it has the format "hash:[calculated-hash]".
              explode: false
              schema:
                type: string
              style: simple
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. Possible reasons:

              * the `thingId` does not conform to the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id))
              * at least one of the defined query parameters is invalid
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to missing authentication.
        "402":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to exceeded transaction
            count.
        "403":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed due to a missing or invalid API
            Token.
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. The thing with the given ID was
            not found.
        "412":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            A precondition for reading or writing the (sub-)resource failed. This will happen for write requests, if you
            specified an If-Match or If-None-Match header, which fails the precondition check against the current ETag of
            the (sub-)resource. For read requests, this error may only happen for a failing If-Match header. In case of a
            failing If-None-Match header for a read request, status 304 will be returned instead.
          headers:
            ETag:
              description: |-
                The (current server-side) ETag for this (sub-)resource. For top-level resources it is in the format
                "rev:[revision]", for sub-resources it has the format "hash:[calculated-hash]".
              explode: false
              schema:
                type: string
              style: simple
      summary: Retrieve a specific thing
      tags:
      - Things
    put:
      description: |-
        Create or update the thing specified by the `thingId` path parameter and
        the optional JSON body.

        * If you set a new `thingId` in the path, a thing will be created.
        * If you set an existing `thingId` in the path, the thing will be updated.


        ### Create a new thing
        At the initial creation of a thing, only a valid `thingId` is required.
        However, you can create a full-fledged thing all at once.

        Example:
        To create a coffee maker thing, set the `thingId` in the path, e.g. to "com.acme.coffeemaker:BE-42"
        and the body part, like in the following snippet.

        ```
         {
           "definition": "com.acme:coffeebrewer:0.1.0",
           "attributes": {
             "manufacturer": "ACME demo corp.",
             "location": "Berlin, main floor",
             "serialno": "42",
             "model": "Speaking coffee machine"
           },
           "features": {
             "coffee-brewer": {
               "definition": [ "com.acme:coffeebrewer:0.1.0" ],
               "properties": {
                 "brewed-coffees": 0
               }
             },
             "water-tank": {
               "properties": {
                 "configuration": {
                   "smartMode": true,
                   "brewingTemp": 87,
                   "tempToHold": 44,
                   "timeoutSeconds": 6000
                 },
                 "status": {
                   "waterAmount": 731,
                   "temperature": 44
                 }
               }
             }
           }
          }
         ```
        As the example does not set a policy in the request body, but the thing concept requires one,
        the service will create a default policy. The default policy, has the exactly same id
        as the thing, and grants ALL permissions to the authorized subject.

        In case you need to associate the new thing to an already existing policy you can additionally
        set a policy e.g. "policyId": "com.acme.coffeemaker:policy-1" as the first element in the body part.
        Keep in mind, that you can also change the assignment to another policy anytime,
        with a request on the sub-resource "PUT /things/{thingId}/policyId"

        ### Update an existing thing

        For updating an existing thing, the authorized subject needs **WRITE** permission on the thing's root resource.

        The ID of a thing cannot be changed after creation. Any `thingId`
        specified in the request body is therefore ignored.

        ### Partially update an existing thing

        When updating an existing thing, which already contains `attributes`, `definition` `policyId` or `features`,
        the existing fields must not explicitly be provided again.
        For this "PUT thing" request - and only for this top-level update on the thing -
        the top-level field to update is **merged** with the existing top-level fields of the thing.

        ### Example for a partial update

        Given, a thing already exists with this content:

        ```
        {
          "thingId": "namespace:thing-name",
          "policyId": "namespace:policy-name",
          "definition": "namespace:model:version",
          "attributes": {
            "foo": 1
          },
          "features": {...}
        }
        ```

        The thing's `attributes` may be modified without having to pass the `policyId` or
        the `features` in again.
        For updating the `attributes`, following request body would be sufficient :

        ```
        {
          "attributes": {
            "foo": 2,
            "bar": false
          }
        }
        ```

        The `policyId` and `features` of the thing will not be overwritten.
        The thing will be merged into:

        ```
        {
          "thingId": "namespace:thing-name",
          "policyId": "namespace:policy-name",
          "definition": "namespace:model:version",
          "attributes": {
            "foo": 2,
            "bar": false
          },
          "features": {...}
        }
        ```
      parameters:
      - description: |-
          The ID of a thing needs to follow the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).

          The namespace needs to be registered for your solution
        explode: false
        in: path
        name: thingId
        required: true
        schema:
          type: string
        style: simple
      - description: |-
          The `If-Match` header, which has to conform to RFC-7232 (Conditional Requests). Common usages are:
            * optimistic locking by specifying the `ETag` from a previous GET response, e.g. `If-Match: "rev:4711"`
            * retrieving or modifying a resource only if it already exists, e.g. `If-Match: *`
        explode: false
        in: header
        name: If-Match
        required: false
        schema:
          type: string
        style: simple
      - description: 'The `If-None-Match` header, which has to conform to RFC-7232
          (Conditional Requests). A common usage scenario is to modify a resource
          only if it does not yet exist, thus to create it, by specifying `If-None-Match:
          *`.'
        explode: false
        in: header
        name: If-None-Match
        required: false
        schema:
          type: string
        style: simple
      - description: |-
          Contains the "requested acknowledgements" for this modifying request as comma separated list. The HTTP call will
          block until all requested acknowledgements were aggregated or will time out based on the specified `timeout`
          parameter.

          The default (if omitted) requested acks is `requested-acks=twin-persisted` which will block the
          HTTP call until the change was persited to the twin.
        explode: true
        in: query
        name: requested-acks
        required: false
        schema:
          type: string
        style: form
      - description: |-
          Defines how long the backend should wait for completion of the request, e.g. applied when waiting for requested
          acknowledgements via the `requested-acks` param. Can be specified without unit (then seconds are assumed) or
          together with `s`, `ms` or `m` unit. Example: `42s`, `1m`.

          The default (if omitted) timeout is `10s`. Maximum value: `60s`.

          A value of `0` applies fire and forget semantics for the command resulting in setting `response-required=false`.
        explode: true
        in: query
        name: timeout
        required: false
        schema:
          type: string
        style: form
      - description: |-
          Defines whether a response is required to the API call or not - if set to `false` the response will directly
          sent back with a status code of `202` (Accepted).

          The default (if ommited) response is `true`.
        explode: true
        in: query
        name: response-required
        required: false
        schema:
          type: boolean
        style: form
      requestBody:
        content:
          application/json:
            example:
              definition: com.acme:coffeebrewer:0.1.0
              attributes:
                manufacturer: ACME demo corp.
                location: Berlin, main floor
                serialno: "42"
                model: Speaking coffee machine
              features:
                coffee-brewer:
                  definition:
                  - com.acme:coffeebrewer:0.1.0
                  properties:
                    brewed-coffees: 0
                water-tank:
                  properties:
                    configuration:
                      smartMode: true
                      brewingTemp: 87
                      tempToHold: 44
                      timeoutSeconds: 6000
                    status:
                      waterAmount: 731
                      temperature: 44
            schema:
              $ref: '#/components/schemas/NewThing'
        description: JSON representation of the thing to be modified.
      responses:
        "201":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Thing'
          description: The thing was successfully created.
          headers:
            ETag:
              description: |-
                The (current server-side) ETag for this (sub-)resource. For top-level resources it is in the format
                "rev:[revision]", for sub-resources it has the format "hash:[calculated-hash]".
              explode: false
              schema:
                type: string
              style: simple
            Location:
              description: The location of the created thing resource
              explode: false
              schema:
                type: string
              style: simple
        "204":
          description: The thing was successfully modified.
          headers:
            ETag:
              description: |-
                The (current server-side) ETag for this (sub-)resource. For top-level resources it is in the format
                "rev:[revision]", for sub-resources it has the format "hash:[calculated-hash]".
              explode: false
              schema:
                type: string
              style: simple
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. Possible reasons:

              * the `thingId` does not conform to the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id))
              * the namespace is not registered for your solution
              * the JSON body of the thing to be created/modified is invalid
              * the JSON body of the thing to be created/modified contains a `thingId`
              which does not match the ID in the path
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to missing authentication.
        "402":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to exceeded data volume
            or exceeded transaction count.
        "403":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. Possible reasons:
              * the API Token is missing or invalid
              * the caller would not have access to the thing after creating it with the given policy
              * the caller has insufficient permissions.
                For modifying an existing thing, an unrestricted `WRITE` permission on the thing's root resource is required.
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. Possible reasons:
              * the referenced thing does not exist.
              * the caller has insufficient permissions to read the referenced thing.
              * the policy that should be copied does not exist.
              * the caller has insufficient permissions to read the policy that should be copied.
        "412":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            A precondition for reading or writing the (sub-)resource failed. This will happen for write requests, if you
            specified an If-Match or If-None-Match header, which fails the precondition check against the current ETag of
            the (sub-)resource. For read requests, this error may only happen for a failing If-Match header. In case of a
            failing If-None-Match header for a read request, status 304 will be returned instead.
          headers:
            ETag:
              description: |-
                The (current server-side) ETag for this (sub-)resource. For top-level resources it is in the format
                "rev:[revision]", for sub-resources it has the format "hash:[calculated-hash]".
              explode: false
              schema:
                type: string
              style: simple
        "413":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The created or modified entity is larger than the accepted
            limit of 100 kB.
      summary: Create or update a thing with a specified ID
      tags:
      - Things
  /things/{thingId}/definition:
    delete:
      description: Deletes the definition of the thing identified by the `thingId`.
      parameters:
      - description: |-
          The ID of a thing needs to follow the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).

          The namespace needs to be registered for your solution
        explode: false
        in: path
        name: thingId
        required: true
        schema:
          type: string
        style: simple
      - description: |-
          The `If-Match` header which has to conform to RFC-7232 (Conditional Requests). Common usages are:
            * optimistic locking by specifying the `ETag` from a previous HTTP response, e.g. `If-Match: "hash:a75ece4e"`
            * retrieving or modifying a resource only if it already exists, e.g. `If-Match: *`
        explode: false
        in: header
        name: If-Match
        required: false
        schema:
          type: string
        style: simple
      - description: 'The `If-None-Match` header, which has to conform to RFC-7232
          (Conditional Requests). A common usage scenario is to modify a resource
          only if it does not yet exist, thus to create it, by specifying `If-None-Match:
          *`.'
        explode: false
        in: header
        name: If-None-Match
        required: false
        schema:
          type: string
        style: simple
      - description: |-
          Contains the "requested acknowledgements" for this modifying request as comma separated list. The HTTP call will
          block until all requested acknowledgements were aggregated or will time out based on the specified `timeout`
          parameter.

          The default (if omitted) requested acks is `requested-acks=twin-persisted` which will block the
          HTTP call until the change was persited to the twin.
        explode: true
        in: query
        name: requested-acks
        required: false
        schema:
          type: string
        style: form
      - description: |-
          Defines how long the backend should wait for completion of the request, e.g. applied when waiting for requested
          acknowledgements via the `requested-acks` param. Can be specified without unit (then seconds are assumed) or
          together with `s`, `ms` or `m` unit. Example: `42s`, `1m`.

          The default (if omitted) timeout is `10s`. Maximum value: `60s`.

          A value of `0` applies fire and forget semantics for the command resulting in setting `response-required=false`.
        explode: true
        in: query
        name: timeout
        required: false
        schema:
          type: string
        style: form
      - description: |-
          Defines whether a response is required to the API call or not - if set to `false` the response will directly
          sent back with a status code of `202` (Accepted).

          The default (if ommited) response is `true`.
        explode: true
        in: query
        name: response-required
        required: false
        schema:
          type: boolean
        style: form
      responses:
        "204":
          description: The definition was successfully deleted.
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. The `thingId` does not conform to the namespaced entity ID notation
            (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to missing authentication.
        "402":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to exceeded data volume
            or exceeded transaction count.
        "403":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. Possible reasons:

              * the API Token is missing or invalid
              * the caller has insufficient permissions.
                For modifying a definition of an existing thing, `WRITE` permission is required.
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. The thing with the given ID or
            its definition was not found.
        "412":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            A precondition for reading or writing the (sub-)resource failed. This will happen for write requests, if you
            specified an If-Match or If-None-Match header, which fails the precondition check against the current ETag of
            the (sub-)resource. For read requests, this error may only happen for a failing If-Match header. In case of a
            failing If-None-Match header for a read request, status 304 will be returned instead.
          headers:
            ETag:
              description: |-
                The (current server-side) ETag for this (sub-)resource. For top-level resources it is in the format
                "rev:[revision]", for sub-resources it has the format "hash:[calculated-hash]".
              explode: false
              schema:
                type: string
              style: simple
      summary: Delete the definition of a specific thing
      tags:
      - Things
    get:
      description: Returns the definition of the thing identified by the `thingId`
        path parameter.
      parameters:
      - description: |-
          The ID of a thing needs to follow the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).

          The namespace needs to be registered for your solution
        explode: false
        in: path
        name: thingId
        required: true
        schema:
          type: string
        style: simple
      - description: |-
          The `If-Match` header which has to conform to RFC-7232 (Conditional Requests). Common usages are:
            * optimistic locking by specifying the `ETag` from a previous HTTP response, e.g. `If-Match: "hash:a75ece4e"`
            * retrieving or modifying a resource only if it already exists, e.g. `If-Match: *`
        explode: false
        in: header
        name: If-Match
        required: false
        schema:
          type: string
        style: simple
      - description: 'The `If-None-Match` header, which has to conform to RFC-7232
          (Conditional Requests). A common usage scenario is to modify a resource
          only if it does not yet exist, thus to create it, by specifying `If-None-Match:
          *`.'
        explode: false
        in: header
        name: If-None-Match
        required: false
        schema:
          type: string
        style: simple
      - description: |-
          Defines how long the backend should wait for completion of the request, e.g. applied when waiting for requested
          acknowledgements via the `requested-acks` param. Can be specified without unit (then seconds are assumed) or
          together with `s`, `ms` or `m` unit. Example: `42s`, `1m`.

          The default (if omitted) timeout is `10s`. Maximum value: `60s`.

          A value of `0` applies fire and forget semantics for the command resulting in setting `response-required=false`.
        explode: true
        in: query
        name: timeout
        required: false
        schema:
          type: string
        style: form
      responses:
        "200":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Definition'
          description: The request successfully returned the definition of the specific
            thing.
          headers:
            ETag:
              description: |-
                The (current server-side) ETag for this (sub-)resource. For top-level resources it is in the format
                "rev:[revision]", for sub-resources it has the format "hash:[calculated-hash]".
              explode: false
              schema:
                type: string
              style: simple
        "304":
          description: |-
            The (sub-)resource has not been modified. This happens if you specified a If-None-Match header, which
             matches the current ETag of the (sub-)resource.
          headers:
            ETag:
              description: |-
                The (current server-side) ETag for this (sub-)resource. For top-level resources it is in the format
                "rev:[revision]", for sub-resources it has the format "hash:[calculated-hash]".
              explode: false
              schema:
                type: string
              style: simple
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. Possible reasons:

            * the `thingId` does not conform to the namespaced entity ID notation
            (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to missing authentication.
        "402":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to exceeded transaction
            count.
        "403":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. Possible reasons:

              * the API Token is missing or invalid
              * the caller has insufficient permissions.
                For modifying the definition of an existing thing, `WRITE` permission is required.
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. The thing with the given ID was
            not found.
        "412":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            A precondition for reading or writing the (sub-)resource failed. This will happen for write requests, if you
            specified an If-Match or If-None-Match header, which fails the precondition check against the current ETag of
            the (sub-)resource. For read requests, this error may only happen for a failing If-Match header. In case of a
            failing If-None-Match header for a read request, status 304 will be returned instead.
          headers:
            ETag:
              description: |-
                The (current server-side) ETag for this (sub-)resource. For top-level resources it is in the format
                "rev:[revision]", for sub-resources it has the format "hash:[calculated-hash]".
              explode: false
              schema:
                type: string
              style: simple
      summary: Retrieve the definition of a specific thing
      tags:
      - Things
    put:
      description: |-
        * If the thing does not have a definition yet, this request will create it.
        * If the thing already has a definition you can assign it to a new one by setting the new definition in the request body.
      parameters:
      - description: |-
          The ID of a thing needs to follow the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).

          The namespace needs to be registered for your solution
        explode: false
        in: path
        name: thingId
        required: true
        schema:
          type: string
        style: simple
      - description: |-
          The `If-Match` header which has to conform to RFC-7232 (Conditional Requests). Common usages are:
            * optimistic locking by specifying the `ETag` from a previous HTTP response, e.g. `If-Match: "hash:a75ece4e"`
            * retrieving or modifying a resource only if it already exists, e.g. `If-Match: *`
        explode: false
        in: header
        name: If-Match
        required: false
        schema:
          type: string
        style: simple
      - description: 'The `If-None-Match` header, which has to conform to RFC-7232
          (Conditional Requests). A common usage scenario is to modify a resource
          only if it does not yet exist, thus to create it, by specifying `If-None-Match:
          *`.'
        explode: false
        in: header
        name: If-None-Match
        required: false
        schema:
          type: string
        style: simple
      - description: |-
          Contains the "requested acknowledgements" for this modifying request as comma separated list. The HTTP call will
          block until all requested acknowledgements were aggregated or will time out based on the specified `timeout`
          parameter.

          The default (if omitted) requested acks is `requested-acks=twin-persisted` which will block the
          HTTP call until the change was persited to the twin.
        explode: true
        in: query
        name: requested-acks
        required: false
        schema:
          type: string
        style: form
      - description: |-
          Defines how long the backend should wait for completion of the request, e.g. applied when waiting for requested
          acknowledgements via the `requested-acks` param. Can be specified without unit (then seconds are assumed) or
          together with `s`, `ms` or `m` unit. Example: `42s`, `1m`.

          The default (if omitted) timeout is `10s`. Maximum value: `60s`.

          A value of `0` applies fire and forget semantics for the command resulting in setting `response-required=false`.
        explode: true
        in: query
        name: timeout
        required: false
        schema:
          type: string
        style: form
      - description: |-
          Defines whether a response is required to the API call or not - if set to `false` the response will directly
          sent back with a status code of `202` (Accepted).

          The default (if ommited) response is `true`.
        explode: true
        in: query
        name: response-required
        required: false
        schema:
          type: boolean
        style: form
      requestBody:
        $ref: '#/components/requestBodies/Definition'
      responses:
        "201":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Definition'
          description: The definition was successfully created.
          headers:
            ETag:
              description: |-
                The (current server-side) ETag for this (sub-)resource. For top-level resources it is in the format
                "rev:[revision]", for sub-resources it has the format "hash:[calculated-hash]".
              explode: false
              schema:
                type: string
              style: simple
            Location:
              description: The location of the created definition resource
              explode: false
              schema:
                type: string
              style: simple
        "204":
          description: The definition was successfully updated.
          headers:
            ETag:
              description: |-
                The (current server-side) ETag for this (sub-)resource. For top-level resources it is in the format
                "rev:[revision]", for sub-resources it has the format "hash:[calculated-hash]".
              explode: false
              schema:
                type: string
              style: simple
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. Possible reasons:

              * the `thingId` does not conform to the namespaced entity ID notation
                (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id))
              * the JSON was invalid
              * the request body was not a JSON object.
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to missing authentication.
        "402":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to exceeded data volume
            or exceeded transaction count.
        "403":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. Possible reasons:

              * the API Token is missing or invalid
              * the caller has insufficient permissions.
                For modifying a definition of an existing thing, `WRITE` permission is required.
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. The thing with the given ID was
            not found.
        "412":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            A precondition for reading or writing the (sub-)resource failed. This will happen for write requests, if you
            specified an If-Match or If-None-Match header, which fails the precondition check against the current ETag of
            the (sub-)resource. For read requests, this error may only happen for a failing If-Match header. In case of a
            failing If-None-Match header for a read request, status 304 will be returned instead.
          headers:
            ETag:
              description: |-
                The (current server-side) ETag for this (sub-)resource. For top-level resources it is in the format
                "rev:[revision]", for sub-resources it has the format "hash:[calculated-hash]".
              explode: false
              schema:
                type: string
              style: simple
        "413":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The created or modified entity is larger than the accepted
            limit of 100 kB.
      summary: Create or update the definition of a specific thing
      tags:
      - Things
  /things/{thingId}/policyId:
    get:
      description: Returns the policy ID of the thing identified by the `thingId`
        path parameter.
      parameters:
      - description: |-
          The ID of a thing needs to follow the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).

          The namespace needs to be registered for your solution
        explode: false
        in: path
        name: thingId
        required: true
        schema:
          type: string
        style: simple
      - description: |-
          The `If-Match` header which has to conform to RFC-7232 (Conditional Requests). Common usages are:
            * optimistic locking by specifying the `ETag` from a previous HTTP response, e.g. `If-Match: "hash:a75ece4e"`
            * retrieving or modifying a resource only if it already exists, e.g. `If-Match: *`
        explode: false
        in: header
        name: If-Match
        required: false
        schema:
          type: string
        style: simple
      - description: 'The `If-None-Match` header, which has to conform to RFC-7232
          (Conditional Requests). A common usage scenario is to modify a resource
          only if it does not yet exist, thus to create it, by specifying `If-None-Match:
          *`.'
        explode: false
        in: header
        name: If-None-Match
        required: false
        schema:
          type: string
        style: simple
      - description: |-
          Defines how long the backend should wait for completion of the request, e.g. applied when waiting for requested
          acknowledgements via the `requested-acks` param. Can be specified without unit (then seconds are assumed) or
          together with `s`, `ms` or `m` unit. Example: `42s`, `1m`.

          The default (if omitted) timeout is `10s`. Maximum value: `60s`.

          A value of `0` applies fire and forget semantics for the command resulting in setting `response-required=false`.
        explode: true
        in: query
        name: timeout
        required: false
        schema:
          type: string
        style: form
      responses:
        "200":
          content:
            application/json:
              schema:
                type: string
          description: The request successfully returned the policy ID.
          headers:
            ETag:
              description: |-
                The (current server-side) ETag for this (sub-)resource. For top-level resources it is in the format
                "rev:[revision]", for sub-resources it has the format "hash:[calculated-hash]".
              explode: false
              schema:
                type: string
              style: simple
        "304":
          description: |-
            The (sub-)resource has not been modified. This happens if you specified a If-None-Match header, which
             matches the current ETag of the (sub-)resource.
          headers:
            ETag:
              description: |-
                The (current server-side) ETag for this (sub-)resource. For top-level resources it is in the format
                "rev:[revision]", for sub-resources it has the format "hash:[calculated-hash]".
              explode: false
              schema:
                type: string
              style: simple
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. Possible reasons:
              * the `thingId` does not conform to the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to missing authentication.
        "402":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to exceeded transaction
            count.
        "403":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to a missing or invalid
            API Token.
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed. The thing with the given
            ID was not found in the context of the authenticated user.
        "412":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            A precondition for reading or writing the (sub-)resource failed. This will happen for write requests, if you
            specified an If-Match or If-None-Match header, which fails the precondition check against the current ETag of
            the (sub-)resource. For read requests, this error may only happen for a failing If-Match header. In case of a
            failing If-None-Match header for a read request, status 304 will be returned instead.
          headers:
            ETag:
              description: |-
                The (current server-side) ETag for this (sub-)resource. For top-level resources it is in the format
                "rev:[revision]", for sub-resources it has the format "hash:[calculated-hash]".
              explode: false
              schema:
                type: string
              style: simple
      summary: Retrieve the policy ID of a thing
      tags:
      - Things
    put:
      description: |-
        Create or update the policy ID of the thing identified by the `thingId`
        path parameter.

        ### Create
        If the thing does not have a `policyId` yet, it is
        considered to have been created via API version 1, where the access control list `acl`
        mechanism is used. In that case, this request will create the `policyId`.

        Note: You will need to create the policy content separately.

        ### Update
        If the thing already has a `policyId` you can assign it to an existing policy by setting
        the new `policyId` in the request body.
      parameters:
      - description: |-
          The ID of a thing needs to follow the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).

          The namespace needs to be registered for your solution
        explode: false
        in: path
        name: thingId
        required: true
        schema:
          type: string
        style: simple
      - description: |-
          The `If-Match` header which has to conform to RFC-7232 (Conditional Requests). Common usages are:
            * optimistic locking by specifying the `ETag` from a previous HTTP response, e.g. `If-Match: "hash:a75ece4e"`
            * retrieving or modifying a resource only if it already exists, e.g. `If-Match: *`
        explode: false
        in: header
        name: If-Match
        required: false
        schema:
          type: string
        style: simple
      - description: 'The `If-None-Match` header, which has to conform to RFC-7232
          (Conditional Requests). A common usage scenario is to modify a resource
          only if it does not yet exist, thus to create it, by specifying `If-None-Match:
          *`.'
        explode: false
        in: header
        name: If-None-Match
        required: false
        schema:
          type: string
        style: simple
      - description: |-
          Contains the "requested acknowledgements" for this modifying request as comma separated list. The HTTP call will
          block until all requested acknowledgements were aggregated or will time out based on the specified `timeout`
          parameter.

          The default (if omitted) requested acks is `requested-acks=twin-persisted` which will block the
          HTTP call until the change was persited to the twin.
        explode: true
        in: query
        name: requested-acks
        required: false
        schema:
          type: string
        style: form
      - description: |-
          Defines how long the backend should wait for completion of the request, e.g. applied when waiting for requested
          acknowledgements via the `requested-acks` param. Can be specified without unit (then seconds are assumed) or
          together with `s`, `ms` or `m` unit. Example: `42s`, `1m`.

          The default (if omitted) timeout is `10s`. Maximum value: `60s`.

          A value of `0` applies fire and forget semantics for the command resulting in setting `response-required=false`.
        explode: true
        in: query
        name: timeout
        required: false
        schema:
          type: string
        style: form
      - description: |-
          Defines whether a response is required to the API call or not - if set to `false` the response will directly
          sent back with a status code of `202` (Accepted).

          The default (if ommited) response is `true`.
        explode: true
        in: query
        name: response-required
        required: false
        schema:
          type: boolean
        style: form
      requestBody:
        content:
          application/json:
            schema:
              example: '"your.namespace:your-policy-name"'
              type: string
        description: |-
          The policy is used for controlling access to this thing. It is managed by
          resource `/policies/{policyId}`.

          The ID of a policy needs to conform to the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).

          The namespace needs to be registered for your solution
        required: true
      responses:
        "201":
          content:
            application/json:
              schema:
                type: string
          description: 'The policy ID was successfully created. Note: You will need
            to create the policy content separately.'
          headers:
            ETag:
              description: |-
                The (current server-side) ETag for this (sub-)resource. For top-level resources it is in the format
                "rev:[revision]", for sub-resources it has the format "hash:[calculated-hash]".
              explode: false
              schema:
                type: string
              style: simple
        "204":
          description: The policy ID was successfully updated.
          headers:
            ETag:
              description: |-
                The (current server-side) ETag for this (sub-)resource. For top-level resources it is in the format
                "rev:[revision]", for sub-resources it has the format "hash:[calculated-hash]".
              explode: false
              schema:
                type: string
              style: simple
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. Possible reasons:

              * the `thingId` does not conform to the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id))
              * the namespace is not registered for your solution
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to missing authentication.
        "402":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to exceeded data volume
            or exceeded transaction count.
        "403":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to a missing or invalid
            API Token.
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. The thing with the given ID was
            not found in the context of the authenticated user.
        "412":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            A precondition for reading or writing the (sub-)resource failed. This will happen for write requests, if you
            specified an If-Match or If-None-Match header, which fails the precondition check against the current ETag of
            the (sub-)resource. For read requests, this error may only happen for a failing If-Match header. In case of a
            failing If-None-Match header for a read request, status 304 will be returned instead.
          headers:
            ETag:
              description: |-
                The (current server-side) ETag for this (sub-)resource. For top-level resources it is in the format
                "rev:[revision]", for sub-resources it has the format "hash:[calculated-hash]".
              explode: false
              schema:
                type: string
              style: simple
        "413":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The created or modified entity is larger than the accepted
            limit of 100 kB.
      summary: Create or update the policy ID of a thing
      tags:
      - Things
  /things/{thingId}/attributes:
    delete:
      description: |-
        Deletes all attributes of the thing identified by the `thingId` path
        parameter.
      parameters:
      - description: |-
          The ID of a thing needs to follow the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).

          The namespace needs to be registered for your solution
        explode: false
        in: path
        name: thingId
        required: true
        schema:
          type: string
        style: simple
      - description: |-
          The `If-Match` header which has to conform to RFC-7232 (Conditional Requests). Common usages are:
            * optimistic locking by specifying the `ETag` from a previous HTTP response, e.g. `If-Match: "hash:a75ece4e"`
            * retrieving or modifying a resource only if it already exists, e.g. `If-Match: *`
        explode: false
        in: header
        name: If-Match
        required: false
        schema:
          type: string
        style: simple
      - description: 'The `If-None-Match` header, which has to conform to RFC-7232
          (Conditional Requests). A common usage scenario is to modify a resource
          only if it does not yet exist, thus to create it, by specifying `If-None-Match:
          *`.'
        explode: false
        in: header
        name: If-None-Match
        required: false
        schema:
          type: string
        style: simple
      - description: |-
          Contains the "requested acknowledgements" for this modifying request as comma separated list. The HTTP call will
          block until all requested acknowledgements were aggregated or will time out based on the specified `timeout`
          parameter.

          The default (if omitted) requested acks is `requested-acks=twin-persisted` which will block the
          HTTP call until the change was persited to the twin.
        explode: true
        in: query
        name: requested-acks
        required: false
        schema:
          type: string
        style: form
      - description: |-
          Defines how long the backend should wait for completion of the request, e.g. applied when waiting for requested
          acknowledgements via the `requested-acks` param. Can be specified without unit (then seconds are assumed) or
          together with `s`, `ms` or `m` unit. Example: `42s`, `1m`.

          The default (if omitted) timeout is `10s`. Maximum value: `60s`.

          A value of `0` applies fire and forget semantics for the command resulting in setting `response-required=false`.
        explode: true
        in: query
        name: timeout
        required: false
        schema:
          type: string
        style: form
      - description: |-
          Defines whether a response is required to the API call or not - if set to `false` the response will directly
          sent back with a status code of `202` (Accepted).

          The default (if ommited) response is `true`.
        explode: true
        in: query
        name: response-required
        required: false
        schema:
          type: boolean
        style: form
      responses:
        "204":
          description: The attributes were successfully deleted.
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. Possible reasons:
              * the `thingId` does not conform to the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to missing authentication.
        "402":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to exceeded transaction
            count.
        "403":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. Possible reasons:
              * the API Token is missing or invalid
              * the caller has insufficient permissions.
                For deleting all attributes of an existing thing, `WRITE` permission is required.
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. The thing with the given ID or
            its attributes were not found.
        "412":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            A precondition for reading or writing the (sub-)resource failed. This will happen for write requests, if you
            specified an If-Match or If-None-Match header, which fails the precondition check against the current ETag of
            the (sub-)resource. For read requests, this error may only happen for a failing If-Match header. In case of a
            failing If-None-Match header for a read request, status 304 will be returned instead.
          headers:
            ETag:
              description: |-
                The (current server-side) ETag for this (sub-)resource. For top-level resources it is in the format
                "rev:[revision]", for sub-resources it has the format "hash:[calculated-hash]".
              explode: false
              schema:
                type: string
              style: simple
      summary: Delete all attributes of a specific thing at once
      tags:
      - Things
    get:
      description: Returns all attributes of the thing identified by the `thingId`
        path parameter.
      parameters:
      - description: |-
          The ID of a thing needs to follow the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).

          The namespace needs to be registered for your solution
        explode: false
        in: path
        name: thingId
        required: true
        schema:
          type: string
        style: simple
      - description: |-
          Contains a comma-separated list of fields from the attributes to be
          included in the returned JSON.

          #### Selectable fields

          Supports selecting arbitrary sub-fields as defined in the attributes by
          using a comma-separated list:
            * several properties paths can be passed as a comma-separated list of JSON pointers (RFC-6901)

              For example:
                * `?fields=model` would select only `model` attribute value (if present)
                * `?fields=model,make` would select `model` and `make` attribute values (if present)

          Supports selecting arbitrary sub-fields of objects by wrapping sub-fields
          inside parentheses `( )`:
            * a comma-separated list of sub-fields (a sub-field is a JSON pointer (RFC-6901) separated with `/`) to select
            * sub-selectors can be used to request only specific sub-fields by placing expressions in parentheses `( )` after a selected subfield

              For example:
               * `?fields=location(longitude,latitude)` would select the `longitude` and `latitude` value inside the `location` attribute

          #### Examples

          * `?fields=model,make,location(longitude,latitude)`

          * `?fields=listOfAddresses/postal(city,street))`
        explode: true
        in: query
        name: fields
        required: false
        schema:
          type: string
        style: form
      - description: |-
          The `If-Match` header which has to conform to RFC-7232 (Conditional Requests). Common usages are:
            * optimistic locking by specifying the `ETag` from a previous HTTP response, e.g. `If-Match: "hash:a75ece4e"`
            * retrieving or modifying a resource only if it already exists, e.g. `If-Match: *`
        explode: false
        in: header
        name: If-Match
        required: false
        schema:
          type: string
        style: simple
      - description: 'The `If-None-Match` header, which has to conform to RFC-7232
          (Conditional Requests). A common usage scenario is to modify a resource
          only if it does not yet exist, thus to create it, by specifying `If-None-Match:
          *`.'
        explode: false
        in: header
        name: If-None-Match
        required: false
        schema:
          type: string
        style: simple
      - description: |-
          Defines how long the backend should wait for completion of the request, e.g. applied when waiting for requested
          acknowledgements via the `requested-acks` param. Can be specified without unit (then seconds are assumed) or
          together with `s`, `ms` or `m` unit. Example: `42s`, `1m`.

          The default (if omitted) timeout is `10s`. Maximum value: `60s`.

          A value of `0` applies fire and forget semantics for the command resulting in setting `response-required=false`.
        explode: true
        in: query
        name: timeout
        required: false
        schema:
          type: string
        style: form
      responses:
        "200":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Attributes'
          description: The attributes of the specific thing were successfully retrieved.
          headers:
            ETag:
              description: |-
                The (current server-side) ETag for this (sub-)resource. For top-level resources it is in the format
                "rev:[revision]", for sub-resources it has the format "hash:[calculated-hash]".
              explode: false
              schema:
                type: string
              style: simple
        "304":
          description: |-
            The (sub-)resource has not been modified. This happens if you specified a If-None-Match header, which
             matches the current ETag of the (sub-)resource.
          headers:
            ETag:
              description: |-
                The (current server-side) ETag for this (sub-)resource. For top-level resources it is in the format
                "rev:[revision]", for sub-resources it has the format "hash:[calculated-hash]".
              explode: false
              schema:
                type: string
              style: simple
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. Possible reasons:

            * the `thingId` does not conform to the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id))
              * the namespace is not registered for your solution
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to missing authentication.
        "402":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to exceeded transaction
            count.
        "403":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to a missing or invalid
            API Token.
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed. The thing with the given
            ID was not found.
        "412":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            A precondition for reading or writing the (sub-)resource failed. This will happen for write requests, if you
            specified an If-Match or If-None-Match header, which fails the precondition check against the current ETag of
            the (sub-)resource. For read requests, this error may only happen for a failing If-Match header. In case of a
            failing If-None-Match header for a read request, status 304 will be returned instead.
          headers:
            ETag:
              description: |-
                The (current server-side) ETag for this (sub-)resource. For top-level resources it is in the format
                "rev:[revision]", for sub-resources it has the format "hash:[calculated-hash]".
              explode: false
              schema:
                type: string
              style: simple
      summary: List all attributes of a specific thing
      tags:
      - Things
    put:
      description: |-
        Create or update the attributes of a thing identified by the `thingId`
        path parameter. The attributes will be overwritten - all at once - with the
        content (JSON) set in the request body.
      parameters:
      - description: |-
          The ID of a thing needs to follow the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).

          The namespace needs to be registered for your solution
        explode: false
        in: path
        name: thingId
        required: true
        schema:
          type: string
        style: simple
      - description: |-
          The `If-Match` header which has to conform to RFC-7232 (Conditional Requests). Common usages are:
            * optimistic locking by specifying the `ETag` from a previous HTTP response, e.g. `If-Match: "hash:a75ece4e"`
            * retrieving or modifying a resource only if it already exists, e.g. `If-Match: *`
        explode: false
        in: header
        name: If-Match
        required: false
        schema:
          type: string
        style: simple
      - description: 'The `If-None-Match` header, which has to conform to RFC-7232
          (Conditional Requests). A common usage scenario is to modify a resource
          only if it does not yet exist, thus to create it, by specifying `If-None-Match:
          *`.'
        explode: false
        in: header
        name: If-None-Match
        required: false
        schema:
          type: string
        style: simple
      - description: |-
          Contains the "requested acknowledgements" for this modifying request as comma separated list. The HTTP call will
          block until all requested acknowledgements were aggregated or will time out based on the specified `timeout`
          parameter.

          The default (if omitted) requested acks is `requested-acks=twin-persisted` which will block the
          HTTP call until the change was persited to the twin.
        explode: true
        in: query
        name: requested-acks
        required: false
        schema:
          type: string
        style: form
      - description: |-
          Defines how long the backend should wait for completion of the request, e.g. applied when waiting for requested
          acknowledgements via the `requested-acks` param. Can be specified without unit (then seconds are assumed) or
          together with `s`, `ms` or `m` unit. Example: `42s`, `1m`.

          The default (if omitted) timeout is `10s`. Maximum value: `60s`.

          A value of `0` applies fire and forget semantics for the command resulting in setting `response-required=false`.
        explode: true
        in: query
        name: timeout
        required: false
        schema:
          type: string
        style: form
      - description: |-
          Defines whether a response is required to the API call or not - if set to `false` the response will directly
          sent back with a status code of `202` (Accepted).

          The default (if ommited) response is `true`.
        explode: true
        in: query
        name: response-required
        required: false
        schema:
          type: boolean
        style: form
      requestBody:
        $ref: '#/components/requestBodies/Attributes'
      responses:
        "201":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Attributes'
          description: The attributes were successfully created.
          headers:
            ETag:
              description: |-
                The (current server-side) ETag for this (sub-)resource. For top-level resources it is in the format
                "rev:[revision]", for sub-resources it has the format "hash:[calculated-hash]".
              explode: false
              schema:
                type: string
              style: simple
            Location:
              description: The location of the created attribute resource
              explode: false
              schema:
                type: string
              style: simple
        "204":
          description: The attributes were successfully updated.
          headers:
            ETag:
              description: |-
                The (current server-side) ETag for this (sub-)resource. For top-level resources it is in the format
                "rev:[revision]", for sub-resources it has the format "hash:[calculated-hash]".
              explode: false
              schema:
                type: string
              style: simple
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. Possible reasons:
              * the `thingId` does not conform to the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).
              * the JSON body of the attributes to be created/modified is invalid
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to missing authentication.
        "402":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to exceeded data volume
            or exceeded transaction count.
        "403":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. Possible reasons:
              * the API Token is missing or invalid
              * the caller has insufficient permissions.
                For modifying the attributes of an existing thing, `WRITE` permission is required.
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. The thing with the given ID was
            not found.
        "412":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            A precondition for reading or writing the (sub-)resource failed. This will happen for write requests, if you
            specified an If-Match or If-None-Match header, which fails the precondition check against the current ETag of
            the (sub-)resource. For read requests, this error may only happen for a failing If-Match header. In case of a
            failing If-None-Match header for a read request, status 304 will be returned instead.
          headers:
            ETag:
              description: |-
                The (current server-side) ETag for this (sub-)resource. For top-level resources it is in the format
                "rev:[revision]", for sub-resources it has the format "hash:[calculated-hash]".
              explode: false
              schema:
                type: string
              style: simple
        "413":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The created or modified entity is larger than the accepted
            limit of 100 kB.
      summary: Create or update all attributes of a specific thing at once
      tags:
      - Things
  /things/{thingId}/attributes/{attributePath}:
    delete:
      description: |-
        Deletes a specific attribute of the thing identified by the `thingId`
        path parameter.

        The attribute (JSON) can be referenced hierarchically, by applying JSON Pointer notation (RFC-6901).

        Example: In order to delete the `name` field of an `manufacturer` attribute, the full path would be
                `/things/{thingId}/attributes/manufacturer/name`
      parameters:
      - description: |-
          The ID of a thing needs to follow the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).

          The namespace needs to be registered for your solution
        explode: false
        in: path
        name: thingId
        required: true
        schema:
          type: string
        style: simple
      - description: The path to the attribute, e.g. **manufacturer/name**
        explode: false
        in: path
        name: attributePath
        required: true
        schema:
          type: string
        style: simple
      - description: |-
          The `If-Match` header which has to conform to RFC-7232 (Conditional Requests). Common usages are:
            * optimistic locking by specifying the `ETag` from a previous HTTP response, e.g. `If-Match: "hash:a75ece4e"`
            * retrieving or modifying a resource only if it already exists, e.g. `If-Match: *`
        explode: false
        in: header
        name: If-Match
        required: false
        schema:
          type: string
        style: simple
      - description: 'The `If-None-Match` header, which has to conform to RFC-7232
          (Conditional Requests). A common usage scenario is to modify a resource
          only if it does not yet exist, thus to create it, by specifying `If-None-Match:
          *`.'
        explode: false
        in: header
        name: If-None-Match
        required: false
        schema:
          type: string
        style: simple
      - description: |-
          Contains the "requested acknowledgements" for this modifying request as comma separated list. The HTTP call will
          block until all requested acknowledgements were aggregated or will time out based on the specified `timeout`
          parameter.

          The default (if omitted) requested acks is `requested-acks=twin-persisted` which will block the
          HTTP call until the change was persited to the twin.
        explode: true
        in: query
        name: requested-acks
        required: false
        schema:
          type: string
        style: form
      - description: |-
          Defines how long the backend should wait for completion of the request, e.g. applied when waiting for requested
          acknowledgements via the `requested-acks` param. Can be specified without unit (then seconds are assumed) or
          together with `s`, `ms` or `m` unit. Example: `42s`, `1m`.

          The default (if omitted) timeout is `10s`. Maximum value: `60s`.

          A value of `0` applies fire and forget semantics for the command resulting in setting `response-required=false`.
        explode: true
        in: query
        name: timeout
        required: false
        schema:
          type: string
        style: form
      - description: |-
          Defines whether a response is required to the API call or not - if set to `false` the response will directly
          sent back with a status code of `202` (Accepted).

          The default (if ommited) response is `true`.
        explode: true
        in: query
        name: response-required
        required: false
        schema:
          type: boolean
        style: form
      responses:
        "204":
          description: The attribute was successfully deleted.
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. Possible reasons:
              * the `thingId` does not conform to the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to missing authentication.
        "402":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to exceeded transaction
            count.
        "403":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. Possible reasons:
              * the API Token is missing or invalid
              * the caller has insufficient permissions.
                For deleting a single attribute of an existing thing, `WRITE` permission is required.
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. The thing with the given ID or
            the attribute at the specified path was not found.
        "412":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            A precondition for reading or writing the (sub-)resource failed. This will happen for write requests, if you
            specified an If-Match or If-None-Match header, which fails the precondition check against the current ETag of
            the (sub-)resource. For read requests, this error may only happen for a failing If-Match header. In case of a
            failing If-None-Match header for a read request, status 304 will be returned instead.
          headers:
            ETag:
              description: |-
                The (current server-side) ETag for this (sub-)resource. For top-level resources it is in the format
                "rev:[revision]", for sub-resources it has the format "hash:[calculated-hash]".
              explode: false
              schema:
                type: string
              style: simple
      summary: Delete a specific attribute of a specific thing
      tags:
      - Things
    get:
      description: |-
        Returns a specific attribute of the thing identified by the `thingId`
        path parameter.

        The attribute (JSON) can be referenced hierarchically, by
        applying JSON Pointer notation (RFC-6901).

        Example:
        In order to retrieve the `name` field of an `manufacturer` attribute,
        the full path would be
        `/things/{thingId}/attributes/manufacturer/name`
      parameters:
      - description: |-
          The ID of a thing needs to follow the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).

          The namespace needs to be registered for your solution
        explode: false
        in: path
        name: thingId
        required: true
        schema:
          type: string
        style: simple
      - description: The path to the attribute, e.g. **manufacturer/name**
        explode: false
        in: path
        name: attributePath
        required: true
        schema:
          type: string
        style: simple
      - description: |-
          The `If-Match` header which has to conform to RFC-7232 (Conditional Requests). Common usages are:
            * optimistic locking by specifying the `ETag` from a previous HTTP response, e.g. `If-Match: "hash:a75ece4e"`
            * retrieving or modifying a resource only if it already exists, e.g. `If-Match: *`
        explode: false
        in: header
        name: If-Match
        required: false
        schema:
          type: string
        style: simple
      - description: 'The `If-None-Match` header, which has to conform to RFC-7232
          (Conditional Requests). A common usage scenario is to modify a resource
          only if it does not yet exist, thus to create it, by specifying `If-None-Match:
          *`.'
        explode: false
        in: header
        name: If-None-Match
        required: false
        schema:
          type: string
        style: simple
      - description: |-
          Defines how long the backend should wait for completion of the request, e.g. applied when waiting for requested
          acknowledgements via the `requested-acks` param. Can be specified without unit (then seconds are assumed) or
          together with `s`, `ms` or `m` unit. Example: `42s`, `1m`.

          The default (if omitted) timeout is `10s`. Maximum value: `60s`.

          A value of `0` applies fire and forget semantics for the command resulting in setting `response-required=false`.
        explode: true
        in: query
        name: timeout
        required: false
        schema:
          type: string
        style: form
      responses:
        "200":
          description: The attribute was successfully retrieved.
          headers:
            ETag:
              description: |-
                The (current server-side) ETag for this (sub-)resource. For top-level resources it is in the format
                "rev:[revision]", for sub-resources it has the format "hash:[calculated-hash]".
              explode: false
              schema:
                type: string
              style: simple
        "304":
          description: |-
            The (sub-)resource has not been modified. This happens if you specified a If-None-Match header, which
             matches the current ETag of the (sub-)resource.
          headers:
            ETag:
              description: |-
                The (current server-side) ETag for this (sub-)resource. For top-level resources it is in the format
                "rev:[revision]", for sub-resources it has the format "hash:[calculated-hash]".
              explode: false
              schema:
                type: string
              style: simple
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. Possible reasons:
              * the `thingId` does not conform to the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to missing authentication.
        "402":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to exceeded transaction
            count.
        "403":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to a missing or invalid
            API Token.
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. The thing with the given ID or
            the attribute at the specified path was not found.
        "412":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            A precondition for reading or writing the (sub-)resource failed. This will happen for write requests, if you
            specified an If-Match or If-None-Match header, which fails the precondition check against the current ETag of
            the (sub-)resource. For read requests, this error may only happen for a failing If-Match header. In case of a
            failing If-None-Match header for a read request, status 304 will be returned instead.
          headers:
            ETag:
              description: |-
                The (current server-side) ETag for this (sub-)resource. For top-level resources it is in the format
                "rev:[revision]", for sub-resources it has the format "hash:[calculated-hash]".
              explode: false
              schema:
                type: string
              style: simple
      summary: Retrieve a specific attribute of a specific thing
      tags:
      - Things
    put:
      description: |-
        Create or update a specific attribute of the thing identified by the
        `thingId` path parameter.

        * If you specify a new attribute path, this will be created
        * If you specify an existing attribute path, this will be updated

        The attribute (JSON) can be referenced hierarchically, by applying JSON Pointer notation (RFC-6901).

        Example: In order to put the `name` field of an `manufacturer` attribute, the full path would be
        `/things/{thingId}/attributes/manufacturer/name`
      parameters:
      - description: |-
          The ID of a thing needs to follow the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).

          The namespace needs to be registered for your solution
        explode: false
        in: path
        name: thingId
        required: true
        schema:
          type: string
        style: simple
      - description: The path to the attribute, e.g. **manufacturer/name**
        explode: false
        in: path
        name: attributePath
        required: true
        schema:
          type: string
        style: simple
      - description: |-
          The `If-Match` header which has to conform to RFC-7232 (Conditional Requests). Common usages are:
            * optimistic locking by specifying the `ETag` from a previous HTTP response, e.g. `If-Match: "hash:a75ece4e"`
            * retrieving or modifying a resource only if it already exists, e.g. `If-Match: *`
        explode: false
        in: header
        name: If-Match
        required: false
        schema:
          type: string
        style: simple
      - description: 'The `If-None-Match` header, which has to conform to RFC-7232
          (Conditional Requests). A common usage scenario is to modify a resource
          only if it does not yet exist, thus to create it, by specifying `If-None-Match:
          *`.'
        explode: false
        in: header
        name: If-None-Match
        required: false
        schema:
          type: string
        style: simple
      - description: |-
          Contains the "requested acknowledgements" for this modifying request as comma separated list. The HTTP call will
          block until all requested acknowledgements were aggregated or will time out based on the specified `timeout`
          parameter.

          The default (if omitted) requested acks is `requested-acks=twin-persisted` which will block the
          HTTP call until the change was persited to the twin.
        explode: true
        in: query
        name: requested-acks
        required: false
        schema:
          type: string
        style: form
      - description: |-
          Defines how long the backend should wait for completion of the request, e.g. applied when waiting for requested
          acknowledgements via the `requested-acks` param. Can be specified without unit (then seconds are assumed) or
          together with `s`, `ms` or `m` unit. Example: `42s`, `1m`.

          The default (if omitted) timeout is `10s`. Maximum value: `60s`.

          A value of `0` applies fire and forget semantics for the command resulting in setting `response-required=false`.
        explode: true
        in: query
        name: timeout
        required: false
        schema:
          type: string
        style: form
      - description: |-
          Defines whether a response is required to the API call or not - if set to `false` the response will directly
          sent back with a status code of `202` (Accepted).

          The default (if ommited) response is `true`.
        explode: true
        in: query
        name: response-required
        required: false
        schema:
          type: boolean
        style: form
      requestBody:
        $ref: '#/components/requestBodies/Value'
      responses:
        "201":
          description: The attribute was successfully created.
          headers:
            ETag:
              description: |-
                The (current server-side) ETag for this (sub-)resource. For top-level resources it is in the format
                "rev:[revision]", for sub-resources it has the format "hash:[calculated-hash]".
              explode: false
              schema:
                type: string
              style: simple
            Location:
              description: The location of the created attribute resource
              explode: false
              schema:
                type: string
              style: simple
        "204":
          description: The attribute was successfully modified.
          headers:
            ETag:
              description: |-
                The (current server-side) ETag for this (sub-)resource. For top-level resources it is in the format
                "rev:[revision]", for sub-resources it has the format "hash:[calculated-hash]".
              explode: false
              schema:
                type: string
              style: simple
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. Possible reasons:
              * the `thingId` does not conform to the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to missing authentication.
        "402":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to exceeded data volume
            or exceeded transaction count.
        "403":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. Possible reasons:
              * the API Token is missing or invalid
              * the caller has insufficient permissions.
                For modifying an attribute of an existing thing, `WRITE` permission is required.
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. The thing with the given ID was
            not found.
        "412":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            A precondition for reading or writing the (sub-)resource failed. This will happen for write requests, if you
            specified an If-Match or If-None-Match header, which fails the precondition check against the current ETag of
            the (sub-)resource. For read requests, this error may only happen for a failing If-Match header. In case of a
            failing If-None-Match header for a read request, status 304 will be returned instead.
          headers:
            ETag:
              description: |-
                The (current server-side) ETag for this (sub-)resource. For top-level resources it is in the format
                "rev:[revision]", for sub-resources it has the format "hash:[calculated-hash]".
              explode: false
              schema:
                type: string
              style: simple
        "413":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The created or modified entity is larger than the accepted
            limit of 100 kB.
      summary: Create or update a specific attribute of a specific thing
      tags:
      - Things
  /things/{thingId}/features:
    delete:
      description: |-
        Deletes all features of the thing identified by the `thingId` path
        parameter.
      parameters:
      - description: |-
          The ID of a thing needs to follow the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).

          The namespace needs to be registered for your solution
        explode: false
        in: path
        name: thingId
        required: true
        schema:
          type: string
        style: simple
      - description: |-
          The `If-Match` header which has to conform to RFC-7232 (Conditional Requests). Common usages are:
            * optimistic locking by specifying the `ETag` from a previous HTTP response, e.g. `If-Match: "hash:a75ece4e"`
            * retrieving or modifying a resource only if it already exists, e.g. `If-Match: *`
        explode: false
        in: header
        name: If-Match
        required: false
        schema:
          type: string
        style: simple
      - description: 'The `If-None-Match` header, which has to conform to RFC-7232
          (Conditional Requests). A common usage scenario is to modify a resource
          only if it does not yet exist, thus to create it, by specifying `If-None-Match:
          *`.'
        explode: false
        in: header
        name: If-None-Match
        required: false
        schema:
          type: string
        style: simple
      - description: |-
          Contains the "requested acknowledgements" for this modifying request as comma separated list. The HTTP call will
          block until all requested acknowledgements were aggregated or will time out based on the specified `timeout`
          parameter.

          The default (if omitted) requested acks is `requested-acks=twin-persisted` which will block the
          HTTP call until the change was persited to the twin.
        explode: true
        in: query
        name: requested-acks
        required: false
        schema:
          type: string
        style: form
      - description: |-
          Defines how long the backend should wait for completion of the request, e.g. applied when waiting for requested
          acknowledgements via the `requested-acks` param. Can be specified without unit (then seconds are assumed) or
          together with `s`, `ms` or `m` unit. Example: `42s`, `1m`.

          The default (if omitted) timeout is `10s`. Maximum value: `60s`.

          A value of `0` applies fire and forget semantics for the command resulting in setting `response-required=false`.
        explode: true
        in: query
        name: timeout
        required: false
        schema:
          type: string
        style: form
      - description: |-
          Defines whether a response is required to the API call or not - if set to `false` the response will directly
          sent back with a status code of `202` (Accepted).

          The default (if ommited) response is `true`.
        explode: true
        in: query
        name: response-required
        required: false
        schema:
          type: boolean
        style: form
      responses:
        "204":
          description: The features were successfully deleted.
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. Possible reasons:
              * the `thingId` does not conform to the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to missing authentication.
        "402":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to exceeded transaction
            count.
        "403":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. Possible reasons:
              * the API Token is missing or invalid
              * the caller has insufficient permissions.
                For deleting all features of an existing thing, `WRITE` permission is required.
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. The thing with the given ID was
            not found or the features have not been defined.
        "412":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            A precondition for reading or writing the (sub-)resource failed. This will happen for write requests, if you
            specified an If-Match or If-None-Match header, which fails the precondition check against the current ETag of
            the (sub-)resource. For read requests, this error may only happen for a failing If-Match header. In case of a
            failing If-None-Match header for a read request, status 304 will be returned instead.
          headers:
            ETag:
              description: |-
                The (current server-side) ETag for this (sub-)resource. For top-level resources it is in the format
                "rev:[revision]", for sub-resources it has the format "hash:[calculated-hash]".
              explode: false
              schema:
                type: string
              style: simple
      summary: Delete all features of a specific thing
      tags:
      - Features
    get:
      description: |-
        Returns all features of the thing identified by the `thingId` path
        parameter.
      parameters:
      - description: |-
          The ID of a thing needs to follow the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).

          The namespace needs to be registered for your solution
        explode: false
        in: path
        name: thingId
        required: true
        schema:
          type: string
        style: simple
      - description: |-
          Contains a comma-separated list of fields from one or more features to be
          included in the returned JSON.

          #### Selectable fields

          * `{featureId}` The ID of the feature to select properties in
            * `properties`
              Supports selecting arbitrary sub-fields by using a comma-separated list:
                * several properties paths can be passed as a comma-separated list of JSON pointers (RFC-6901)
                  For example:
                    * `?fields={featureId}/properties/color` would select only `color` property value (if present) of the feature identified with `{featureId}`
                    * `?fields={featureId}/properties/color,properties/brightness` would select only `color` and `brightness` property values (if present) of the feature identified with `{featureId}`
              Supports selecting arbitrary sub-fields of objects by wrapping sub-fields inside parentheses `( )`:
                * a comma-separated list of sub-fields (a sub-field is a JSON pointer (RFC-6901) separated with `/`) to select
                * sub-selectors can be used to request only specific sub-fields by placing expressions in parentheses `( )` after a selected subfield
                  For example:
                   * `?fields={featureId}/properties(color,brightness)` would select only `color` and `brightness` property values (if present) of the feature identified with `{featureId}`
                   * `?fields={featureId}/properties(location/longitude)` would select the `longitude` value inside the `location` object of the feature identified with `{featureId}`


          #### Examples
          * `?fields=EnvironmentScanner/properties(temperature,humidity)`
          * `?fields=EnvironmentScanner/properties(temperature,humidity),Vehicle/properties/configuration`
        explode: true
        in: query
        name: fields
        required: false
        schema:
          type: string
        style: form
      - description: |-
          The `If-Match` header which has to conform to RFC-7232 (Conditional Requests). Common usages are:
            * optimistic locking by specifying the `ETag` from a previous HTTP response, e.g. `If-Match: "hash:a75ece4e"`
            * retrieving or modifying a resource only if it already exists, e.g. `If-Match: *`
        explode: false
        in: header
        name: If-Match
        required: false
        schema:
          type: string
        style: simple
      - description: 'The `If-None-Match` header, which has to conform to RFC-7232
          (Conditional Requests). A common usage scenario is to modify a resource
          only if it does not yet exist, thus to create it, by specifying `If-None-Match:
          *`.'
        explode: false
        in: header
        name: If-None-Match
        required: false
        schema:
          type: string
        style: simple
      - description: |-
          Defines how long the backend should wait for completion of the request, e.g. applied when waiting for requested
          acknowledgements via the `requested-acks` param. Can be specified without unit (then seconds are assumed) or
          together with `s`, `ms` or `m` unit. Example: `42s`, `1m`.

          The default (if omitted) timeout is `10s`. Maximum value: `60s`.

          A value of `0` applies fire and forget semantics for the command resulting in setting `response-required=false`.
        explode: true
        in: query
        name: timeout
        required: false
        schema:
          type: string
        style: form
      responses:
        "200":
          content:
            application/json:
              example:
                featureId1:
                  definition:
                  - namespace:definition1:v1.0
                  properties:
                    property1: value1
                featureId2:
                  definition:
                  - namespace:definition2:v1.0
                  properties:
                    property2: value2
              schema:
                $ref: '#/components/schemas/Features'
          description: |-
            The list of features of the specific thing were successfully
            retrieved.
          headers:
            ETag:
              description: |-
                The (current server-side) ETag for this (sub-)resource. For top-level resources it is in the format
                "rev:[revision]", for sub-resources it has the format "hash:[calculated-hash]".
              explode: false
              schema:
                type: string
              style: simple
        "304":
          description: |-
            The (sub-)resource has not been modified. This happens if you specified a If-None-Match header, which
             matches the current ETag of the (sub-)resource.
          headers:
            ETag:
              description: |-
                The (current server-side) ETag for this (sub-)resource. For top-level resources it is in the format
                "rev:[revision]", for sub-resources it has the format "hash:[calculated-hash]".
              explode: false
              schema:
                type: string
              style: simple
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. Possible reasons:
              * the `thingId` does not conform to the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).
              * at least one of the defined query parameters is invalid.
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to missing authentication.
        "402":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to exceeded data volume
            or exceeded transaction count.
        "403":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to a missing or invalid
            API Token.
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. The thing with the given ID was
            not found or the features have not been defined.
        "412":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            A precondition for reading or writing the (sub-)resource failed. This will happen for write requests, if you
            specified an If-Match or If-None-Match header, which fails the precondition check against the current ETag of
            the (sub-)resource. For read requests, this error may only happen for a failing If-Match header. In case of a
            failing If-None-Match header for a read request, status 304 will be returned instead.
          headers:
            ETag:
              description: |-
                The (current server-side) ETag for this (sub-)resource. For top-level resources it is in the format
                "rev:[revision]", for sub-resources it has the format "hash:[calculated-hash]".
              explode: false
              schema:
                type: string
              style: simple
      summary: List all features of a specific thing
      tags:
      - Features
    put:
      description: |-
        Create or modify all features of a thing identified by the `thingId`
        path parameter.
        ### Create all features at once
        In case at the initial creation of your thing you have not specified any features, these can be created here.

        ### Update all features at once
        To update all features at once prepare the JSON body accordingly.

        Note: In contrast to the "PUT thing" request, a partial update is not supported here,
        but the content will be **overwritten**.
        If you need to update single features or their paths, please use the sub-resources instead.

        Example:

        ```
        {
             "coffee-brewer": {
               "definition": ["com.acme:coffeebrewer:0.1.0"],
               "properties": {
                 "brewed-coffees": 0
               }
             },
             "water-tank": {
               "properties": {
                 "configuration": {
                   "smartMode": true,
                   "brewingTemp": 87,
                   "tempToHold": 44,
                   "timeoutSeconds": 6000
                 },
                 "status": {
                   "waterAmount": 731,
                   "temperature": 44
                 }
               }
             }
        }
        ```
      parameters:
      - description: |-
          The ID of a thing needs to follow the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).

          The namespace needs to be registered for your solution
        explode: false
        in: path
        name: thingId
        required: true
        schema:
          type: string
        style: simple
      - description: |-
          The `If-Match` header which has to conform to RFC-7232 (Conditional Requests). Common usages are:
            * optimistic locking by specifying the `ETag` from a previous HTTP response, e.g. `If-Match: "hash:a75ece4e"`
            * retrieving or modifying a resource only if it already exists, e.g. `If-Match: *`
        explode: false
        in: header
        name: If-Match
        required: false
        schema:
          type: string
        style: simple
      - description: 'The `If-None-Match` header, which has to conform to RFC-7232
          (Conditional Requests). A common usage scenario is to modify a resource
          only if it does not yet exist, thus to create it, by specifying `If-None-Match:
          *`.'
        explode: false
        in: header
        name: If-None-Match
        required: false
        schema:
          type: string
        style: simple
      - description: |-
          Contains the "requested acknowledgements" for this modifying request as comma separated list. The HTTP call will
          block until all requested acknowledgements were aggregated or will time out based on the specified `timeout`
          parameter.

          The default (if omitted) requested acks is `requested-acks=twin-persisted` which will block the
          HTTP call until the change was persited to the twin.
        explode: true
        in: query
        name: requested-acks
        required: false
        schema:
          type: string
        style: form
      - description: |-
          Defines how long the backend should wait for completion of the request, e.g. applied when waiting for requested
          acknowledgements via the `requested-acks` param. Can be specified without unit (then seconds are assumed) or
          together with `s`, `ms` or `m` unit. Example: `42s`, `1m`.

          The default (if omitted) timeout is `10s`. Maximum value: `60s`.

          A value of `0` applies fire and forget semantics for the command resulting in setting `response-required=false`.
        explode: true
        in: query
        name: timeout
        required: false
        schema:
          type: string
        style: form
      - description: |-
          Defines whether a response is required to the API call or not - if set to `false` the response will directly
          sent back with a status code of `202` (Accepted).

          The default (if ommited) response is `true`.
        explode: true
        in: query
        name: response-required
        required: false
        schema:
          type: boolean
        style: form
      requestBody:
        content:
          application/json:
            example:
              coffee-brewer:
                properties:
                  definition:
                  - com.acme:coffeebrewer:0.1.0
                  brewed-coffees: 0
              water-tank:
                properties:
                  configuration:
                    smartMode: true
                    brewingTemp: 87
                    tempToHold: 44
                    timeoutSeconds: 6000
                  status:
                    waterAmount: 731
                    temperature: 44
            schema:
              $ref: '#/components/schemas/Features'
        description: |-
          JSON object of all features to be modified at once. Consider that the value has to be a JSON object or null.

          Examples:
          * an empty object: {} - would just delete all old features
          * an empty feature: { "featureId": {} } - We strongly recommend to use a restricted set of characters
            for the `featureId`, as it might be needed for the (URL) path later.

            Currently these identifiers should follow the pattern: [_a-zA-Z][_a-zA-Z0-9-]*

          * a nested object with multiple features as shown in the example value field
        required: true
      responses:
        "201":
          content:
            application/json:
              example: {}
              schema:
                $ref: '#/components/schemas/Features'
          description: The features were successfully created.
          headers:
            ETag:
              description: |-
                The (current server-side) ETag for this (sub-)resource. For top-level resources it is in the format
                "rev:[revision]", for sub-resources it has the format "hash:[calculated-hash]".
              explode: false
              schema:
                type: string
              style: simple
            Location:
              description: The location of the created features resource
              explode: false
              schema:
                type: string
              style: simple
        "204":
          description: The features were successfully modified.
          headers:
            ETag:
              description: |-
                The (current server-side) ETag for this (sub-)resource. For top-level resources it is in the format
                "rev:[revision]", for sub-resources it has the format "hash:[calculated-hash]".
              explode: false
              schema:
                type: string
              style: simple
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. Possible reasons:
              * the `thingId` does not conform to the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).
              * the JSON body of the feature to be created/modified is invalid
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to missing authentication.
        "402":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to exceeded data volume
            or exceeded transaction count.
        "403":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. Possible reasons:

              * the API Token is missing or invalid
              * the caller has insufficient permissions.
                For modifying all features of an existing thing, `WRITE` permission is required.
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. The thing with the given ID was
            not found.
        "412":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            A precondition for reading or writing the (sub-)resource failed. This will happen for write requests, if you
            specified an If-Match or If-None-Match header, which fails the precondition check against the current ETag of
            the (sub-)resource. For read requests, this error may only happen for a failing If-Match header. In case of a
            failing If-None-Match header for a read request, status 304 will be returned instead.
          headers:
            ETag:
              description: |-
                The (current server-side) ETag for this (sub-)resource. For top-level resources it is in the format
                "rev:[revision]", for sub-resources it has the format "hash:[calculated-hash]".
              explode: false
              schema:
                type: string
              style: simple
        "413":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The created or modified entity is larger than the accepted
            limit of 100 kB.
      summary: Create or modify all features of a specific thing at once
      tags:
      - Features
  /things/{thingId}/features/{featureId}:
    delete:
      description: |-
        Deletes a specific feature identified by the `featureId` path parameter
        of the thing identified by the `thingId` path parameter.
      parameters:
      - description: |-
          The ID of a thing needs to follow the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).

          The namespace needs to be registered for your solution
        explode: false
        in: path
        name: thingId
        required: true
        schema:
          type: string
        style: simple
      - description: The ID of the feature - has to conform to RFC-3986 (URI)
        explode: false
        in: path
        name: featureId
        required: true
        schema:
          type: string
        style: simple
      - description: |-
          The `If-Match` header which has to conform to RFC-7232 (Conditional Requests). Common usages are:
            * optimistic locking by specifying the `ETag` from a previous HTTP response, e.g. `If-Match: "hash:a75ece4e"`
            * retrieving or modifying a resource only if it already exists, e.g. `If-Match: *`
        explode: false
        in: header
        name: If-Match
        required: false
        schema:
          type: string
        style: simple
      - description: 'The `If-None-Match` header, which has to conform to RFC-7232
          (Conditional Requests). A common usage scenario is to modify a resource
          only if it does not yet exist, thus to create it, by specifying `If-None-Match:
          *`.'
        explode: false
        in: header
        name: If-None-Match
        required: false
        schema:
          type: string
        style: simple
      - description: |-
          Contains the "requested acknowledgements" for this modifying request as comma separated list. The HTTP call will
          block until all requested acknowledgements were aggregated or will time out based on the specified `timeout`
          parameter.

          The default (if omitted) requested acks is `requested-acks=twin-persisted` which will block the
          HTTP call until the change was persited to the twin.
        explode: true
        in: query
        name: requested-acks
        required: false
        schema:
          type: string
        style: form
      - description: |-
          Defines how long the backend should wait for completion of the request, e.g. applied when waiting for requested
          acknowledgements via the `requested-acks` param. Can be specified without unit (then seconds are assumed) or
          together with `s`, `ms` or `m` unit. Example: `42s`, `1m`.

          The default (if omitted) timeout is `10s`. Maximum value: `60s`.

          A value of `0` applies fire and forget semantics for the command resulting in setting `response-required=false`.
        explode: true
        in: query
        name: timeout
        required: false
        schema:
          type: string
        style: form
      - description: |-
          Defines whether a response is required to the API call or not - if set to `false` the response will directly
          sent back with a status code of `202` (Accepted).

          The default (if ommited) response is `true`.
        explode: true
        in: query
        name: response-required
        required: false
        schema:
          type: boolean
        style: form
      responses:
        "204":
          description: The feature was successfully deleted.
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. Possible reasons:
              * the `thingId` does not conform to the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to missing authentication.
        "402":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to exceeded transaction
            count.
        "403":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. Possible reasons:

              * the API Token is missing or invalid
              * the caller has insufficient permissions.
                For deleting a single feature of an existing thing, `WRITE` permission is required.
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. The thing with the given ID or
            the feature at the specified path was not found.
        "412":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            A precondition for reading or writing the (sub-)resource failed. This will happen for write requests, if you
            specified an If-Match or If-None-Match header, which fails the precondition check against the current ETag of
            the (sub-)resource. For read requests, this error may only happen for a failing If-Match header. In case of a
            failing If-None-Match header for a read request, status 304 will be returned instead.
          headers:
            ETag:
              description: |-
                The (current server-side) ETag for this (sub-)resource. For top-level resources it is in the format
                "rev:[revision]", for sub-resources it has the format "hash:[calculated-hash]".
              explode: false
              schema:
                type: string
              style: simple
      summary: Delete a specific feature of a specific thing
      tags:
      - Features
    get:
      description: |-
        Returns a specific feature identified by the `featureId` path parameter
        of the thing identified by the `thingId` path parameter.
      parameters:
      - description: |-
          The ID of a thing needs to follow the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).

          The namespace needs to be registered for your solution
        explode: false
        in: path
        name: thingId
        required: true
        schema:
          type: string
        style: simple
      - description: The ID of the feature - has to conform to RFC-3986 (URI)
        explode: false
        in: path
        name: featureId
        required: true
        schema:
          type: string
        style: simple
      - description: |-
          Contains a comma-separated list of fields from the selected feature to be
          included in the returned JSON.

          #### Selectable fields

          * `properties`

            Supports selecting arbitrary sub-fields by using a comma-separated list:
              * several properties paths can be passed as a comma-separated list of JSON pointers (RFC-6901)

                For example:
                  * `?fields=properties/color` would select only `color` property value (if present)
                  * `?fields=properties/color,properties/brightness` would select only `color` and `brightness` property values (if present)

            Supports selecting arbitrary sub-fields of objects by wrapping sub-fields inside parentheses `( )`:
              * a comma-separated list of sub-fields (a sub-field is a JSON pointer (RFC-6901) separated with `/`) to select
              * sub-selectors can be used to request only specific sub-fields by placing expressions in parentheses `( )` after a selected subfield

                For example:
                 * `?fields=properties(color,brightness)` would select only `color` and `brightness` property values (if present)
                 * `?fields=properties(location/longitude)` would select the `longitude` value inside the `location` object

          #### Examples

          * `?fields=properties(color,brightness)`
        explode: true
        in: query
        name: fields
        required: false
        schema:
          type: string
        style: form
      - description: |-
          The `If-Match` header which has to conform to RFC-7232 (Conditional Requests). Common usages are:
            * optimistic locking by specifying the `ETag` from a previous HTTP response, e.g. `If-Match: "hash:a75ece4e"`
            * retrieving or modifying a resource only if it already exists, e.g. `If-Match: *`
        explode: false
        in: header
        name: If-Match
        required: false
        schema:
          type: string
        style: simple
      - description: 'The `If-None-Match` header, which has to conform to RFC-7232
          (Conditional Requests). A common usage scenario is to modify a resource
          only if it does not yet exist, thus to create it, by specifying `If-None-Match:
          *`.'
        explode: false
        in: header
        name: If-None-Match
        required: false
        schema:
          type: string
        style: simple
      - description: |-
          Defines how long the backend should wait for completion of the request, e.g. applied when waiting for requested
          acknowledgements via the `requested-acks` param. Can be specified without unit (then seconds are assumed) or
          together with `s`, `ms` or `m` unit. Example: `42s`, `1m`.

          The default (if omitted) timeout is `10s`. Maximum value: `60s`.

          A value of `0` applies fire and forget semantics for the command resulting in setting `response-required=false`.
        explode: true
        in: query
        name: timeout
        required: false
        schema:
          type: string
        style: form
      responses:
        "200":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Feature'
          description: The feature was successfully retrieved.
          headers:
            ETag:
              description: |-
                The (current server-side) ETag for this (sub-)resource. For top-level resources it is in the format
                "rev:[revision]", for sub-resources it has the format "hash:[calculated-hash]".
              explode: false
              schema:
                type: string
              style: simple
        "304":
          description: |-
            The (sub-)resource has not been modified. This happens if you specified a If-None-Match header, which
             matches the current ETag of the (sub-)resource.
          headers:
            ETag:
              description: |-
                The (current server-side) ETag for this (sub-)resource. For top-level resources it is in the format
                "rev:[revision]", for sub-resources it has the format "hash:[calculated-hash]".
              explode: false
              schema:
                type: string
              style: simple
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. Possible reasons:
              * the `thingId` does not conform to the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).
              * at least one of the defined query parameters is invalid.
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to missing authentication.
        "402":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to exceeded transaction
            count.
        "403":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to a missing or invalid
            API Token.
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. The thing with the given ID or
            the feature with the specified `featureId` was not found.
        "412":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            A precondition for reading or writing the (sub-)resource failed. This will happen for write requests, if you
            specified an If-Match or If-None-Match header, which fails the precondition check against the current ETag of
            the (sub-)resource. For read requests, this error may only happen for a failing If-Match header. In case of a
            failing If-None-Match header for a read request, status 304 will be returned instead.
          headers:
            ETag:
              description: |-
                The (current server-side) ETag for this (sub-)resource. For top-level resources it is in the format
                "rev:[revision]", for sub-resources it has the format "hash:[calculated-hash]".
              explode: false
              schema:
                type: string
              style: simple
      summary: Retrieve a specific feature of a specific thing
      tags:
      - Features
    put:
      description: |-
        Create or modify a specific feature identified by the `featureId` path
        parameter of the thing identified by the `thingId` path parameter.

        ### Create feature
        If the feature ID is new, the feature and all content from the JSON body will be created

        ### Update feature
        If the feature ID is used already in this thing, the feature will be overwrittern
        with the content from the JSON body.

        Example: Set the `featureId` to **coffee-brewer** and all properties in the body part.

        ```
        {
          "definition": ["com.acme:coffeebrewer:0.1.0"],
          "properties": {
            "brewed-coffees": 42
          }
        }
        ```
      parameters:
      - description: |-
          The ID of a thing needs to follow the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).

          The namespace needs to be registered for your solution
        explode: false
        in: path
        name: thingId
        required: true
        schema:
          type: string
        style: simple
      - description: The ID of the feature - has to conform to RFC-3986 (URI)
        explode: false
        in: path
        name: featureId
        required: true
        schema:
          type: string
        style: simple
      - description: |-
          The `If-Match` header which has to conform to RFC-7232 (Conditional Requests). Common usages are:
            * optimistic locking by specifying the `ETag` from a previous HTTP response, e.g. `If-Match: "hash:a75ece4e"`
            * retrieving or modifying a resource only if it already exists, e.g. `If-Match: *`
        explode: false
        in: header
        name: If-Match
        required: false
        schema:
          type: string
        style: simple
      - description: 'The `If-None-Match` header, which has to conform to RFC-7232
          (Conditional Requests). A common usage scenario is to modify a resource
          only if it does not yet exist, thus to create it, by specifying `If-None-Match:
          *`.'
        explode: false
        in: header
        name: If-None-Match
        required: false
        schema:
          type: string
        style: simple
      - description: |-
          Contains the "requested acknowledgements" for this modifying request as comma separated list. The HTTP call will
          block until all requested acknowledgements were aggregated or will time out based on the specified `timeout`
          parameter.

          The default (if omitted) requested acks is `requested-acks=twin-persisted` which will block the
          HTTP call until the change was persited to the twin.
        explode: true
        in: query
        name: requested-acks
        required: false
        schema:
          type: string
        style: form
      - description: |-
          Defines how long the backend should wait for completion of the request, e.g. applied when waiting for requested
          acknowledgements via the `requested-acks` param. Can be specified without unit (then seconds are assumed) or
          together with `s`, `ms` or `m` unit. Example: `42s`, `1m`.

          The default (if omitted) timeout is `10s`. Maximum value: `60s`.

          A value of `0` applies fire and forget semantics for the command resulting in setting `response-required=false`.
        explode: true
        in: query
        name: timeout
        required: false
        schema:
          type: string
        style: form
      - description: |-
          Defines whether a response is required to the API call or not - if set to `false` the response will directly
          sent back with a status code of `202` (Accepted).

          The default (if ommited) response is `true`.
        explode: true
        in: query
        name: response-required
        required: false
        schema:
          type: boolean
        style: form
      requestBody:
        content:
          application/json:
            example:
              definition:
              - com.acme:coffeemaker:0.1.0
              - com.acme:coffeemaker:1.1.0
              properties:
                connected: true
                brewed-coffees: 0
            schema:
              $ref: '#/components/schemas/Feature'
        description: |-
          JSON representation of the feature to be created/modified.
          Consider that the value has to be a JSON object or null.

          Examples:
          * an empty object: {} - would just create the featureID but would delete all content of the feature
          * a nested object with multiple model definitions and multiple properties as shown in the example value field
        required: true
      responses:
        "201":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Feature'
          description: The feature was successfully created.
          headers:
            ETag:
              description: |-
                The (current server-side) ETag for this (sub-)resource. For top-level resources it is in the format
                "rev:[revision]", for sub-resources it has the format "hash:[calculated-hash]".
              explode: false
              schema:
                type: string
              style: simple
            Location:
              description: The location of the created feature resource
              explode: false
              schema:
                type: string
              style: simple
        "204":
          description: The feature was successfully modified.
          headers:
            ETag:
              description: |-
                The (current server-side) ETag for this (sub-)resource. For top-level resources it is in the format
                "rev:[revision]", for sub-resources it has the format "hash:[calculated-hash]".
              explode: false
              schema:
                type: string
              style: simple
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. Possible reasons:
              * the `thingId` does not conform to the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).
              * the JSON body of the feature to be created/modified is invalid
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to missing authentication.
        "402":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to exceeded data volume
            or exceeded transaction count.
        "403":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. Possible reasons:

              * the API Token is missing or invalid
              * the caller has insufficient permissions.
                For modifying a single feature of an existing thing, `WRITE` permission is required.
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. The thing with the given ID was
            not found.
        "412":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            A precondition for reading or writing the (sub-)resource failed. This will happen for write requests, if you
            specified an If-Match or If-None-Match header, which fails the precondition check against the current ETag of
            the (sub-)resource. For read requests, this error may only happen for a failing If-Match header. In case of a
            failing If-None-Match header for a read request, status 304 will be returned instead.
          headers:
            ETag:
              description: |-
                The (current server-side) ETag for this (sub-)resource. For top-level resources it is in the format
                "rev:[revision]", for sub-resources it has the format "hash:[calculated-hash]".
              explode: false
              schema:
                type: string
              style: simple
        "413":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The created or modified entity is larger than the accepted
            limit of 100 kB.
      summary: Create or modify a specific feature of a specific thing
      tags:
      - Features
  /things/{thingId}/features/{featureId}/definition:
    delete:
      description: |-
        Deletes the complete definition of the feature identified by the `thingId` and
        `featureId` path parameter.
      parameters:
      - description: |-
          The ID of a thing needs to follow the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).

          The namespace needs to be registered for your solution
        explode: false
        in: path
        name: thingId
        required: true
        schema:
          type: string
        style: simple
      - description: The ID of the feature - has to conform to RFC-3986 (URI)
        explode: false
        in: path
        name: featureId
        required: true
        schema:
          type: string
        style: simple
      - description: |-
          The `If-Match` header which has to conform to RFC-7232 (Conditional Requests). Common usages are:
            * optimistic locking by specifying the `ETag` from a previous HTTP response, e.g. `If-Match: "hash:a75ece4e"`
            * retrieving or modifying a resource only if it already exists, e.g. `If-Match: *`
        explode: false
        in: header
        name: If-Match
        required: false
        schema:
          type: string
        style: simple
      - description: 'The `If-None-Match` header, which has to conform to RFC-7232
          (Conditional Requests). A common usage scenario is to modify a resource
          only if it does not yet exist, thus to create it, by specifying `If-None-Match:
          *`.'
        explode: false
        in: header
        name: If-None-Match
        required: false
        schema:
          type: string
        style: simple
      - description: |-
          Contains the "requested acknowledgements" for this modifying request as comma separated list. The HTTP call will
          block until all requested acknowledgements were aggregated or will time out based on the specified `timeout`
          parameter.

          The default (if omitted) requested acks is `requested-acks=twin-persisted` which will block the
          HTTP call until the change was persited to the twin.
        explode: true
        in: query
        name: requested-acks
        required: false
        schema:
          type: string
        style: form
      - description: |-
          Defines how long the backend should wait for completion of the request, e.g. applied when waiting for requested
          acknowledgements via the `requested-acks` param. Can be specified without unit (then seconds are assumed) or
          together with `s`, `ms` or `m` unit. Example: `42s`, `1m`.

          The default (if omitted) timeout is `10s`. Maximum value: `60s`.

          A value of `0` applies fire and forget semantics for the command resulting in setting `response-required=false`.
        explode: true
        in: query
        name: timeout
        required: false
        schema:
          type: string
        style: form
      - description: |-
          Defines whether a response is required to the API call or not - if set to `false` the response will directly
          sent back with a status code of `202` (Accepted).

          The default (if ommited) response is `true`.
        explode: true
        in: query
        name: response-required
        required: false
        schema:
          type: boolean
        style: form
      responses:
        "204":
          description: The definition was successfully deleted.
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. Possible reasons:
              * the `thingId` does not conform to the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to missing authentication.
        "402":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to exceeded transaction
            count.
        "403":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. Possible reasons:

              * the API Token is missing or invalid
              * the caller has insufficient permissions.
                For deleting the definition of an existing feature, `WRITE` permission is required.
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. The specified feature has no
            definition or the thing with the specified `thingId` or the feature
            with `featureId` was not found.
        "412":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            A precondition for reading or writing the (sub-)resource failed. This will happen for write requests, if you
            specified an If-Match or If-None-Match header, which fails the precondition check against the current ETag of
            the (sub-)resource. For read requests, this error may only happen for a failing If-Match header. In case of a
            failing If-None-Match header for a read request, status 304 will be returned instead.
          headers:
            ETag:
              description: |-
                The (current server-side) ETag for this (sub-)resource. For top-level resources it is in the format
                "rev:[revision]", for sub-resources it has the format "hash:[calculated-hash]".
              explode: false
              schema:
                type: string
              style: simple
      summary: Delete the definition of a feature
      tags:
      - Features
    get:
      description: |-
        Returns the complete definition field of the feature identified by the `thingId` and
        `featureId` path parameter.
      parameters:
      - description: |-
          The ID of a thing needs to follow the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).

          The namespace needs to be registered for your solution
        explode: false
        in: path
        name: thingId
        required: true
        schema:
          type: string
        style: simple
      - description: The ID of the feature - has to conform to RFC-3986 (URI)
        explode: false
        in: path
        name: featureId
        required: true
        schema:
          type: string
        style: simple
      - description: |-
          The `If-Match` header which has to conform to RFC-7232 (Conditional Requests). Common usages are:
            * optimistic locking by specifying the `ETag` from a previous HTTP response, e.g. `If-Match: "hash:a75ece4e"`
            * retrieving or modifying a resource only if it already exists, e.g. `If-Match: *`
        explode: false
        in: header
        name: If-Match
        required: false
        schema:
          type: string
        style: simple
      - description: 'The `If-None-Match` header, which has to conform to RFC-7232
          (Conditional Requests). A common usage scenario is to modify a resource
          only if it does not yet exist, thus to create it, by specifying `If-None-Match:
          *`.'
        explode: false
        in: header
        name: If-None-Match
        required: false
        schema:
          type: string
        style: simple
      - description: |-
          Defines how long the backend should wait for completion of the request, e.g. applied when waiting for requested
          acknowledgements via the `requested-acks` param. Can be specified without unit (then seconds are assumed) or
          together with `s`, `ms` or `m` unit. Example: `42s`, `1m`.

          The default (if omitted) timeout is `10s`. Maximum value: `60s`.

          A value of `0` applies fire and forget semantics for the command resulting in setting `response-required=false`.
        explode: true
        in: query
        name: timeout
        required: false
        schema:
          type: string
        style: form
      responses:
        "200":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/FeatureDefinition'
          description: The definition was successfully retrieved.
          headers:
            ETag:
              description: |-
                The (current server-side) ETag for this (sub-)resource. For top-level resources it is in the format
                "rev:[revision]", for sub-resources it has the format "hash:[calculated-hash]".
              explode: false
              schema:
                type: string
              style: simple
        "304":
          description: |-
            The (sub-)resource has not been modified. This happens if you specified a If-None-Match header, which
             matches the current ETag of the (sub-)resource.
          headers:
            ETag:
              description: |-
                The (current server-side) ETag for this (sub-)resource. For top-level resources it is in the format
                "rev:[revision]", for sub-resources it has the format "hash:[calculated-hash]".
              explode: false
              schema:
                type: string
              style: simple
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. Possible reasons:
              * the `thingId` does not conform to the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).
              * at least one of the defined query parameters is invalid.
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to missing authentication.
        "402":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to exceeded transaction
            count.
        "403":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to a missing or invalid
            API Token.
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. The specified feature has no
            definition or the thing with the specified `thingId` or the feature
            with `featureId` was not found.
        "412":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            A precondition for reading or writing the (sub-)resource failed. This will happen for write requests, if you
            specified an If-Match or If-None-Match header, which fails the precondition check against the current ETag of
            the (sub-)resource. For read requests, this error may only happen for a failing If-Match header. In case of a
            failing If-None-Match header for a read request, status 304 will be returned instead.
          headers:
            ETag:
              description: |-
                The (current server-side) ETag for this (sub-)resource. For top-level resources it is in the format
                "rev:[revision]", for sub-resources it has the format "hash:[calculated-hash]".
              explode: false
              schema:
                type: string
              style: simple
      summary: List the definition of a feature
      tags:
      - Features
    put:
      description: |-
        Create or update the complete definition of a feature identified by the `thingId`
        and `featureId` path parameter.

        The definition field will be overwritten with the JSON array set in the request body
      parameters:
      - description: |-
          The ID of a thing needs to follow the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).

          The namespace needs to be registered for your solution
        explode: false
        in: path
        name: thingId
        required: true
        schema:
          type: string
        style: simple
      - description: The ID of the feature - has to conform to RFC-3986 (URI)
        explode: false
        in: path
        name: featureId
        required: true
        schema:
          type: string
        style: simple
      - description: |-
          The `If-Match` header which has to conform to RFC-7232 (Conditional Requests). Common usages are:
            * optimistic locking by specifying the `ETag` from a previous HTTP response, e.g. `If-Match: "hash:a75ece4e"`
            * retrieving or modifying a resource only if it already exists, e.g. `If-Match: *`
        explode: false
        in: header
        name: If-Match
        required: false
        schema:
          type: string
        style: simple
      - description: 'The `If-None-Match` header, which has to conform to RFC-7232
          (Conditional Requests). A common usage scenario is to modify a resource
          only if it does not yet exist, thus to create it, by specifying `If-None-Match:
          *`.'
        explode: false
        in: header
        name: If-None-Match
        required: false
        schema:
          type: string
        style: simple
      - description: |-
          Contains the "requested acknowledgements" for this modifying request as comma separated list. The HTTP call will
          block until all requested acknowledgements were aggregated or will time out based on the specified `timeout`
          parameter.

          The default (if omitted) requested acks is `requested-acks=twin-persisted` which will block the
          HTTP call until the change was persited to the twin.
        explode: true
        in: query
        name: requested-acks
        required: false
        schema:
          type: string
        style: form
      - description: |-
          Defines how long the backend should wait for completion of the request, e.g. applied when waiting for requested
          acknowledgements via the `requested-acks` param. Can be specified without unit (then seconds are assumed) or
          together with `s`, `ms` or `m` unit. Example: `42s`, `1m`.

          The default (if omitted) timeout is `10s`. Maximum value: `60s`.

          A value of `0` applies fire and forget semantics for the command resulting in setting `response-required=false`.
        explode: true
        in: query
        name: timeout
        required: false
        schema:
          type: string
        style: form
      - description: |-
          Defines whether a response is required to the API call or not - if set to `false` the response will directly
          sent back with a status code of `202` (Accepted).

          The default (if ommited) response is `true`.
        explode: true
        in: query
        name: response-required
        required: false
        schema:
          type: boolean
        style: form
      requestBody:
        content:
          application/json:
            example:
            - com.acme:coffeebrewer:0.1.0
            - com.acme:coffeebrewer:1.0.0
            schema:
              $ref: '#/components/schemas/FeatureDefinition'
        description: |-
          JSON array of the complete definition to be updated. Consider that the
          value has to be a JSON array or `null`.

          The content of the JSON array
          are strings in the format `"namespace:name:version"` which is
          enforced.
        required: true
      responses:
        "201":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/FeatureDefinition'
          description: The definition was successfully created.
          headers:
            ETag:
              description: |-
                The (current server-side) ETag for this (sub-)resource. For top-level resources it is in the format
                "rev:[revision]", for sub-resources it has the format "hash:[calculated-hash]".
              explode: false
              schema:
                type: string
              style: simple
            Location:
              description: The location of the created definition resource
              explode: false
              schema:
                type: string
              style: simple
        "204":
          description: The definition was successfully updated.
          headers:
            ETag:
              description: |-
                The (current server-side) ETag for this (sub-)resource. For top-level resources it is in the format
                "rev:[revision]", for sub-resources it has the format "hash:[calculated-hash]".
              explode: false
              schema:
                type: string
              style: simple
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. Possible reasons:
              * the `thingId` does not conform to the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).
              * the JSON body is invalid
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to missing authentication.
        "402":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to exceeded data volume
            or exceeded transaction count.
        "403":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. Possible reasons:
              * the API Token is missing or invalid
              * the caller has insufficient permissions.
                For modifying the definition of an existing feature, `WRITE` permission is required.
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. The thing or the feature with
            the given ID was not found.
        "412":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            A precondition for reading or writing the (sub-)resource failed. This will happen for write requests, if you
            specified an If-Match or If-None-Match header, which fails the precondition check against the current ETag of
            the (sub-)resource. For read requests, this error may only happen for a failing If-Match header. In case of a
            failing If-None-Match header for a read request, status 304 will be returned instead.
          headers:
            ETag:
              description: |-
                The (current server-side) ETag for this (sub-)resource. For top-level resources it is in the format
                "rev:[revision]", for sub-resources it has the format "hash:[calculated-hash]".
              explode: false
              schema:
                type: string
              style: simple
        "413":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The created or modified entity is larger than the accepted
            limit of 100 kB.
      summary: Create or update the definition of a feature
      tags:
      - Features
  /things/{thingId}/features/{featureId}/properties:
    delete:
      description: |-
        Deletes all properties of the feature identified by the `thingId` and
        `featureId` path parameter.
      parameters:
      - description: |-
          The ID of a thing needs to follow the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).

          The namespace needs to be registered for your solution
        explode: false
        in: path
        name: thingId
        required: true
        schema:
          type: string
        style: simple
      - description: The ID of the feature - has to conform to RFC-3986 (URI)
        explode: false
        in: path
        name: featureId
        required: true
        schema:
          type: string
        style: simple
      - description: |-
          The `If-Match` header which has to conform to RFC-7232 (Conditional Requests). Common usages are:
            * optimistic locking by specifying the `ETag` from a previous HTTP response, e.g. `If-Match: "hash:a75ece4e"`
            * retrieving or modifying a resource only if it already exists, e.g. `If-Match: *`
        explode: false
        in: header
        name: If-Match
        required: false
        schema:
          type: string
        style: simple
      - description: 'The `If-None-Match` header, which has to conform to RFC-7232
          (Conditional Requests). A common usage scenario is to modify a resource
          only if it does not yet exist, thus to create it, by specifying `If-None-Match:
          *`.'
        explode: false
        in: header
        name: If-None-Match
        required: false
        schema:
          type: string
        style: simple
      - description: |-
          Contains the "requested acknowledgements" for this modifying request as comma separated list. The HTTP call will
          block until all requested acknowledgements were aggregated or will time out based on the specified `timeout`
          parameter.

          The default (if omitted) requested acks is `requested-acks=twin-persisted` which will block the
          HTTP call until the change was persited to the twin.
        explode: true
        in: query
        name: requested-acks
        required: false
        schema:
          type: string
        style: form
      - description: |-
          Defines how long the backend should wait for completion of the request, e.g. applied when waiting for requested
          acknowledgements via the `requested-acks` param. Can be specified without unit (then seconds are assumed) or
          together with `s`, `ms` or `m` unit. Example: `42s`, `1m`.

          The default (if omitted) timeout is `10s`. Maximum value: `60s`.

          A value of `0` applies fire and forget semantics for the command resulting in setting `response-required=false`.
        explode: true
        in: query
        name: timeout
        required: false
        schema:
          type: string
        style: form
      - description: |-
          Defines whether a response is required to the API call or not - if set to `false` the response will directly
          sent back with a status code of `202` (Accepted).

          The default (if ommited) response is `true`.
        explode: true
        in: query
        name: response-required
        required: false
        schema:
          type: boolean
        style: form
      responses:
        "204":
          description: The properties were successfully deleted.
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. Possible reasons:
              * the `thingId` does not conform to the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to missing authentication.
        "402":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to exceeded transaction
            count.
        "403":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. Possible reasons:

              * the API Token is missing or invalid
              * the caller has insufficient permissions.
                For deleting the properties of an existing feature, `WRITE` permission is required.
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. The specified feature has no
            properties or the thing with the specified `thingId` or the feature
            with `featureId` was not found.
        "412":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            A precondition for reading or writing the (sub-)resource failed. This will happen for write requests, if you
            specified an If-Match or If-None-Match header, which fails the precondition check against the current ETag of
            the (sub-)resource. For read requests, this error may only happen for a failing If-Match header. In case of a
            failing If-None-Match header for a read request, status 304 will be returned instead.
          headers:
            ETag:
              description: |-
                The (current server-side) ETag for this (sub-)resource. For top-level resources it is in the format
                "rev:[revision]", for sub-resources it has the format "hash:[calculated-hash]".
              explode: false
              schema:
                type: string
              style: simple
      summary: Delete all properties of a feature
      tags:
      - Features
    get:
      description: |-
        Returns all properties of the feature identified by the `thingId` and
        `featureId` path parameter.
      parameters:
      - description: |-
          The ID of a thing needs to follow the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).

          The namespace needs to be registered for your solution
        explode: false
        in: path
        name: thingId
        required: true
        schema:
          type: string
        style: simple
      - description: The ID of the feature - has to conform to RFC-3986 (URI)
        explode: false
        in: path
        name: featureId
        required: true
        schema:
          type: string
        style: simple
      - description: |-
          Contains a comma-separated list of fields from the properties to be
          included in the returned JSON.

          #### Selectable fields

          Supports selecting arbitrary sub-fields as defined in the properties by
          using a comma-separated list:
            * several properties paths can be passed as a comma-separated list of JSON pointers (RFC-6901)

              For example:
                * `?fields=temperature` would select only `temperature` property value (if present)
                * `?fields=temperature,humidity` would select only `temperature` and `humidity` property values (if present)

          Supports selecting arbitrary sub-fields of objects by wrapping sub-fields
          inside parentheses `( )`:
            * a comma-separated list of sub-fields (a sub-field is a JSON pointer (RFC-6901) separated with `/`) to select
            * sub-selectors can be used to request only specific sub-fields by placing expressions in parentheses `( )` after a selected subfield

              For example:
               * `?fields=location(longitude,latitude)` would select the `longitude` and `latitude` value inside the `location` property

          #### Examples

          * `?fields=temperature,humidity,location(longitude,latitude)`

          * `?fields=configuration,status(powerConsumption/watts)`
        explode: true
        in: query
        name: fields
        required: false
        schema:
          type: string
        style: form
      - description: |-
          The `If-Match` header which has to conform to RFC-7232 (Conditional Requests). Common usages are:
            * optimistic locking by specifying the `ETag` from a previous HTTP response, e.g. `If-Match: "hash:a75ece4e"`
            * retrieving or modifying a resource only if it already exists, e.g. `If-Match: *`
        explode: false
        in: header
        name: If-Match
        required: false
        schema:
          type: string
        style: simple
      - description: 'The `If-None-Match` header, which has to conform to RFC-7232
          (Conditional Requests). A common usage scenario is to modify a resource
          only if it does not yet exist, thus to create it, by specifying `If-None-Match:
          *`.'
        explode: false
        in: header
        name: If-None-Match
        required: false
        schema:
          type: string
        style: simple
      - description: |-
          Defines how long the backend should wait for completion of the request, e.g. applied when waiting for requested
          acknowledgements via the `requested-acks` param. Can be specified without unit (then seconds are assumed) or
          together with `s`, `ms` or `m` unit. Example: `42s`, `1m`.

          The default (if omitted) timeout is `10s`. Maximum value: `60s`.

          A value of `0` applies fire and forget semantics for the command resulting in setting `response-required=false`.
        explode: true
        in: query
        name: timeout
        required: false
        schema:
          type: string
        style: form
      responses:
        "200":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/FeatureProperties'
          description: The properties were successfully retrieved.
          headers:
            ETag:
              description: |-
                The (current server-side) ETag for this (sub-)resource. For top-level resources it is in the format
                "rev:[revision]", for sub-resources it has the format "hash:[calculated-hash]".
              explode: false
              schema:
                type: string
              style: simple
        "304":
          description: |-
            The (sub-)resource has not been modified. This happens if you specified a If-None-Match header, which
             matches the current ETag of the (sub-)resource.
          headers:
            ETag:
              description: |-
                The (current server-side) ETag for this (sub-)resource. For top-level resources it is in the format
                "rev:[revision]", for sub-resources it has the format "hash:[calculated-hash]".
              explode: false
              schema:
                type: string
              style: simple
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. Possible reasons:
              * the `thingId` does not conform to the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).
              * at least one of the defined query parameters is invalid.
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to missing authentication.
        "402":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to exceeded transaction
            count.
        "403":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to a missing or invalid
            API Token.
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. The specified feature has no
            properties or the thing with the specified `thingId` or the feature
            with `featureId` was not found.
        "412":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            A precondition for reading or writing the (sub-)resource failed. This will happen for write requests, if you
            specified an If-Match or If-None-Match header, which fails the precondition check against the current ETag of
            the (sub-)resource. For read requests, this error may only happen for a failing If-Match header. In case of a
            failing If-None-Match header for a read request, status 304 will be returned instead.
          headers:
            ETag:
              description: |-
                The (current server-side) ETag for this (sub-)resource. For top-level resources it is in the format
                "rev:[revision]", for sub-resources it has the format "hash:[calculated-hash]".
              explode: false
              schema:
                type: string
              style: simple
      summary: List all properties of a feature
      tags:
      - Features
    put:
      description: |-
        Create or update the properties of a feature identified by the `thingId`
        and `featureId` path parameter.

        The properties will be overwritten with the JSON content from the request body.
      parameters:
      - description: |-
          The ID of a thing needs to follow the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).

          The namespace needs to be registered for your solution
        explode: false
        in: path
        name: thingId
        required: true
        schema:
          type: string
        style: simple
      - description: The ID of the feature - has to conform to RFC-3986 (URI)
        explode: false
        in: path
        name: featureId
        required: true
        schema:
          type: string
        style: simple
      - description: |-
          The `If-Match` header which has to conform to RFC-7232 (Conditional Requests). Common usages are:
            * optimistic locking by specifying the `ETag` from a previous HTTP response, e.g. `If-Match: "hash:a75ece4e"`
            * retrieving or modifying a resource only if it already exists, e.g. `If-Match: *`
        explode: false
        in: header
        name: If-Match
        required: false
        schema:
          type: string
        style: simple
      - description: 'The `If-None-Match` header, which has to conform to RFC-7232
          (Conditional Requests). A common usage scenario is to modify a resource
          only if it does not yet exist, thus to create it, by specifying `If-None-Match:
          *`.'
        explode: false
        in: header
        name: If-None-Match
        required: false
        schema:
          type: string
        style: simple
      - description: |-
          Contains the "requested acknowledgements" for this modifying request as comma separated list. The HTTP call will
          block until all requested acknowledgements were aggregated or will time out based on the specified `timeout`
          parameter.

          The default (if omitted) requested acks is `requested-acks=twin-persisted` which will block the
          HTTP call until the change was persited to the twin.
        explode: true
        in: query
        name: requested-acks
        required: false
        schema:
          type: string
        style: form
      - description: |-
          Defines how long the backend should wait for completion of the request, e.g. applied when waiting for requested
          acknowledgements via the `requested-acks` param. Can be specified without unit (then seconds are assumed) or
          together with `s`, `ms` or `m` unit. Example: `42s`, `1m`.

          The default (if omitted) timeout is `10s`. Maximum value: `60s`.

          A value of `0` applies fire and forget semantics for the command resulting in setting `response-required=false`.
        explode: true
        in: query
        name: timeout
        required: false
        schema:
          type: string
        style: form
      - description: |-
          Defines whether a response is required to the API call or not - if set to `false` the response will directly
          sent back with a status code of `202` (Accepted).

          The default (if ommited) response is `true`.
        explode: true
        in: query
        name: response-required
        required: false
        schema:
          type: boolean
        style: form
      requestBody:
        content:
          application/json:
            example:
              configuration:
                smartMode: true
                brewingTemp: 87
                tempToHold: 44
                timeoutSeconds: 6000
              status:
                waterAmount: 731
                temperature: 44
            schema:
              $ref: '#/components/schemas/FeatureProperties'
        description: |-
          JSON object of all properties to be updated at once.

          Consider that the value has to be a JSON object or `null`. We strongly recommend to use
          a restricted set of characters for the key (identifier).

          Currently these identifiers should follow the pattern: [_a-zA-Z][_a-zA-Z0-9\-]*
        required: true
      responses:
        "201":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/FeatureProperties'
          description: The properties were successfully created.
          headers:
            ETag:
              description: |-
                The (current server-side) ETag for this (sub-)resource. For top-level resources it is in the format
                "rev:[revision]", for sub-resources it has the format "hash:[calculated-hash]".
              explode: false
              schema:
                type: string
              style: simple
        "204":
          description: The properties were successfully updated.
          headers:
            ETag:
              description: |-
                The (current server-side) ETag for this (sub-)resource. For top-level resources it is in the format
                "rev:[revision]", for sub-resources it has the format "hash:[calculated-hash]".
              explode: false
              schema:
                type: string
              style: simple
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. Possible reasons:
              * the `thingId` does not conform to the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).
              * the JSON body of the feature properties to be created/modified is invalid
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to missing authentication.
        "402":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to exceeded data volume
            or exceeded transaction count.
        "403":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. Possible reasons:

              * the API Token is missing or invalid
              * the caller has insufficient permissions.
                For modifying the properties of an existing feature, `WRITE` permission is required.
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. The thing or the feature with
            the given ID was not found.
        "412":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            A precondition for reading or writing the (sub-)resource failed. This will happen for write requests, if you
            specified an If-Match or If-None-Match header, which fails the precondition check against the current ETag of
            the (sub-)resource. For read requests, this error may only happen for a failing If-Match header. In case of a
            failing If-None-Match header for a read request, status 304 will be returned instead.
          headers:
            ETag:
              description: |-
                The (current server-side) ETag for this (sub-)resource. For top-level resources it is in the format
                "rev:[revision]", for sub-resources it has the format "hash:[calculated-hash]".
              explode: false
              schema:
                type: string
              style: simple
        "413":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The created or modified entity is larger than the accepted
            limit of 100 kB.
      summary: Create or update all properties of a feature at once
      tags:
      - Features
  /things/{thingId}/features/{featureId}/properties/{propertyPath}:
    delete:
      description: |-
        Deletes a specific property of the feature identified by the `thingId`
        and `featureId` path parameter.

        The property (JSON) can be referenced
        hierarchically, by applying JSON Pointer notation (RFC-6901)

        ### Example
        To delete the value of the brewingTemp in the water-tank of our coffeemaker example the full path is:

        `/things/{thingId}/features/water-tank/properties/configuration/brewingTemp`
      parameters:
      - description: |-
          The ID of a thing needs to follow the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).

          The namespace needs to be registered for your solution
        explode: false
        in: path
        name: thingId
        required: true
        schema:
          type: string
        style: simple
      - description: The ID of the feature - has to conform to RFC-3986 (URI)
        explode: false
        in: path
        name: featureId
        required: true
        schema:
          type: string
        style: simple
      - description: The path to the property
        explode: false
        in: path
        name: propertyPath
        required: true
        schema:
          type: string
        style: simple
      - description: |-
          The `If-Match` header which has to conform to RFC-7232 (Conditional Requests). Common usages are:
            * optimistic locking by specifying the `ETag` from a previous HTTP response, e.g. `If-Match: "hash:a75ece4e"`
            * retrieving or modifying a resource only if it already exists, e.g. `If-Match: *`
        explode: false
        in: header
        name: If-Match
        required: false
        schema:
          type: string
        style: simple
      - description: 'The `If-None-Match` header, which has to conform to RFC-7232
          (Conditional Requests). A common usage scenario is to modify a resource
          only if it does not yet exist, thus to create it, by specifying `If-None-Match:
          *`.'
        explode: false
        in: header
        name: If-None-Match
        required: false
        schema:
          type: string
        style: simple
      - description: |-
          Contains the "requested acknowledgements" for this modifying request as comma separated list. The HTTP call will
          block until all requested acknowledgements were aggregated or will time out based on the specified `timeout`
          parameter.

          The default (if omitted) requested acks is `requested-acks=twin-persisted` which will block the
          HTTP call until the change was persited to the twin.
        explode: true
        in: query
        name: requested-acks
        required: false
        schema:
          type: string
        style: form
      - description: |-
          Defines how long the backend should wait for completion of the request, e.g. applied when waiting for requested
          acknowledgements via the `requested-acks` param. Can be specified without unit (then seconds are assumed) or
          together with `s`, `ms` or `m` unit. Example: `42s`, `1m`.

          The default (if omitted) timeout is `10s`. Maximum value: `60s`.

          A value of `0` applies fire and forget semantics for the command resulting in setting `response-required=false`.
        explode: true
        in: query
        name: timeout
        required: false
        schema:
          type: string
        style: form
      - description: |-
          Defines whether a response is required to the API call or not - if set to `false` the response will directly
          sent back with a status code of `202` (Accepted).

          The default (if ommited) response is `true`.
        explode: true
        in: query
        name: response-required
        required: false
        schema:
          type: boolean
        style: form
      responses:
        "204":
          description: The property was successfully deleted.
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. Possible reasons:
              * the `thingId` does not conform to the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to missing authentication.
        "402":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to exceeded transaction
            count.
        "403":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to a missing or invalid
            API Token.
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. The specified property or the
            thing with the specified `thingId` or the feature with `featureId`
            was not found.
        "412":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            A precondition for reading or writing the (sub-)resource failed. This will happen for write requests, if you
            specified an If-Match or If-None-Match header, which fails the precondition check against the current ETag of
            the (sub-)resource. For read requests, this error may only happen for a failing If-Match header. In case of a
            failing If-None-Match header for a read request, status 304 will be returned instead.
          headers:
            ETag:
              description: |-
                The (current server-side) ETag for this (sub-)resource. For top-level resources it is in the format
                "rev:[revision]", for sub-resources it has the format "hash:[calculated-hash]".
              explode: false
              schema:
                type: string
              style: simple
      summary: Delete a specific property of a feature
      tags:
      - Features
    get:
      description: |-
        Returns the a specific property path of the feature identified by the `thingId` and
        `featureId` path parameter.

        The property (JSON) can be referenced
        hierarchically, by applying JSON Pointer notation (RFC-6901)

        ### Example
        To retrieve the value of the `brewingTemp` in the `water-tank` of our coffeemaker example the full path is:

        `/things/{thingId}/features/water-tank/properties/configuration/brewingTemp`
      parameters:
      - description: |-
          The ID of a thing needs to follow the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).

          The namespace needs to be registered for your solution
        explode: false
        in: path
        name: thingId
        required: true
        schema:
          type: string
        style: simple
      - description: The ID of the feature - has to conform to RFC-3986 (URI)
        explode: false
        in: path
        name: featureId
        required: true
        schema:
          type: string
        style: simple
      - description: The path to the property
        explode: false
        in: path
        name: propertyPath
        required: true
        schema:
          type: string
        style: simple
      - description: |-
          The `If-Match` header which has to conform to RFC-7232 (Conditional Requests). Common usages are:
            * optimistic locking by specifying the `ETag` from a previous HTTP response, e.g. `If-Match: "hash:a75ece4e"`
            * retrieving or modifying a resource only if it already exists, e.g. `If-Match: *`
        explode: false
        in: header
        name: If-Match
        required: false
        schema:
          type: string
        style: simple
      - description: 'The `If-None-Match` header, which has to conform to RFC-7232
          (Conditional Requests). A common usage scenario is to modify a resource
          only if it does not yet exist, thus to create it, by specifying `If-None-Match:
          *`.'
        explode: false
        in: header
        name: If-None-Match
        required: false
        schema:
          type: string
        style: simple
      - description: |-
          Defines how long the backend should wait for completion of the request, e.g. applied when waiting for requested
          acknowledgements via the `requested-acks` param. Can be specified without unit (then seconds are assumed) or
          together with `s`, `ms` or `m` unit. Example: `42s`, `1m`.

          The default (if omitted) timeout is `10s`. Maximum value: `60s`.

          A value of `0` applies fire and forget semantics for the command resulting in setting `response-required=false`.
        explode: true
        in: query
        name: timeout
        required: false
        schema:
          type: string
        style: form
      responses:
        "200":
          description: The property was successfully retrieved.
          headers:
            ETag:
              description: |-
                The (current server-side) ETag for this (sub-)resource. For top-level resources it is in the format
                "rev:[revision]", for sub-resources it has the format "hash:[calculated-hash]".
              explode: false
              schema:
                type: string
              style: simple
        "304":
          description: |-
            The (sub-)resource has not been modified. This happens if you specified a If-None-Match header, which
             matches the current ETag of the (sub-)resource.
          headers:
            ETag:
              description: |-
                The (current server-side) ETag for this (sub-)resource. For top-level resources it is in the format
                "rev:[revision]", for sub-resources it has the format "hash:[calculated-hash]".
              explode: false
              schema:
                type: string
              style: simple
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. Possible reasons:
              * the `thingId` does not conform to the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to missing authentication.
        "402":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to exceeded transaction
            count.
        "403":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to a missing or invalid
            API Token.
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. The specified property or the
            thing with the specified `thingId` or the feature with `featureId`
            was not found.
        "412":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            A precondition for reading or writing the (sub-)resource failed. This will happen for write requests, if you
            specified an If-Match or If-None-Match header, which fails the precondition check against the current ETag of
            the (sub-)resource. For read requests, this error may only happen for a failing If-Match header. In case of a
            failing If-None-Match header for a read request, status 304 will be returned instead.
          headers:
            ETag:
              description: |-
                The (current server-side) ETag for this (sub-)resource. For top-level resources it is in the format
                "rev:[revision]", for sub-resources it has the format "hash:[calculated-hash]".
              explode: false
              schema:
                type: string
              style: simple
      summary: Retrieve a specific property of a feature
      tags:
      - Features
    put:
      description: |-
        Create or update a specific property of a feature identified by the
        `thingId` and `featureId` path parameter.

        The property will be created
        if it doesn't exist or else updated.

        The property (JSON) can be
        referenced hierarchically, by applying JSON Pointer notation (RFC-6901),

        ### Example
        To set the value of the brewingTemp in the water-tank of our coffeemaker example the full path is:

        `/things/{thingId}/features/water-tank/properties/configuration/brewingTemp`
      parameters:
      - description: |-
          The ID of a thing needs to follow the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).

          The namespace needs to be registered for your solution
        explode: false
        in: path
        name: thingId
        required: true
        schema:
          type: string
        style: simple
      - description: The ID of the feature - has to conform to RFC-3986 (URI)
        explode: false
        in: path
        name: featureId
        required: true
        schema:
          type: string
        style: simple
      - description: The path to the property
        explode: false
        in: path
        name: propertyPath
        required: true
        schema:
          type: string
        style: simple
      - description: |-
          The `If-Match` header which has to conform to RFC-7232 (Conditional Requests). Common usages are:
            * optimistic locking by specifying the `ETag` from a previous HTTP response, e.g. `If-Match: "hash:a75ece4e"`
            * retrieving or modifying a resource only if it already exists, e.g. `If-Match: *`
        explode: false
        in: header
        name: If-Match
        required: false
        schema:
          type: string
        style: simple
      - description: 'The `If-None-Match` header, which has to conform to RFC-7232
          (Conditional Requests). A common usage scenario is to modify a resource
          only if it does not yet exist, thus to create it, by specifying `If-None-Match:
          *`.'
        explode: false
        in: header
        name: If-None-Match
        required: false
        schema:
          type: string
        style: simple
      - description: |-
          Contains the "requested acknowledgements" for this modifying request as comma separated list. The HTTP call will
          block until all requested acknowledgements were aggregated or will time out based on the specified `timeout`
          parameter.

          The default (if omitted) requested acks is `requested-acks=twin-persisted` which will block the
          HTTP call until the change was persited to the twin.
        explode: true
        in: query
        name: requested-acks
        required: false
        schema:
          type: string
        style: form
      - description: |-
          Defines how long the backend should wait for completion of the request, e.g. applied when waiting for requested
          acknowledgements via the `requested-acks` param. Can be specified without unit (then seconds are assumed) or
          together with `s`, `ms` or `m` unit. Example: `42s`, `1m`.

          The default (if omitted) timeout is `10s`. Maximum value: `60s`.

          A value of `0` applies fire and forget semantics for the command resulting in setting `response-required=false`.
        explode: true
        in: query
        name: timeout
        required: false
        schema:
          type: string
        style: form
      - description: |-
          Defines whether a response is required to the API call or not - if set to `false` the response will directly
          sent back with a status code of `202` (Accepted).

          The default (if ommited) response is `true`.
        explode: true
        in: query
        name: response-required
        required: false
        schema:
          type: boolean
        style: form
      requestBody:
        $ref: '#/components/requestBodies/Value'
      responses:
        "201":
          description: The property was successfully created.
          headers:
            ETag:
              description: |-
                The (current server-side) ETag for this (sub-)resource. For top-level resources it is in the format
                "rev:[revision]", for sub-resources it has the format "hash:[calculated-hash]".
              explode: false
              schema:
                type: string
              style: simple
        "204":
          description: The property was successfully updated.
          headers:
            ETag:
              description: |-
                The (current server-side) ETag for this (sub-)resource. For top-level resources it is in the format
                "rev:[revision]", for sub-resources it has the format "hash:[calculated-hash]".
              explode: false
              schema:
                type: string
              style: simple
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. Possible reasons:
              * the `thingId` does not conform to the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).
              * the JSON body is invalid
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to missing authentication.
        "402":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to exceeded data volume
            or exceeded transaction count.
        "403":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. Possible reasons:

              * the API Token is missing or invalid
              * the caller has insufficient permissions.
                For creating/updating a property of an existing feature, `WRITE` permission is required.
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. The thing or the feature with
            the given ID was not found.
        "412":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            A precondition for reading or writing the (sub-)resource failed. This will happen for write requests, if you
            specified an If-Match or If-None-Match header, which fails the precondition check against the current ETag of
            the (sub-)resource. For read requests, this error may only happen for a failing If-Match header. In case of a
            failing If-None-Match header for a read request, status 304 will be returned instead.
          headers:
            ETag:
              description: |-
                The (current server-side) ETag for this (sub-)resource. For top-level resources it is in the format
                "rev:[revision]", for sub-resources it has the format "hash:[calculated-hash]".
              explode: false
              schema:
                type: string
              style: simple
        "413":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The created or modified entity is larger than the accepted
            limit of 100 kB.
      summary: Create or update a specific property of a feature
      tags:
      - Features
  /things/{thingId}/inbox/claim:
    post:
      description: |-
        ### Why
        A claiming process may enable an end-user to claim things and proof ownership thereof.
        Such a process is initially triggered via a claim message.
        This message can be sent to the things service with the HTTP API or the things-client.

        ### How
        At this resource you can send a "claim" message to the thing identified
        by the `thingId` path parameter in order to gain access to it. The "claim" message is forwarded
        together with the request body and `Content-Type` header to client(s)
        which registered for Claim messages of the specific thing.

        The decision whether to grant access (by setting permissions) is
        completely up to the client(s) which handle the "claim" message.

        The HTTP request blocks until a response to the issued "claim" message is
        available or until the `timeout` is expired. If many clients respond to
        the issued message, the first response will complete the HTTP request.

        Note that the client chooses which HTTP status code it wants to return. Things
        will forward the status code to you. (Also note that '204 - No Content' status code
        will never return a body, even if the client responded with a body).

        ### Who
        No special permission is required to issue a claim message.

        ### Example
        See [Claiming](https://docs.bosch-iot-suite.com/things/basic-concepts/auth/claim/) concept in detail and example in GitHub.
        However, in that scenario, the policy should grant you READ and WRITE permission on
        the "message:/" resource in order to be able to send the message and read the response.
        Further, the things-client which handles the "claim" message, needs permission to change the policy itself
        (i.e. READ and WRITE permission on the "policy:/" resource).
      parameters:
      - description: |-
          The ID of a thing needs to follow the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).

          The namespace needs to be registered for your solution
        explode: false
        in: path
        name: thingId
        required: true
        schema:
          type: string
        style: simple
      - description: |-
          Contains an optional timeout (in seconds) of how long to wait for the Claim response and therefore block the
          HTTP request. Default value (if omitted): 60 seconds. Maximum value: 600 seconds. A value of 0 seconds applies
          fire and forget semantics for the message.
        explode: true
        in: query
        name: timeout
        required: false
        schema:
          type: integer
        style: form
      requestBody:
        $ref: '#/components/requestBodies/Payload'
      responses:
        "200":
          description: |-
            The Claim message was processed successfully and the response body
            contains the custom response. The response body may contain
            arbitrary data chosen by the recipient. The response code defaults
            to `200` but may be chosen by the recipient too.
        "204":
          description: |-
            The Claim message was processed successfully and no custom response
            body was set. The response code defaults to `204` but may be chosen
            by the recipient.
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. Possible reasons:
              * the `thingId` does not conform to the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).
              * at least one of the defined path parameters is invalid
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to missing authentication.
        "402":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to exceeded transaction
            count.
        "403":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to a missing or invalid
            API Token.
        "413":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The size of the send message is larger than the accepted limit
            of 250 kB.
        "429":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The user has sent too many requests in a given amount of time ("rate
            limiting").
        "503":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed as there is no consumer
            for this message connected.
      summary: Initiates claiming a specific thing in order to gain access
      tags:
      - Messages
  /things/{thingId}/inbox/messages/{messageSubject}:
    post:
      description: |-
        ### Why
        A message can be sent to a thing or one of its features in order to invoke an operation on the device.

        ### How
        Send a message with a `messageSubject` **to** the thing
        identified by the `thingId` path parameter. The request body contains
        the message payload and the `Content-Type` header defines its type.

        The API does not provide any kind of acknowledgement that the thing has received the message.

        The HTTP request blocks until a response to the message is available
        or until the `timeout` is expired. If many clients respond to
        the issued message, the first response will complete the HTTP request.

        In order to handle the message in a fire and forget manner, add
        a query-parameter `timeout=0` to the request.

        Note that the client chooses which HTTP status code it wants to return. Things
        will forward the status code to you. (Also note that '204 - No Content' status code
        will never return a body, even if the client responded with a body).

        ### Who
        You will need `WRITE` permission on the root "message:/" resource, or at least
        the resource `message:/inbox/messages/messageSubject`. The receiving device needs `READ` permission on the resource.
        Such permission is managed within the policy which controls the access on the thing.

        ### Example
        Given you have a "coffemaker" thing as shown in the examples for the `things` resources.
        The `messageSubject` understood by such a device would be "makeCoffee".

        Further, as in our example the "brewed-coffees" counter would increase as a response, you would need `WRITE`
        permission for the things resource, at least at the respective path

        `/things/{thingId}/features/coffee-brewer/properties/brewed-coffees`
      parameters:
      - description: |-
          The ID of a thing needs to follow the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).

          The namespace needs to be registered for your solution
        explode: false
        in: path
        name: thingId
        required: true
        schema:
          type: string
        style: simple
      - description: The subject of the Message - has to conform to RFC-3986 (URI)
        explode: false
        in: path
        name: messageSubject
        required: true
        schema:
          type: string
        style: simple
      - description: |-
          Contains an optional timeout (in seconds) of how long to wait for the message response and therefore block the
          HTTP request. Default value (if omitted): 10 seconds. Maximum value: 60 seconds. A value of 0 seconds applies
          fire and forget semantics for the message.
        explode: true
        in: query
        name: timeout
        required: false
        schema:
          type: integer
        style: form
      requestBody:
        $ref: '#/components/requestBodies/Payload'
      responses:
        "202":
          description: The message was sent but not necessarily received by the thing
            (fire and forget).
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. Possible reasons:
              * the `thingId` does not conform to the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).
              * at least one of the defined path parameters is invalid
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to missing authentication.
        "402":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to exceeded transaction
            count.
        "403":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. Possible reasons:

              * the API Token is missing or invalid
              * the caller has insufficient permissions.
                You need `WRITE` permission on the resource `message:/inbox/messages/{messageSubject}`.
        "413":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The size of the send message is larger than the accepted limit
            of 250 kB.
        "503":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed as there is no consumer
            for this message connected.
      summary: Send a message TO a specific thing
      tags:
      - Messages
  /things/{thingId}/outbox/messages/{messageSubject}:
    post:
      description: |-
        Send a message with the subject `messageSubject` **from** the thing
        identified by the `thingId` path parameter. The request body contains
        the message payload and the `Content-Type` header defines its type.

        The HTTP request blocks until a response to the message is available
        or until the `timeout` is expired. If many clients respond to
        the issued message, the first response will complete the HTTP request.

        In order to handle the message in a fire and forget manner, add
        a query-parameter `timeout=0` to the request.

        Note that the client chooses which HTTP status code it wants to return. Things
        will forward the status code to you. (Also note that '204 - No Content' status code
        will never return a body, even if the client responded with a body).

        ### Who
        You will need `WRITE` permission on the root "message:/" resource, or at least
        the resource `message:/outbox/messages/messageSubject`.
        Such permission is managed  within the policy which controls the access on the thing.
      parameters:
      - description: |-
          The ID of a thing needs to follow the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).

          The namespace needs to be registered for your solution
        explode: false
        in: path
        name: thingId
        required: true
        schema:
          type: string
        style: simple
      - description: The subject of the Message - has to conform to RFC-3986 (URI)
        explode: false
        in: path
        name: messageSubject
        required: true
        schema:
          type: string
        style: simple
      - description: |-
          Contains an optional timeout (in seconds) of how long to wait for the message response and therefore block the
          HTTP request. Default value (if omitted): 10 seconds. Maximum value: 60 seconds. A value of 0 seconds applies
          fire and forget semantics for the message.
        explode: true
        in: query
        name: timeout
        required: false
        schema:
          type: integer
        style: form
      requestBody:
        $ref: '#/components/requestBodies/Payload'
      responses:
        "202":
          description: The message was sent (fire and forget).
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. Possible reasons:
              * the `thingId` does not conform to the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).
              * at least one of the defined path parameters is invalid.
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to missing authentication.
        "402":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to exceeded transaction
            count.
        "403":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. Possible reasons:

              * the API Token is missing or invalid
              * the caller has insufficient permissions.
                You need `WRITE` permission on the resource `message:/outbox/messages/{messageSubject}`.
        "413":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The size of the send message is larger than the accepted limit
            of 250 kB.
        "503":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed as there is no consumer
            for this message connected.
      summary: Send a message FROM a specific thing
      tags:
      - Messages
  /things/{thingId}/features/{featureId}/inbox/messages/{messageSubject}:
    post:
      description: |-
        Send a message with the subject `messageSubject` **to** the feature
        specified by the `featureId` and `thingId` path parameter. The request
        body contains the message payload and the `Content-Type` header defines
        its type. The API does not provide any kind of acknowledgement that the
        message was received by the feature.

        The HTTP request blocks until a response to the message is available
        or until the `timeout` is expired. If many clients respond to
        the issued message, the first response will complete the HTTP request.

        In order to handle the message in a fire and forget manner, add
        a query-parameter `timeout=0` to the request.

        Note that the client chooses which HTTP status code it wants to return. Things
        will forward the status code to you. (Also note that '204 - No Content' status code
        will never return a body, even if the client responded with a body).

        ### Who
        You will need `WRITE` permission on the root "message:/" resource, or at least
        the resource `message:/features/featureId/inbox/messages/messageSubject`. The receiving device needs `READ` permission on the resource.
        Such permission is managed  within the policy which controls the access on the thing.
      parameters:
      - description: |-
          The ID of a thing needs to follow the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).

          The namespace needs to be registered for your solution
        explode: false
        in: path
        name: thingId
        required: true
        schema:
          type: string
        style: simple
      - description: The ID of the feature - has to conform to RFC-3986 (URI)
        explode: false
        in: path
        name: featureId
        required: true
        schema:
          type: string
        style: simple
      - description: The subject of the Message - has to conform to RFC-3986 (URI)
        explode: false
        in: path
        name: messageSubject
        required: true
        schema:
          type: string
        style: simple
      - description: |-
          Contains an optional timeout (in seconds) of how long to wait for the message response and therefore block the
          HTTP request. Default value (if omitted): 10 seconds. Maximum value: 60 seconds. A value of 0 seconds applies
          fire and forget semantics for the message.
        explode: true
        in: query
        name: timeout
        required: false
        schema:
          type: integer
        style: form
      requestBody:
        $ref: '#/components/requestBodies/Payload'
      responses:
        "202":
          description: |-
            The message was sent but not necessarily received by the feature
            (fire and forget).
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. Possible reasons:
              * the `thingId` does not conform to the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).
              * at least one of the defined path parameters is invalid.
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to missing authentication.
        "402":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to exceeded transaction
            count.
        "403":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. Possible reasons:

             * the API Token is missing or invalid
             * the caller has insufficient permissions.
               You need `WRITE` permission on the resource `message:/features/{featureId}/inbox/messages/{messageSubject}`.
        "413":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The size of the send message is larger than the accepted limit
            of 250 kB.
        "503":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed as there is no consumer
            for this message connected.
      summary: Send a message TO a specific feature of a specific thing
      tags:
      - Messages
  /things/{thingId}/features/{featureId}/outbox/messages/{messageSubject}:
    post:
      description: |-
        Send a message with the subject `messageSubject` **from** the feature
        specified by the `featureId` and `thingId` path parameter. The request
        body contains the message payload and the `Content-Type` header defines
        its type.

        The HTTP request blocks until a response to the message is available
        or until the `timeout` is expired. If many clients respond to
        the issued message, the first response will complete the HTTP request.

        In order to handle the message in a fire and forget manner, add
        a query-parameter `timeout=0` to the request.

        Note that the client chooses which HTTP status code it wants to return. Things
        will forward the status code to you. (Also note that '204 - No Content' status code
        will never return a body, even if the client responded with a body).

        ### Who
        You will need `WRITE` permission on the root "message:/" resource, or at least
        the resource `message:/features/featureId/outbox/messages/messageSubject`.
        Such permission is managed  within the policy which controls the access on the thing.
      parameters:
      - description: |-
          The ID of a thing needs to follow the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).

          The namespace needs to be registered for your solution
        explode: false
        in: path
        name: thingId
        required: true
        schema:
          type: string
        style: simple
      - description: The ID of the feature - has to conform to RFC-3986 (URI)
        explode: false
        in: path
        name: featureId
        required: true
        schema:
          type: string
        style: simple
      - description: The subject of the Message - has to conform to RFC-3986 (URI)
        explode: false
        in: path
        name: messageSubject
        required: true
        schema:
          type: string
        style: simple
      - description: |-
          Contains an optional timeout (in seconds) of how long to wait for the message response and therefore block the
          HTTP request. Default value (if omitted): 10 seconds. Maximum value: 60 seconds. A value of 0 seconds applies
          fire and forget semantics for the message.
        explode: true
        in: query
        name: timeout
        required: false
        schema:
          type: integer
        style: form
      requestBody:
        $ref: '#/components/requestBodies/Payload'
      responses:
        "202":
          description: The message was sent (fire and forget).
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. Possible reasons:
              * the `thingId` does not conform to the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).
              * at least one of the defined path parameters is valid.
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to missing authentication.
        "402":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to exceeded transaction
            count.
        "403":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. Possible reasons:

              * the API Token is missing or invalid
              * the caller has insufficient permissions.
                You need `WRITE` permission on the resource `message:/features/{featureId}/outbox/messages/{messageSubject}`.
        "413":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The size of the send message is larger than the accepted limit
            of 250 kB.
        "503":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed as there is no consumer
            for this message connected.
      summary: Send a message FROM a specific feature of a specific thing
      tags:
      - Messages
  /policies/{policyId}:
    delete:
      description: |-
        Deletes the policy identified by the `policyId` path parameter. Deleting
        a policy does not implicitly delete other entities (e.g. things) which
        use this policy.

        Note: Delete the respective things **before** deleting the
        policy, otherwise nobody has permission to read, update, or delete the things.
        If you accidentally run into such a scenario, re-create the policy via
        PUT `/policies/{policyId}`.
      parameters:
      - description: |-
          The ID of the policy needs to follow the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).

          The namespace needs to:
          * conform to the reverse domain name notation
          * be registered for your solution
        explode: false
        in: path
        name: policyId
        required: true
        schema:
          type: string
        style: simple
      - description: |-
          The `If-Match` header, which has to conform to RFC-7232 (Conditional Requests). Common usages are:
            * optimistic locking by specifying the `ETag` from a previous GET response, e.g. `If-Match: "rev:4711"`
            * retrieving or modifying a resource only if it already exists, e.g. `If-Match: *`
        explode: false
        in: header
        name: If-Match
        required: false
        schema:
          type: string
        style: simple
      - description: 'The `If-None-Match` header, which has to conform to RFC-7232
          (Conditional Requests). A common usage scenario is to modify a resource
          only if it does not yet exist, thus to create it, by specifying `If-None-Match:
          *`.'
        explode: false
        in: header
        name: If-None-Match
        required: false
        schema:
          type: string
        style: simple
      - description: |-
          Defines how long the backend should wait for completion of the request, e.g. applied when waiting for requested
          acknowledgements via the `requested-acks` param. Can be specified without unit (then seconds are assumed) or
          together with `s`, `ms` or `m` unit. Example: `42s`, `1m`.

          The default (if omitted) timeout is `10s`. Maximum value: `60s`.

          A value of `0` applies fire and forget semantics for the command resulting in setting `response-required=false`.
        explode: true
        in: query
        name: timeout
        required: false
        schema:
          type: string
        style: form
      - description: |-
          Defines whether a response is required to the API call or not - if set to `false` the response will directly
          sent back with a status code of `202` (Accepted).

          The default (if ommited) response is `true`.
        explode: true
        in: query
        name: response-required
        required: false
        schema:
          type: boolean
        style: form
      responses:
        "204":
          description: The policy was successfully deleted.
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. Possible reasons:

              * the `policyId` does not conform to the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id))
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to missing authentication.
        "402":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to exceeded transaction
            count.
        "403":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. Possible reasons:
              * the API Token is missing or invalid
              * the caller has insufficient permissions.
                You need `WRITE` permission on the root `policy:/` resource,
                without any revoke in a deeper path of the policy resource.having any revoke.
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. The policy with the given ID was
            not found in the context of the authenticated user.
        "412":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            A precondition for reading or writing the (sub-)resource failed. This will happen for write requests, if you
            specified an If-Match or If-None-Match header, which fails the precondition check against the current ETag of
            the (sub-)resource. For read requests, this error may only happen for a failing If-Match header. In case of a
            failing If-None-Match header for a read request, status 304 will be returned instead.
          headers:
            ETag:
              description: |-
                The (current server-side) ETag for this (sub-)resource. For top-level resources it is in the format
                "rev:[revision]", for sub-resources it has the format "hash:[calculated-hash]".
              explode: false
              schema:
                type: string
              style: simple
      summary: Delete a specific policy
      tags:
      - Policies
    get:
      description: |-
        Returns the complete policy identified by the `policyId` path parameter. The
        response contains the policy as JSON object.

        Tip: If you don't know the policy ID, request it via GET ​/things​/{thingId}.
      parameters:
      - description: |-
          The ID of the policy needs to follow the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).

          The namespace needs to:
          * conform to the reverse domain name notation
          * be registered for your solution
        explode: false
        in: path
        name: policyId
        required: true
        schema:
          type: string
        style: simple
      - description: |-
          The `If-Match` header, which has to conform to RFC-7232 (Conditional Requests). Common usages are:
            * optimistic locking by specifying the `ETag` from a previous GET response, e.g. `If-Match: "rev:4711"`
            * retrieving or modifying a resource only if it already exists, e.g. `If-Match: *`
        explode: false
        in: header
        name: If-Match
        required: false
        schema:
          type: string
        style: simple
      - description: 'The `If-None-Match` header, which has to conform to RFC-7232
          (Conditional Requests). A common usage scenario is to modify a resource
          only if it does not yet exist, thus to create it, by specifying `If-None-Match:
          *`.'
        explode: false
        in: header
        name: If-None-Match
        required: false
        schema:
          type: string
        style: simple
      - description: |-
          Defines how long the backend should wait for completion of the request, e.g. applied when waiting for requested
          acknowledgements via the `requested-acks` param. Can be specified without unit (then seconds are assumed) or
          together with `s`, `ms` or `m` unit. Example: `42s`, `1m`.

          The default (if omitted) timeout is `10s`. Maximum value: `60s`.

          A value of `0` applies fire and forget semantics for the command resulting in setting `response-required=false`.
        explode: true
        in: query
        name: timeout
        required: false
        schema:
          type: string
        style: form
      responses:
        "200":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Policy'
          description: |-
            The request successfully returned completed and returned is the
            policy.
          headers:
            ETag:
              description: |-
                The (current server-side) ETag for this (sub-)resource. For top-level resources it is in the format
                "rev:[revision]", for sub-resources it has the format "hash:[calculated-hash]".
              explode: false
              schema:
                type: string
              style: simple
        "304":
          description: |-
            The (sub-)resource has not been modified. This happens if you specified a If-None-Match header, which
             matches the current ETag of the (sub-)resource.
          headers:
            ETag:
              description: |-
                The (current server-side) ETag for this (sub-)resource. For top-level resources it is in the format
                "rev:[revision]", for sub-resources it has the format "hash:[calculated-hash]".
              explode: false
              schema:
                type: string
              style: simple
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. Possible reasons:

              * the `policyId` does not conform to the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id))
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to missing authentication.
        "402":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to exceeded transaction
            count.
        "403":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to a missing or invalid
            API Token.
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. The policy with the given ID was
            not found in the context of the authenticated user.
        "412":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            A precondition for reading or writing the (sub-)resource failed. This will happen for write requests, if you
            specified an If-Match or If-None-Match header, which fails the precondition check against the current ETag of
            the (sub-)resource. For read requests, this error may only happen for a failing If-Match header. In case of a
            failing If-None-Match header for a read request, status 304 will be returned instead.
          headers:
            ETag:
              description: |-
                The (current server-side) ETag for this (sub-)resource. For top-level resources it is in the format
                "rev:[revision]", for sub-resources it has the format "hash:[calculated-hash]".
              explode: false
              schema:
                type: string
              style: simple
      summary: Retrieve a specific policy
      tags:
      - Policies
    put:
      description: |-
        Create or update the policy specified by the policyId path parameter.
        * If you set a new policyId in the path, a new policy will be created.
        * If you set an existing policyId in the path, the policy will be updated.

        ### Create a new policy
        At the initial creation of a policy, at least one valid entry is required. However, you can create a full-fledged policy all at once.

        Example: To create a policy for multiple coffee maker things,
        which gives **yourself** all permissions on all resources, set the policyId in the path,
        e.g. to "com.acme.coffeemaker:policy-01" and the body part, like in the following snippet.

        ```
        {
          "entries": {
            "DEFAULT": {
              "subjects": {
                "{{ request:subjectId }}": {
                  "type": "bosch-id"
                }
              },
              "resources": {
                "policy:/": {
                  "grant": [
                    "READ",
                    "WRITE"
                  ],
                  "revoke": []
                },
                "thing:/": {
                  "grant": [
                    "READ",
                    "WRITE"
                  ],
                  "revoke": []
                },
                "message:/": {
                  "grant": [
                    "READ",
                    "WRITE"
                  ],
                  "revoke": []
                }
              }
            }
          }
        }
        ```

        ### Update an existing policy
        For updating an existing policy, the authorized subject needs WRITE permission on the policy's root resource.

        The ID of a policy cannot be changed after creation. Any `policyId` specified in the request body is therefore ignored.

        ### Partially update an existing policy
        Partial updates are not supported.

        If you need to create or update a specific label, resource, or subject, please use the respective sub-resources.
      parameters:
      - description: |-
          The ID of the policy needs to follow the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).

          The namespace needs to:
          * conform to the reverse domain name notation
          * be registered for your solution
        explode: false
        in: path
        name: policyId
        required: true
        schema:
          type: string
        style: simple
      - description: |-
          The `If-Match` header, which has to conform to RFC-7232 (Conditional Requests). Common usages are:
            * optimistic locking by specifying the `ETag` from a previous GET response, e.g. `If-Match: "rev:4711"`
            * retrieving or modifying a resource only if it already exists, e.g. `If-Match: *`
        explode: false
        in: header
        name: If-Match
        required: false
        schema:
          type: string
        style: simple
      - description: 'The `If-None-Match` header, which has to conform to RFC-7232
          (Conditional Requests). A common usage scenario is to modify a resource
          only if it does not yet exist, thus to create it, by specifying `If-None-Match:
          *`.'
        explode: false
        in: header
        name: If-None-Match
        required: false
        schema:
          type: string
        style: simple
      - description: |-
          Defines how long the backend should wait for completion of the request, e.g. applied when waiting for requested
          acknowledgements via the `requested-acks` param. Can be specified without unit (then seconds are assumed) or
          together with `s`, `ms` or `m` unit. Example: `42s`, `1m`.

          The default (if omitted) timeout is `10s`. Maximum value: `60s`.

          A value of `0` applies fire and forget semantics for the command resulting in setting `response-required=false`.
        explode: true
        in: query
        name: timeout
        required: false
        schema:
          type: string
        style: form
      - description: |-
          Defines whether a response is required to the API call or not - if set to `false` the response will directly
          sent back with a status code of `202` (Accepted).

          The default (if ommited) response is `true`.
        explode: true
        in: query
        name: response-required
        required: false
        schema:
          type: boolean
        style: form
      requestBody:
        content:
          application/json:
            example:
              entries:
                DEFAULT:
                  subjects:
                    '{{ request:subjectId }}':
                      type: bosch-id
                  resources:
                    policy:/:
                      grant:
                      - READ
                      - WRITE
                      revoke: []
                    thing:/:
                      grant:
                      - READ
                      - WRITE
                      revoke: []
                    message:/:
                      grant:
                      - READ
                      - WRITE
                      revoke: []
            schema:
              $ref: '#/components/schemas/Policy'
        description: |-
          JSON representation of the policy.
          Use the placeholder `{{ request:subjectId }}` in order to let the
          backend insert the authenticated subjectId of the HTTP request.
        required: true
      responses:
        "201":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Policy'
          description: The policy was successfully created.
          headers:
            ETag:
              description: |-
                The (current server-side) ETag for this (sub-)resource. For top-level resources it is in the format
                "rev:[revision]", for sub-resources it has the format "hash:[calculated-hash]".
              explode: false
              schema:
                type: string
              style: simple
            Location:
              description: The location of the created policy resource
              explode: false
              schema:
                type: string
              style: simple
        "204":
          description: The policy was successfully updated.
          headers:
            ETag:
              description: |-
                The (current server-side) ETag for this (sub-)resource. For top-level resources it is in the format
                "rev:[revision]", for sub-resources it has the format "hash:[calculated-hash]".
              explode: false
              schema:
                type: string
              style: simple
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. Possible reasons:

              * the `policyId` does not conform to the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id))
              * the namespace is not registered for your solution
              * the JSON body of the policy to be created/modified is invalid
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to missing authentication.
        "402":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to exceeded data volume
            or exceeded transaction count.
        "403":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. Possible reasons:

              * the API Token is missing or invalid.
              * the caller has insufficient permissions.
                You need `WRITE` permission on the root `policy:/` resource,
                without any revoke in a deeper path of the policy resource.
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. The policy with the given ID was
            not found in the context of the authenticated user.
        "412":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            A precondition for reading or writing the (sub-)resource failed. This will happen for write requests, if you
            specified an If-Match or If-None-Match header, which fails the precondition check against the current ETag of
            the (sub-)resource. For read requests, this error may only happen for a failing If-Match header. In case of a
            failing If-None-Match header for a read request, status 304 will be returned instead.
          headers:
            ETag:
              description: |-
                The (current server-side) ETag for this (sub-)resource. For top-level resources it is in the format
                "rev:[revision]", for sub-resources it has the format "hash:[calculated-hash]".
              explode: false
              schema:
                type: string
              style: simple
        "413":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The created or modified entity is larger than the accepted
            limit of 100 kB.
      summary: Create or update a policy with a specified ID
      tags:
      - Policies
  /policies/{policyId}/entries:
    get:
      description: |-
        Returns all policy entries of the policy identified by the `policyId`
        path parameter.
      parameters:
      - description: |-
          The ID of the policy needs to follow the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).

          The namespace needs to:
          * conform to the reverse domain name notation
          * be registered for your solution
        explode: false
        in: path
        name: policyId
        required: true
        schema:
          type: string
        style: simple
      - description: |-
          The `If-Match` header which has to conform to RFC-7232 (Conditional Requests). Common usages are:
            * optimistic locking by specifying the `ETag` from a previous HTTP response, e.g. `If-Match: "hash:a75ece4e"`
            * retrieving or modifying a resource only if it already exists, e.g. `If-Match: *`
        explode: false
        in: header
        name: If-Match
        required: false
        schema:
          type: string
        style: simple
      - description: 'The `If-None-Match` header, which has to conform to RFC-7232
          (Conditional Requests). A common usage scenario is to modify a resource
          only if it does not yet exist, thus to create it, by specifying `If-None-Match:
          *`.'
        explode: false
        in: header
        name: If-None-Match
        required: false
        schema:
          type: string
        style: simple
      - description: |-
          Defines how long the backend should wait for completion of the request, e.g. applied when waiting for requested
          acknowledgements via the `requested-acks` param. Can be specified without unit (then seconds are assumed) or
          together with `s`, `ms` or `m` unit. Example: `42s`, `1m`.

          The default (if omitted) timeout is `10s`. Maximum value: `60s`.

          A value of `0` applies fire and forget semantics for the command resulting in setting `response-required=false`.
        explode: true
        in: query
        name: timeout
        required: false
        schema:
          type: string
        style: form
      responses:
        "200":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/PolicyEntries'
          description: |-
            The request successfully returned completed and returned are the
            policy entries.
          headers:
            ETag:
              description: |-
                The (current server-side) ETag for this (sub-)resource. For top-level resources it is in the format
                "rev:[revision]", for sub-resources it has the format "hash:[calculated-hash]".
              explode: false
              schema:
                type: string
              style: simple
        "304":
          description: |-
            The (sub-)resource has not been modified. This happens if you specified a If-None-Match header, which
             matches the current ETag of the (sub-)resource.
          headers:
            ETag:
              description: |-
                The (current server-side) ETag for this (sub-)resource. For top-level resources it is in the format
                "rev:[revision]", for sub-resources it has the format "hash:[calculated-hash]".
              explode: false
              schema:
                type: string
              style: simple
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. Possible reasons:

              * the `policyId` does not conform to the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id))
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to missing authentication.
        "402":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to exceeded transaction
            count.
        "403":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to a missing or invalid
            API Token.
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. The policy with the given ID was
            not found in the context of the authenticated user.
        "412":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            A precondition for reading or writing the (sub-)resource failed. This will happen for write requests, if you
            specified an If-Match or If-None-Match header, which fails the precondition check against the current ETag of
            the (sub-)resource. For read requests, this error may only happen for a failing If-Match header. In case of a
            failing If-None-Match header for a read request, status 304 will be returned instead.
          headers:
            ETag:
              description: |-
                The (current server-side) ETag for this (sub-)resource. For top-level resources it is in the format
                "rev:[revision]", for sub-resources it has the format "hash:[calculated-hash]".
              explode: false
              schema:
                type: string
              style: simple
      summary: Retrieve the entries of a specific policy
      tags:
      - Policies
    put:
      description: |-
        Modify the policy entries of the policy identified by the `policyId`
        path parameter.

        Note: Take care to not lock yourself out. Use the placeholder {{ request:subjectId }}
        in order to let the backend insert the authenticated subjectId of the HTTP request.
      parameters:
      - description: |-
          The ID of the policy needs to follow the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).

          The namespace needs to:
          * conform to the reverse domain name notation
          * be registered for your solution
        explode: false
        in: path
        name: policyId
        required: true
        schema:
          type: string
        style: simple
      - description: |-
          The `If-Match` header which has to conform to RFC-7232 (Conditional Requests). Common usages are:
            * optimistic locking by specifying the `ETag` from a previous HTTP response, e.g. `If-Match: "hash:a75ece4e"`
            * retrieving or modifying a resource only if it already exists, e.g. `If-Match: *`
        explode: false
        in: header
        name: If-Match
        required: false
        schema:
          type: string
        style: simple
      - description: 'The `If-None-Match` header, which has to conform to RFC-7232
          (Conditional Requests). A common usage scenario is to modify a resource
          only if it does not yet exist, thus to create it, by specifying `If-None-Match:
          *`.'
        explode: false
        in: header
        name: If-None-Match
        required: false
        schema:
          type: string
        style: simple
      - description: |-
          Defines how long the backend should wait for completion of the request, e.g. applied when waiting for requested
          acknowledgements via the `requested-acks` param. Can be specified without unit (then seconds are assumed) or
          together with `s`, `ms` or `m` unit. Example: `42s`, `1m`.

          The default (if omitted) timeout is `10s`. Maximum value: `60s`.

          A value of `0` applies fire and forget semantics for the command resulting in setting `response-required=false`.
        explode: true
        in: query
        name: timeout
        required: false
        schema:
          type: string
        style: form
      - description: |-
          Defines whether a response is required to the API call or not - if set to `false` the response will directly
          sent back with a status code of `202` (Accepted).

          The default (if ommited) response is `true`.
        explode: true
        in: query
        name: response-required
        required: false
        schema:
          type: boolean
        style: form
      requestBody:
        content:
          application/json:
            example:
              DEFAULT:
                subjects:
                  '{{ request:subjectId }}':
                    type: bosch-id
                resources:
                  policy:/:
                    grant:
                    - READ
                    - WRITE
                    revoke: []
                  thing:/:
                    grant:
                    - READ
                    - WRITE
                    revoke: []
                  message:/:
                    grant:
                    - READ
                    - WRITE
                    revoke: []
            schema:
              $ref: '#/components/schemas/PolicyEntries'
        description: |-
          JSON representation of the policy entries.
          Use the placeholder `{{ request:subjectId }}` in order to let the
          backend insert the authenticated subjectId of the HTTP request.
        required: true
      responses:
        "204":
          description: The policy entries were successfully updated.
          headers:
            ETag:
              description: |-
                The (current server-side) ETag for this (sub-)resource. For top-level resources it is in the format
                "rev:[revision]", for sub-resources it has the format "hash:[calculated-hash]".
              explode: false
              schema:
                type: string
              style: simple
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. Possible reasons:

              * the `policyId` does not conform to the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id))
              * the JSON body of the policy to be created/modified is invalid
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to missing authentication.
        "402":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to exceeded data volume
            or exceeded transaction count.
        "403":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. Possible reasons:

            * the API Token is missing or invalid
            * the caller has insufficient permissions.
              You need `WRITE` permission on the `policy:/entries` resource,
              without any revoke in a deeper path of the policy resource.
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. The policy with the given ID was
            not found in the context of the authenticated user.
        "412":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            A precondition for reading or writing the (sub-)resource failed. This will happen for write requests, if you
            specified an If-Match or If-None-Match header, which fails the precondition check against the current ETag of
            the (sub-)resource. For read requests, this error may only happen for a failing If-Match header. In case of a
            failing If-None-Match header for a read request, status 304 will be returned instead.
          headers:
            ETag:
              description: |-
                The (current server-side) ETag for this (sub-)resource. For top-level resources it is in the format
                "rev:[revision]", for sub-resources it has the format "hash:[calculated-hash]".
              explode: false
              schema:
                type: string
              style: simple
        "413":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The created or modified entity is larger than the accepted
            limit of 100 kB.
      summary: Modify the entries of a specific policy
      tags:
      - Policies
  /policies/{policyId}/entries/{label}:
    delete:
      description: |-
        Deletes the entry of the policy identified by the `policyId` path
        parameter and with the label identified by the `label` path parameter.
      parameters:
      - description: |-
          The ID of the policy needs to follow the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).

          The namespace needs to:
          * conform to the reverse domain name notation
          * be registered for your solution
        explode: false
        in: path
        name: policyId
        required: true
        schema:
          type: string
        style: simple
      - description: The label of a policy entry
        explode: false
        in: path
        name: label
        required: true
        schema:
          type: string
        style: simple
      - description: |-
          The `If-Match` header which has to conform to RFC-7232 (Conditional Requests). Common usages are:
            * optimistic locking by specifying the `ETag` from a previous HTTP response, e.g. `If-Match: "hash:a75ece4e"`
            * retrieving or modifying a resource only if it already exists, e.g. `If-Match: *`
        explode: false
        in: header
        name: If-Match
        required: false
        schema:
          type: string
        style: simple
      - description: 'The `If-None-Match` header, which has to conform to RFC-7232
          (Conditional Requests). A common usage scenario is to modify a resource
          only if it does not yet exist, thus to create it, by specifying `If-None-Match:
          *`.'
        explode: false
        in: header
        name: If-None-Match
        required: false
        schema:
          type: string
        style: simple
      - description: |-
          Defines how long the backend should wait for completion of the request, e.g. applied when waiting for requested
          acknowledgements via the `requested-acks` param. Can be specified without unit (then seconds are assumed) or
          together with `s`, `ms` or `m` unit. Example: `42s`, `1m`.

          The default (if omitted) timeout is `10s`. Maximum value: `60s`.

          A value of `0` applies fire and forget semantics for the command resulting in setting `response-required=false`.
        explode: true
        in: query
        name: timeout
        required: false
        schema:
          type: string
        style: form
      - description: |-
          Defines whether a response is required to the API call or not - if set to `false` the response will directly
          sent back with a status code of `202` (Accepted).

          The default (if ommited) response is `true`.
        explode: true
        in: query
        name: response-required
        required: false
        schema:
          type: boolean
        style: form
      responses:
        "204":
          description: The policy entry was successfully deleted.
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. Possible reasons:

              * the `policyId` does not conform to the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id))
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to missing authentication.
        "402":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to exceeded transaction
            count.
        "403":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. Possible reasons:

             * the API Token is missing or invalid
             * the caller has insufficient permissions.
               You need `WRITE` permission on the `policy:/entries/{label}` resource,
               without any revoke in a deeper path of the policy resource.
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. The policy with the given ID was
            not found in the context of the authenticated user.
        "412":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            A precondition for reading or writing the (sub-)resource failed. This will happen for write requests, if you
            specified an If-Match or If-None-Match header, which fails the precondition check against the current ETag of
            the (sub-)resource. For read requests, this error may only happen for a failing If-Match header. In case of a
            failing If-None-Match header for a read request, status 304 will be returned instead.
          headers:
            ETag:
              description: |-
                The (current server-side) ETag for this (sub-)resource. For top-level resources it is in the format
                "rev:[revision]", for sub-resources it has the format "hash:[calculated-hash]".
              explode: false
              schema:
                type: string
              style: simple
      summary: Delete the entries of a specific Label of a specific policy
      tags:
      - Policies
    get:
      description: |-
        Returns all entries (subjects, resources, etc.) of the policy identified by the `policyId` path
        parameter, and by the `label` path parameter.
        Example label: DEFAULT.
      parameters:
      - description: |-
          The ID of the policy needs to follow the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).

          The namespace needs to:
          * conform to the reverse domain name notation
          * be registered for your solution
        explode: false
        in: path
        name: policyId
        required: true
        schema:
          type: string
        style: simple
      - description: The label of a policy entry
        explode: false
        in: path
        name: label
        required: true
        schema:
          type: string
        style: simple
      - description: |-
          The `If-Match` header which has to conform to RFC-7232 (Conditional Requests). Common usages are:
            * optimistic locking by specifying the `ETag` from a previous HTTP response, e.g. `If-Match: "hash:a75ece4e"`
            * retrieving or modifying a resource only if it already exists, e.g. `If-Match: *`
        explode: false
        in: header
        name: If-Match
        required: false
        schema:
          type: string
        style: simple
      - description: 'The `If-None-Match` header, which has to conform to RFC-7232
          (Conditional Requests). A common usage scenario is to modify a resource
          only if it does not yet exist, thus to create it, by specifying `If-None-Match:
          *`.'
        explode: false
        in: header
        name: If-None-Match
        required: false
        schema:
          type: string
        style: simple
      - description: |-
          Defines how long the backend should wait for completion of the request, e.g. applied when waiting for requested
          acknowledgements via the `requested-acks` param. Can be specified without unit (then seconds are assumed) or
          together with `s`, `ms` or `m` unit. Example: `42s`, `1m`.

          The default (if omitted) timeout is `10s`. Maximum value: `60s`.

          A value of `0` applies fire and forget semantics for the command resulting in setting `response-required=false`.
        explode: true
        in: query
        name: timeout
        required: false
        schema:
          type: string
        style: form
      responses:
        "200":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/PolicyEntry'
          description: |-
            The request successfully returned completed and returned is the
            policy entry.
          headers:
            ETag:
              description: |-
                The (current server-side) ETag for this (sub-)resource. For top-level resources it is in the format
                "rev:[revision]", for sub-resources it has the format "hash:[calculated-hash]".
              explode: false
              schema:
                type: string
              style: simple
        "304":
          description: |-
            The (sub-)resource has not been modified. This happens if you specified a If-None-Match header, which
             matches the current ETag of the (sub-)resource.
          headers:
            ETag:
              description: |-
                The (current server-side) ETag for this (sub-)resource. For top-level resources it is in the format
                "rev:[revision]", for sub-resources it has the format "hash:[calculated-hash]".
              explode: false
              schema:
                type: string
              style: simple
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. Possible reasons:

              * the `policyId` does not conform to the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id))
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to missing authentication.
        "402":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to exceeded transaction
            count.
        "403":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to a missing or invalid
            API Token.
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. The policy with the given ID or
            the policy entry was not found in the context of the authenticated
            user.
        "412":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            A precondition for reading or writing the (sub-)resource failed. This will happen for write requests, if you
            specified an If-Match or If-None-Match header, which fails the precondition check against the current ETag of
            the (sub-)resource. For read requests, this error may only happen for a failing If-Match header. In case of a
            failing If-None-Match header for a read request, status 304 will be returned instead.
          headers:
            ETag:
              description: |-
                The (current server-side) ETag for this (sub-)resource. For top-level resources it is in the format
                "rev:[revision]", for sub-resources it has the format "hash:[calculated-hash]".
              explode: false
              schema:
                type: string
              style: simple
      summary: Retrieve the entries of a specific Label of a specific policy
      tags:
      - Policies
    put:
      description: |-
        Create or modify the policy entry identified by the
        `policyId` path parameter and with the label identified by the `label`
        path parameter.
        * If you specify a new label, the respective policy entry will be created
        * If you specify an existig label, the respective policy entry will be updated
      parameters:
      - description: |-
          The ID of the policy needs to follow the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).

          The namespace needs to:
          * conform to the reverse domain name notation
          * be registered for your solution
        explode: false
        in: path
        name: policyId
        required: true
        schema:
          type: string
        style: simple
      - description: The label of a policy entry
        explode: false
        in: path
        name: label
        required: true
        schema:
          type: string
        style: simple
      - description: |-
          The `If-Match` header which has to conform to RFC-7232 (Conditional Requests). Common usages are:
            * optimistic locking by specifying the `ETag` from a previous HTTP response, e.g. `If-Match: "hash:a75ece4e"`
            * retrieving or modifying a resource only if it already exists, e.g. `If-Match: *`
        explode: false
        in: header
        name: If-Match
        required: false
        schema:
          type: string
        style: simple
      - description: 'The `If-None-Match` header, which has to conform to RFC-7232
          (Conditional Requests). A common usage scenario is to modify a resource
          only if it does not yet exist, thus to create it, by specifying `If-None-Match:
          *`.'
        explode: false
        in: header
        name: If-None-Match
        required: false
        schema:
          type: string
        style: simple
      - description: |-
          Defines how long the backend should wait for completion of the request, e.g. applied when waiting for requested
          acknowledgements via the `requested-acks` param. Can be specified without unit (then seconds are assumed) or
          together with `s`, `ms` or `m` unit. Example: `42s`, `1m`.

          The default (if omitted) timeout is `10s`. Maximum value: `60s`.

          A value of `0` applies fire and forget semantics for the command resulting in setting `response-required=false`.
        explode: true
        in: query
        name: timeout
        required: false
        schema:
          type: string
        style: form
      - description: |-
          Defines whether a response is required to the API call or not - if set to `false` the response will directly
          sent back with a status code of `202` (Accepted).

          The default (if ommited) response is `true`.
        explode: true
        in: query
        name: response-required
        required: false
        schema:
          type: boolean
        style: form
      requestBody:
        content:
          application/json:
            example:
              subjects:
                '{{ request:subjectId }}':
                  type: bosch-id
              resources:
                policy:/:
                  grant:
                  - READ
                  - WRITE
                  revoke: []
                thing:/:
                  grant:
                  - READ
                  - WRITE
                  revoke: []
                message:/:
                  grant:
                  - READ
                  - WRITE
                  revoke: []
            schema:
              $ref: '#/components/schemas/PolicyEntry'
        description: |-
          JSON representation of the policy entry.
          Use the placeholder `{{ request:subjectId }}` in order to let the
          backend insert the authenticated subjectId of the HTTP request.

          ### Example
          Given your policy "com.acme.coffeemaker:policy-01" only has the
          DEFAULT entry, and you want to add a "Consumer" section which additionally allows USER-01
          (managed within a Bosch IoT Permissions service instance) to
          *read* the thing and to trigger a "makeCoffee" operation (i.e. POST such a message - see
          POST /things/{thingId}/inbox/messages/{messageSubject}).

          Set the label value to **Consumer** and the following request body:
          ```
          {
             "subjects": {
               "iot-permissions:USER-01": {
                 "type": "iot-permissions-userid"
               },
             },
             "resources": {
               "thing:/": {
                 "grant": [
                   "READ"
                 ],
                 "revoke": []
               },
               "message:/": {
                 "grant": [
                   "WRITE"
                 ],
                 "revoke": []
               }
             }
           }
          ```
        required: true
      responses:
        "201":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/PolicyEntry'
          description: The policy entry was successfully created.
          headers:
            ETag:
              description: |-
                The (current server-side) ETag for this (sub-)resource. For top-level resources it is in the format
                "rev:[revision]", for sub-resources it has the format "hash:[calculated-hash]".
              explode: false
              schema:
                type: string
              style: simple
            Location:
              description: The location of the created policy entry
              explode: false
              schema:
                type: string
              style: simple
        "204":
          description: The policy entry was successfully updated.
          headers:
            ETag:
              description: |-
                The (current server-side) ETag for this (sub-)resource. For top-level resources it is in the format
                "rev:[revision]", for sub-resources it has the format "hash:[calculated-hash]".
              explode: false
              schema:
                type: string
              style: simple
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. Possible reasons:

              * the `policyId` does not conform to the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id))
            * the JSON body of the policy entry to be created/modified is invalid
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to missing authentication.
        "402":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to exceeded data volume
            or exceeded transaction count.
        "403":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. Possible reasons:

              * the API Token is missing or invalid
              * the caller has insufficient permissions.
                You need `WRITE` permission on the `policy:/entries/{label}` resource,
                without any revoke in a deeper path of the policy resource.
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. The policy with the given ID was
            not found in the context of the authenticated user.
        "412":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            A precondition for reading or writing the (sub-)resource failed. This will happen for write requests, if you
            specified an If-Match or If-None-Match header, which fails the precondition check against the current ETag of
            the (sub-)resource. For read requests, this error may only happen for a failing If-Match header. In case of a
            failing If-None-Match header for a read request, status 304 will be returned instead.
          headers:
            ETag:
              description: |-
                The (current server-side) ETag for this (sub-)resource. For top-level resources it is in the format
                "rev:[revision]", for sub-resources it has the format "hash:[calculated-hash]".
              explode: false
              schema:
                type: string
              style: simple
        "413":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The created or modified entity is larger than the accepted
            limit of 100 kB.
      summary: Create or modify the entries of a specific Label of a specific policy
      tags:
      - Policies
  /policies/{policyId}/entries/{label}/subjects:
    get:
      description: |-
        Returns all subject entries of the policy identified by the
        `policyId` path parameter, and by the `label`
        path parameter.
      parameters:
      - description: |-
          The ID of the policy needs to follow the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).

          The namespace needs to:
          * conform to the reverse domain name notation
          * be registered for your solution
        explode: false
        in: path
        name: policyId
        required: true
        schema:
          type: string
        style: simple
      - description: The label of a policy entry
        explode: false
        in: path
        name: label
        required: true
        schema:
          type: string
        style: simple
      - description: |-
          The `If-Match` header which has to conform to RFC-7232 (Conditional Requests). Common usages are:
            * optimistic locking by specifying the `ETag` from a previous HTTP response, e.g. `If-Match: "hash:a75ece4e"`
            * retrieving or modifying a resource only if it already exists, e.g. `If-Match: *`
        explode: false
        in: header
        name: If-Match
        required: false
        schema:
          type: string
        style: simple
      - description: 'The `If-None-Match` header, which has to conform to RFC-7232
          (Conditional Requests). A common usage scenario is to modify a resource
          only if it does not yet exist, thus to create it, by specifying `If-None-Match:
          *`.'
        explode: false
        in: header
        name: If-None-Match
        required: false
        schema:
          type: string
        style: simple
      - description: |-
          Defines how long the backend should wait for completion of the request, e.g. applied when waiting for requested
          acknowledgements via the `requested-acks` param. Can be specified without unit (then seconds are assumed) or
          together with `s`, `ms` or `m` unit. Example: `42s`, `1m`.

          The default (if omitted) timeout is `10s`. Maximum value: `60s`.

          A value of `0` applies fire and forget semantics for the command resulting in setting `response-required=false`.
        explode: true
        in: query
        name: timeout
        required: false
        schema:
          type: string
        style: form
      responses:
        "200":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Subjects'
          description: The request successfully returned. The subjects are returned.
          headers:
            ETag:
              description: |-
                The (current server-side) ETag for this (sub-)resource. For top-level resources it is in the format
                "rev:[revision]", for sub-resources it has the format "hash:[calculated-hash]".
              explode: false
              schema:
                type: string
              style: simple
        "304":
          description: |-
            The (sub-)resource has not been modified. This happens if you specified a If-None-Match header, which
             matches the current ETag of the (sub-)resource.
          headers:
            ETag:
              description: |-
                The (current server-side) ETag for this (sub-)resource. For top-level resources it is in the format
                "rev:[revision]", for sub-resources it has the format "hash:[calculated-hash]".
              explode: false
              schema:
                type: string
              style: simple
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. Possible reasons:

               * the `policyId` does not conform to the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id))
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to missing authentication.
        "402":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to exceeded transaction
            count.
        "403":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to a missing or invalid
            API Token.
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. The policy with the given ID or
            the policy entry was not found in the context of the authenticated
            user.
        "412":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            A precondition for reading or writing the (sub-)resource failed. This will happen for write requests, if you
            specified an If-Match or If-None-Match header, which fails the precondition check against the current ETag of
            the (sub-)resource. For read requests, this error may only happen for a failing If-Match header. In case of a
            failing If-None-Match header for a read request, status 304 will be returned instead.
          headers:
            ETag:
              description: |-
                The (current server-side) ETag for this (sub-)resource. For top-level resources it is in the format
                "rev:[revision]", for sub-resources it has the format "hash:[calculated-hash]".
              explode: false
              schema:
                type: string
              style: simple
      summary: Retrieve all Subjects for a specific Label of a specific policy
      tags:
      - Policies
    put:
      description: |-
        Create or modify at once ALL subjects of the policy entry identified
        by the `policyId` path parameter, and by the `label` path parameter.

        ### Example - delete all subjects
        To delete all subjects set an empty body { }

        ### Example - entities of Bosch IoT Permissions
        To add a user, a goup, and a role managed within Bosch IoT Permissions

        ```
        {
          "iot-permissions:ID-user": {
            "type": "iot-permissions-userid"
          },
          "iot-permissions:ID-group": {
            "type": "iot-permissions-groupid"
          },
          "iot-permissions:ID-role": {
            "type": "iot-permissions-roleid"
          }
        }
        ```

        ### Example - technical clients
        To add a technical client
        ```
        {
           "iot-things:Your-Things-Solution-ID-user:your-postfix": {
             "type": "iot-things-clientid"
           },
           "iot-integration:your-Things-solution-ID-user:bosch-iot-hub": {
             "type": "hub-amqp-clientid"
           },
           "iot-suite:service:iot-things-eu-1:Your-Things-Solution-ID_things/full-access": {
             "type": "suite-auth"
           }
        }
        ```
      parameters:
      - description: |-
          The ID of the policy needs to follow the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).

          The namespace needs to:
          * conform to the reverse domain name notation
          * be registered for your solution
        explode: false
        in: path
        name: policyId
        required: true
        schema:
          type: string
        style: simple
      - description: The label of a policy entry
        explode: false
        in: path
        name: label
        required: true
        schema:
          type: string
        style: simple
      - description: |-
          The `If-Match` header which has to conform to RFC-7232 (Conditional Requests). Common usages are:
            * optimistic locking by specifying the `ETag` from a previous HTTP response, e.g. `If-Match: "hash:a75ece4e"`
            * retrieving or modifying a resource only if it already exists, e.g. `If-Match: *`
        explode: false
        in: header
        name: If-Match
        required: false
        schema:
          type: string
        style: simple
      - description: 'The `If-None-Match` header, which has to conform to RFC-7232
          (Conditional Requests). A common usage scenario is to modify a resource
          only if it does not yet exist, thus to create it, by specifying `If-None-Match:
          *`.'
        explode: false
        in: header
        name: If-None-Match
        required: false
        schema:
          type: string
        style: simple
      - description: |-
          Defines how long the backend should wait for completion of the request, e.g. applied when waiting for requested
          acknowledgements via the `requested-acks` param. Can be specified without unit (then seconds are assumed) or
          together with `s`, `ms` or `m` unit. Example: `42s`, `1m`.

          The default (if omitted) timeout is `10s`. Maximum value: `60s`.

          A value of `0` applies fire and forget semantics for the command resulting in setting `response-required=false`.
        explode: true
        in: query
        name: timeout
        required: false
        schema:
          type: string
        style: form
      - description: |-
          Defines whether a response is required to the API call or not - if set to `false` the response will directly
          sent back with a status code of `202` (Accepted).

          The default (if ommited) response is `true`.
        explode: true
        in: query
        name: response-required
        required: false
        schema:
          type: boolean
        style: form
      requestBody:
        content:
          application/json:
            example: {}
            schema:
              $ref: '#/components/schemas/Subjects'
        description: |-
          JSON representation of the Subjects.


          Use the placeholder `{{ request:subjectId }}` in order to let the
          backend insert the authenticated subjectId of the HTTP request.
        required: true
      responses:
        "204":
          description: The Subjects were successfully created or updated.
          headers:
            ETag:
              description: |-
                The (current server-side) ETag for this (sub-)resource. For top-level resources it is in the format
                "rev:[revision]", for sub-resources it has the format "hash:[calculated-hash]".
              explode: false
              schema:
                type: string
              style: simple
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. Possible reasons:

               * the `policyId` does not conform to the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id))
             * the JSON body of the policy subjects to be created/modified is invalid
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to missing authentication.
        "402":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to exceeded data volume
            or exceeded transaction count.
        "403":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. Possible reasons:

            * the API Token is missing or invalid
            * the caller has insufficient permissions.
              You need `WRITE` permission on the `policy:/entries/{label}/subjects` resource,
              without any revoke in a deeper path of the policy resource.
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. The policy with the given ID was
            not found in the context of the authenticated user.
        "412":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            A precondition for reading or writing the (sub-)resource failed. This will happen for write requests, if you
            specified an If-Match or If-None-Match header, which fails the precondition check against the current ETag of
            the (sub-)resource. For read requests, this error may only happen for a failing If-Match header. In case of a
            failing If-None-Match header for a read request, status 304 will be returned instead.
          headers:
            ETag:
              description: |-
                The (current server-side) ETag for this (sub-)resource. For top-level resources it is in the format
                "rev:[revision]", for sub-resources it has the format "hash:[calculated-hash]".
              explode: false
              schema:
                type: string
              style: simple
        "413":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The created or modified entity is larger than the accepted
            limit of 100 kB.
      summary: Create or modify all Subjects for a specific Label of a specific policy
      tags:
      - Policies
  /policies/{policyId}/entries/{label}/subjects/{subjectId}:
    delete:
      description: |-
        Deletes the subject with ID `subjectId` from the policy identified
        by the `policyId` path parameter and
        by the `label` path parameter.

        Note: If the subject is used in other labels, it will not be deleted there,
        i.e. it will not lose those permissions, but only the permissions defined in the
        label specified at this path.
      parameters:
      - description: |-
          The ID of the policy needs to follow the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).

          The namespace needs to:
          * conform to the reverse domain name notation
          * be registered for your solution
        explode: false
        in: path
        name: policyId
        required: true
        schema:
          type: string
        style: simple
      - description: The label of a policy entry
        explode: false
        in: path
        name: label
        required: true
        schema:
          type: string
        style: simple
      - description: The ID of an (Authorization) Subject
        explode: false
        in: path
        name: subjectId
        required: true
        schema:
          type: string
        style: simple
      - description: |-
          The `If-Match` header which has to conform to RFC-7232 (Conditional Requests). Common usages are:
            * optimistic locking by specifying the `ETag` from a previous HTTP response, e.g. `If-Match: "hash:a75ece4e"`
            * retrieving or modifying a resource only if it already exists, e.g. `If-Match: *`
        explode: false
        in: header
        name: If-Match
        required: false
        schema:
          type: string
        style: simple
      - description: 'The `If-None-Match` header, which has to conform to RFC-7232
          (Conditional Requests). A common usage scenario is to modify a resource
          only if it does not yet exist, thus to create it, by specifying `If-None-Match:
          *`.'
        explode: false
        in: header
        name: If-None-Match
        required: false
        schema:
          type: string
        style: simple
      - description: |-
          Defines how long the backend should wait for completion of the request, e.g. applied when waiting for requested
          acknowledgements via the `requested-acks` param. Can be specified without unit (then seconds are assumed) or
          together with `s`, `ms` or `m` unit. Example: `42s`, `1m`.

          The default (if omitted) timeout is `10s`. Maximum value: `60s`.

          A value of `0` applies fire and forget semantics for the command resulting in setting `response-required=false`.
        explode: true
        in: query
        name: timeout
        required: false
        schema:
          type: string
        style: form
      - description: |-
          Defines whether a response is required to the API call or not - if set to `false` the response will directly
          sent back with a status code of `202` (Accepted).

          The default (if ommited) response is `true`.
        explode: true
        in: query
        name: response-required
        required: false
        schema:
          type: boolean
        style: form
      responses:
        "204":
          description: The Subject was successfully deleted.
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. Possible reasons:

              * the `policyId` does not conform to the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id))
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to missing authentication.
        "402":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to exceeded transaction
            count.
        "403":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. Possible reasons:

            * the API Token is missing or invalid
            * the caller has insufficient permissions.
              You need `WRITE` permission on the root `policy:/entries/{label}/subjects/{subjectId}` resource,
              without any revoke in a deeper path of the policy resource.
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. The policy with the given ID,
            the policy entry or the Subject was not found in the context of the
            authenticated user.
        "412":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            A precondition for reading or writing the (sub-)resource failed. This will happen for write requests, if you
            specified an If-Match or If-None-Match header, which fails the precondition check against the current ETag of
            the (sub-)resource. For read requests, this error may only happen for a failing If-Match header. In case of a
            failing If-None-Match header for a read request, status 304 will be returned instead.
          headers:
            ETag:
              description: |-
                The (current server-side) ETag for this (sub-)resource. For top-level resources it is in the format
                "rev:[revision]", for sub-resources it has the format "hash:[calculated-hash]".
              explode: false
              schema:
                type: string
              style: simple
      summary: Delete one specific Subject for a specific Label of a specific policy
      tags:
      - Policies
    get:
      description: |-
        Returns the subject with ID `subjectId` of the policy entry identified
        by the `policyId` path parameter, and by the `label` path parameter.
      parameters:
      - description: |-
          The ID of the policy needs to follow the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).

          The namespace needs to:
          * conform to the reverse domain name notation
          * be registered for your solution
        explode: false
        in: path
        name: policyId
        required: true
        schema:
          type: string
        style: simple
      - description: The label of a policy entry
        explode: false
        in: path
        name: label
        required: true
        schema:
          type: string
        style: simple
      - description: The ID of an (Authorization) Subject
        explode: false
        in: path
        name: subjectId
        required: true
        schema:
          type: string
        style: simple
      - description: |-
          The `If-Match` header which has to conform to RFC-7232 (Conditional Requests). Common usages are:
            * optimistic locking by specifying the `ETag` from a previous HTTP response, e.g. `If-Match: "hash:a75ece4e"`
            * retrieving or modifying a resource only if it already exists, e.g. `If-Match: *`
        explode: false
        in: header
        name: If-Match
        required: false
        schema:
          type: string
        style: simple
      - description: 'The `If-None-Match` header, which has to conform to RFC-7232
          (Conditional Requests). A common usage scenario is to modify a resource
          only if it does not yet exist, thus to create it, by specifying `If-None-Match:
          *`.'
        explode: false
        in: header
        name: If-None-Match
        required: false
        schema:
          type: string
        style: simple
      - description: |-
          Defines how long the backend should wait for completion of the request, e.g. applied when waiting for requested
          acknowledgements via the `requested-acks` param. Can be specified without unit (then seconds are assumed) or
          together with `s`, `ms` or `m` unit. Example: `42s`, `1m`.

          The default (if omitted) timeout is `10s`. Maximum value: `60s`.

          A value of `0` applies fire and forget semantics for the command resulting in setting `response-required=false`.
        explode: true
        in: query
        name: timeout
        required: false
        schema:
          type: string
        style: form
      responses:
        "200":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/SubjectEntry'
          description: |-
            The request successfully returned completed and returned is the
            Subject.
          headers:
            ETag:
              description: |-
                The (current server-side) ETag for this (sub-)resource. For top-level resources it is in the format
                "rev:[revision]", for sub-resources it has the format "hash:[calculated-hash]".
              explode: false
              schema:
                type: string
              style: simple
        "304":
          description: |-
            The (sub-)resource has not been modified. This happens if you specified a If-None-Match header, which
             matches the current ETag of the (sub-)resource.
          headers:
            ETag:
              description: |-
                The (current server-side) ETag for this (sub-)resource. For top-level resources it is in the format
                "rev:[revision]", for sub-resources it has the format "hash:[calculated-hash]".
              explode: false
              schema:
                type: string
              style: simple
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. Possible reasons:

              * the `policyId` does not conform to the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id))
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to missing authentication.
        "402":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to exceeded transaction
            count.
        "403":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to a missing or invalid
            API Token.
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. The policy with the given ID,
            the policy entry or the Subject was not found in the context of the
            authenticated user.
        "412":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            A precondition for reading or writing the (sub-)resource failed. This will happen for write requests, if you
            specified an If-Match or If-None-Match header, which fails the precondition check against the current ETag of
            the (sub-)resource. For read requests, this error may only happen for a failing If-Match header. In case of a
            failing If-None-Match header for a read request, status 304 will be returned instead.
          headers:
            ETag:
              description: |-
                The (current server-side) ETag for this (sub-)resource. For top-level resources it is in the format
                "rev:[revision]", for sub-resources it has the format "hash:[calculated-hash]".
              explode: false
              schema:
                type: string
              style: simple
      summary: Retrieve one specific Subject for a specific Label of a specific policy
      tags:
      - Policies
    put:
      description: |-
        Create or modify the subject with ID `subjectId` of the policy identified
        by the `policyId` path parameter, and
        by the `label` path parameter.

        ### Example -  add user managed within Bosch IoT Permissions
        To add a user managed within Bosch IoT Permissions, set the subjectId path to **iot-permissions:ID-user**
        and the body to  { "type": "iot-permissions-userid" }.
      parameters:
      - description: |-
          The ID of the policy needs to follow the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).

          The namespace needs to:
          * conform to the reverse domain name notation
          * be registered for your solution
        explode: false
        in: path
        name: policyId
        required: true
        schema:
          type: string
        style: simple
      - description: The label of a policy entry
        explode: false
        in: path
        name: label
        required: true
        schema:
          type: string
        style: simple
      - description: The ID of an (Authorization) Subject
        explode: false
        in: path
        name: subjectId
        required: true
        schema:
          type: string
        style: simple
      - description: |-
          The `If-Match` header which has to conform to RFC-7232 (Conditional Requests). Common usages are:
            * optimistic locking by specifying the `ETag` from a previous HTTP response, e.g. `If-Match: "hash:a75ece4e"`
            * retrieving or modifying a resource only if it already exists, e.g. `If-Match: *`
        explode: false
        in: header
        name: If-Match
        required: false
        schema:
          type: string
        style: simple
      - description: 'The `If-None-Match` header, which has to conform to RFC-7232
          (Conditional Requests). A common usage scenario is to modify a resource
          only if it does not yet exist, thus to create it, by specifying `If-None-Match:
          *`.'
        explode: false
        in: header
        name: If-None-Match
        required: false
        schema:
          type: string
        style: simple
      - description: |-
          Defines how long the backend should wait for completion of the request, e.g. applied when waiting for requested
          acknowledgements via the `requested-acks` param. Can be specified without unit (then seconds are assumed) or
          together with `s`, `ms` or `m` unit. Example: `42s`, `1m`.

          The default (if omitted) timeout is `10s`. Maximum value: `60s`.

          A value of `0` applies fire and forget semantics for the command resulting in setting `response-required=false`.
        explode: true
        in: query
        name: timeout
        required: false
        schema:
          type: string
        style: form
      - description: |-
          Defines whether a response is required to the API call or not - if set to `false` the response will directly
          sent back with a status code of `202` (Accepted).

          The default (if ommited) response is `true`.
        explode: true
        in: query
        name: response-required
        required: false
        schema:
          type: boolean
        style: form
      requestBody:
        content:
          application/json:
            example: {}
            schema:
              $ref: '#/components/schemas/SubjectEntry'
        description: JSON representation of the Subject
        required: true
      responses:
        "201":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/SubjectEntry'
          description: The Subject was successfully created.
          headers:
            ETag:
              description: |-
                The (current server-side) ETag for this (sub-)resource. For top-level resources it is in the format
                "rev:[revision]", for sub-resources it has the format "hash:[calculated-hash]".
              explode: false
              schema:
                type: string
              style: simple
            Location:
              description: The location of the created Subject
              explode: false
              schema:
                type: string
              style: simple
        "204":
          description: The Subject was successfully updated.
          headers:
            ETag:
              description: |-
                The (current server-side) ETag for this (sub-)resource. For top-level resources it is in the format
                "rev:[revision]", for sub-resources it has the format "hash:[calculated-hash]".
              explode: false
              schema:
                type: string
              style: simple
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. Possible reasons:

              * the `policyId` does not conform to the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)))
            * the JSON body of the policy subject to be created/modified is invalid.
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to missing authentication.
        "402":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to exceeded data volume
            or exceeded transaction count.
        "403":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. Possible reasons:

            * the API Token is missing or invalid
            * the caller has insufficient permissions.
              You need `WRITE` permission on the root `policy:/entries/{label}/subjects/{subjectId}` resource,
              without any revoke in a deeper path of the policy resource.
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. The policy with the given ID or
            the policy entry was not found in the context of the authenticated
            user.
        "412":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            A precondition for reading or writing the (sub-)resource failed. This will happen for write requests, if you
            specified an If-Match or If-None-Match header, which fails the precondition check against the current ETag of
            the (sub-)resource. For read requests, this error may only happen for a failing If-Match header. In case of a
            failing If-None-Match header for a read request, status 304 will be returned instead.
          headers:
            ETag:
              description: |-
                The (current server-side) ETag for this (sub-)resource. For top-level resources it is in the format
                "rev:[revision]", for sub-resources it has the format "hash:[calculated-hash]".
              explode: false
              schema:
                type: string
              style: simple
        "413":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The created or modified entity is larger than the accepted
            limit of 100 kB.
      summary: Create or modify one specific Subject for a specific Label of a specific
        policy
      tags:
      - Policies
  /policies/{policyId}/entries/{label}/resources:
    get:
      description: |-
        Returns all resource entries of the policy identified by
        the `policyId` path parameter,
        and by the `label` path parameter.
      parameters:
      - description: |-
          The ID of the policy needs to follow the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).

          The namespace needs to:
          * conform to the reverse domain name notation
          * be registered for your solution
        explode: false
        in: path
        name: policyId
        required: true
        schema:
          type: string
        style: simple
      - description: The label of a policy entry
        explode: false
        in: path
        name: label
        required: true
        schema:
          type: string
        style: simple
      - description: |-
          The `If-Match` header which has to conform to RFC-7232 (Conditional Requests). Common usages are:
            * optimistic locking by specifying the `ETag` from a previous HTTP response, e.g. `If-Match: "hash:a75ece4e"`
            * retrieving or modifying a resource only if it already exists, e.g. `If-Match: *`
        explode: false
        in: header
        name: If-Match
        required: false
        schema:
          type: string
        style: simple
      - description: 'The `If-None-Match` header, which has to conform to RFC-7232
          (Conditional Requests). A common usage scenario is to modify a resource
          only if it does not yet exist, thus to create it, by specifying `If-None-Match:
          *`.'
        explode: false
        in: header
        name: If-None-Match
        required: false
        schema:
          type: string
        style: simple
      - description: |-
          Defines how long the backend should wait for completion of the request, e.g. applied when waiting for requested
          acknowledgements via the `requested-acks` param. Can be specified without unit (then seconds are assumed) or
          together with `s`, `ms` or `m` unit. Example: `42s`, `1m`.

          The default (if omitted) timeout is `10s`. Maximum value: `60s`.

          A value of `0` applies fire and forget semantics for the command resulting in setting `response-required=false`.
        explode: true
        in: query
        name: timeout
        required: false
        schema:
          type: string
        style: form
      responses:
        "200":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Resources'
          description: The request successfully returned. The resources are returned.
          headers:
            ETag:
              description: |-
                The (current server-side) ETag for this (sub-)resource. For top-level resources it is in the format
                "rev:[revision]", for sub-resources it has the format "hash:[calculated-hash]".
              explode: false
              schema:
                type: string
              style: simple
        "304":
          description: |-
            The (sub-)resource has not been modified. This happens if you specified a If-None-Match header, which
             matches the current ETag of the (sub-)resource.
          headers:
            ETag:
              description: |-
                The (current server-side) ETag for this (sub-)resource. For top-level resources it is in the format
                "rev:[revision]", for sub-resources it has the format "hash:[calculated-hash]".
              explode: false
              schema:
                type: string
              style: simple
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. Possible reasons:

              * the `policyId` does not conform to the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id))
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to missing authentication.
        "402":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to exceeded transaction
            count.
        "403":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to a missing or invalid
            API Token.
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. The policy with the given ID or
            the policy entry was not found in the context of the authenticated
            user.
        "412":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            A precondition for reading or writing the (sub-)resource failed. This will happen for write requests, if you
            specified an If-Match or If-None-Match header, which fails the precondition check against the current ETag of
            the (sub-)resource. For read requests, this error may only happen for a failing If-Match header. In case of a
            failing If-None-Match header for a read request, status 304 will be returned instead.
          headers:
            ETag:
              description: |-
                The (current server-side) ETag for this (sub-)resource. For top-level resources it is in the format
                "rev:[revision]", for sub-resources it has the format "hash:[calculated-hash]".
              explode: false
              schema:
                type: string
              style: simple
      summary: Retrieve all Resources for a specific Label of a specific policy
      tags:
      - Policies
    put:
      description: |-
        Create or modify all resources of the policy
        identified by the `policyId` path parameter,
        and by the `label` path parameter.

        ### Delete all resource entries

        Set the empty body part, if you need to delete all resource entries: { }

        ### Set max permissions on all ressources
        ```
        {
                  "policy:/": {
                          "grant": [
                            "READ",
                            "WRITE"
                          ],
                          "revoke": []
                        },
                 "thing:/": {
                          "grant": [
                            "READ",
                            "WRITE"
                          ],
                          "revoke": []
                        },
                 "message:/": {
                          "grant": [
                            "READ",
                            "WRITE"
                          ],
                          "revoke": []
                        }
                      }
          }
          ```
          ### Allow to read all parts of a thing except the "confidential" feature
          ```
          {
                  "thing:/": {
                            "grant": [ "READ" ],
                            "revoke": []
                  },
                  "things:/{thingId}/features/confidential:/": {
                            "grant": [],
                            "revoke": [ "READ"]
                  },
          }
          ```
      parameters:
      - description: |-
          The ID of the policy needs to follow the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).

          The namespace needs to:
          * conform to the reverse domain name notation
          * be registered for your solution
        explode: false
        in: path
        name: policyId
        required: true
        schema:
          type: string
        style: simple
      - description: The label of a policy entry
        explode: false
        in: path
        name: label
        required: true
        schema:
          type: string
        style: simple
      - description: |-
          The `If-Match` header which has to conform to RFC-7232 (Conditional Requests). Common usages are:
            * optimistic locking by specifying the `ETag` from a previous HTTP response, e.g. `If-Match: "hash:a75ece4e"`
            * retrieving or modifying a resource only if it already exists, e.g. `If-Match: *`
        explode: false
        in: header
        name: If-Match
        required: false
        schema:
          type: string
        style: simple
      - description: 'The `If-None-Match` header, which has to conform to RFC-7232
          (Conditional Requests). A common usage scenario is to modify a resource
          only if it does not yet exist, thus to create it, by specifying `If-None-Match:
          *`.'
        explode: false
        in: header
        name: If-None-Match
        required: false
        schema:
          type: string
        style: simple
      - description: |-
          Defines how long the backend should wait for completion of the request, e.g. applied when waiting for requested
          acknowledgements via the `requested-acks` param. Can be specified without unit (then seconds are assumed) or
          together with `s`, `ms` or `m` unit. Example: `42s`, `1m`.

          The default (if omitted) timeout is `10s`. Maximum value: `60s`.

          A value of `0` applies fire and forget semantics for the command resulting in setting `response-required=false`.
        explode: true
        in: query
        name: timeout
        required: false
        schema:
          type: string
        style: form
      - description: |-
          Defines whether a response is required to the API call or not - if set to `false` the response will directly
          sent back with a status code of `202` (Accepted).

          The default (if ommited) response is `true`.
        explode: true
        in: query
        name: response-required
        required: false
        schema:
          type: boolean
        style: form
      requestBody:
        content:
          application/json:
            example: {}
            schema:
              $ref: '#/components/schemas/Resources'
        description: JSON representation of the Resources
        required: true
      responses:
        "204":
          description: The Resources were successfully created or updated.
          headers:
            ETag:
              description: |-
                The (current server-side) ETag for this (sub-)resource. For top-level resources it is in the format
                "rev:[revision]", for sub-resources it has the format "hash:[calculated-hash]".
              explode: false
              schema:
                type: string
              style: simple
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. Possible reasons:

              * the `policyId` does not conform to the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id))
              * the JSON is invalid, or no valid Resources JSON object.
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to missing authentication.
        "402":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to exceeded data volume
            or exceeded transaction count.
        "403":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. Possible reasons:

            * the API Token is missing or invalid
            * the caller has insufficient permissions.
              You need `WRITE` permission on the root `policy:/entries/{label}/resources` resource,
              without any revoke in a deeper path of the policy resource.
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. The policy with the given ID or
            the policy entry was not found in the context of the authenticated
            user.
        "412":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            A precondition for reading or writing the (sub-)resource failed. This will happen for write requests, if you
            specified an If-Match or If-None-Match header, which fails the precondition check against the current ETag of
            the (sub-)resource. For read requests, this error may only happen for a failing If-Match header. In case of a
            failing If-None-Match header for a read request, status 304 will be returned instead.
          headers:
            ETag:
              description: |-
                The (current server-side) ETag for this (sub-)resource. For top-level resources it is in the format
                "rev:[revision]", for sub-resources it has the format "hash:[calculated-hash]".
              explode: false
              schema:
                type: string
              style: simple
        "413":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The created or modified entity is larger than the accepted
            limit of 100 kB.
      summary: Create or modify all Resources for a specific Label of a specific policy
      tags:
      - Policies
  /policies/{policyId}/entries/{label}/resources/{resourcePath}:
    delete:
      description: |-
        Deletes the resource with path `resourcePath` from the policy
        identified by the the `policyId` path parameter, and by the
        `label` path parameter.
      parameters:
      - description: |-
          The ID of the policy needs to follow the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).

          The namespace needs to:
          * conform to the reverse domain name notation
          * be registered for your solution
        explode: false
        in: path
        name: policyId
        required: true
        schema:
          type: string
        style: simple
      - description: The label of a policy entry
        explode: false
        in: path
        name: label
        required: true
        schema:
          type: string
        style: simple
      - description: The path of an (Authorization) Resource
        explode: false
        in: path
        name: resourcePath
        required: true
        schema:
          type: string
        style: simple
      - description: |-
          The `If-Match` header which has to conform to RFC-7232 (Conditional Requests). Common usages are:
            * optimistic locking by specifying the `ETag` from a previous HTTP response, e.g. `If-Match: "hash:a75ece4e"`
            * retrieving or modifying a resource only if it already exists, e.g. `If-Match: *`
        explode: false
        in: header
        name: If-Match
        required: false
        schema:
          type: string
        style: simple
      - description: 'The `If-None-Match` header, which has to conform to RFC-7232
          (Conditional Requests). A common usage scenario is to modify a resource
          only if it does not yet exist, thus to create it, by specifying `If-None-Match:
          *`.'
        explode: false
        in: header
        name: If-None-Match
        required: false
        schema:
          type: string
        style: simple
      - description: |-
          Defines how long the backend should wait for completion of the request, e.g. applied when waiting for requested
          acknowledgements via the `requested-acks` param. Can be specified without unit (then seconds are assumed) or
          together with `s`, `ms` or `m` unit. Example: `42s`, `1m`.

          The default (if omitted) timeout is `10s`. Maximum value: `60s`.

          A value of `0` applies fire and forget semantics for the command resulting in setting `response-required=false`.
        explode: true
        in: query
        name: timeout
        required: false
        schema:
          type: string
        style: form
      - description: |-
          Defines whether a response is required to the API call or not - if set to `false` the response will directly
          sent back with a status code of `202` (Accepted).

          The default (if ommited) response is `true`.
        explode: true
        in: query
        name: response-required
        required: false
        schema:
          type: boolean
        style: form
      responses:
        "204":
          description: The Resource was successfully deleted.
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. Possible reasons:

              * the `policyId` does not conform to the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id))
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to missing authentication.
        "402":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to exceeded transaction
            count.
        "403":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. Possible reasons:

              * the API Token is missing or invalid
              * the caller has insufficient permissions.
                You need `WRITE` permission on the `policy:/entries/{label}/resources/{resourcePath}` resource,
                without any revoke in a deeper path of the policy resource.
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. The policy with the given ID,
            the policy entry or the Resource was not found in the context of the
            authenticated user.
        "412":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            A precondition for reading or writing the (sub-)resource failed. This will happen for write requests, if you
            specified an If-Match or If-None-Match header, which fails the precondition check against the current ETag of
            the (sub-)resource. For read requests, this error may only happen for a failing If-Match header. In case of a
            failing If-None-Match header for a read request, status 304 will be returned instead.
          headers:
            ETag:
              description: |-
                The (current server-side) ETag for this (sub-)resource. For top-level resources it is in the format
                "rev:[revision]", for sub-resources it has the format "hash:[calculated-hash]".
              explode: false
              schema:
                type: string
              style: simple
      summary: Delete one specific Resource for a specific Label of a specific policy
      tags:
      - Policies
    get:
      description: |-
        Returns the resource with path `resourcePath` of the policy identified
        by the `policyId` path parameter, and
        by the `label` path parameter.
      parameters:
      - description: |-
          The ID of the policy needs to follow the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).

          The namespace needs to:
          * conform to the reverse domain name notation
          * be registered for your solution
        explode: false
        in: path
        name: policyId
        required: true
        schema:
          type: string
        style: simple
      - description: The label of a policy entry
        explode: false
        in: path
        name: label
        required: true
        schema:
          type: string
        style: simple
      - description: The path of an (Authorization) Resource
        explode: false
        in: path
        name: resourcePath
        required: true
        schema:
          type: string
        style: simple
      - description: |-
          The `If-Match` header which has to conform to RFC-7232 (Conditional Requests). Common usages are:
            * optimistic locking by specifying the `ETag` from a previous HTTP response, e.g. `If-Match: "hash:a75ece4e"`
            * retrieving or modifying a resource only if it already exists, e.g. `If-Match: *`
        explode: false
        in: header
        name: If-Match
        required: false
        schema:
          type: string
        style: simple
      - description: 'The `If-None-Match` header, which has to conform to RFC-7232
          (Conditional Requests). A common usage scenario is to modify a resource
          only if it does not yet exist, thus to create it, by specifying `If-None-Match:
          *`.'
        explode: false
        in: header
        name: If-None-Match
        required: false
        schema:
          type: string
        style: simple
      - description: |-
          Defines how long the backend should wait for completion of the request, e.g. applied when waiting for requested
          acknowledgements via the `requested-acks` param. Can be specified without unit (then seconds are assumed) or
          together with `s`, `ms` or `m` unit. Example: `42s`, `1m`.

          The default (if omitted) timeout is `10s`. Maximum value: `60s`.

          A value of `0` applies fire and forget semantics for the command resulting in setting `response-required=false`.
        explode: true
        in: query
        name: timeout
        required: false
        schema:
          type: string
        style: form
      responses:
        "200":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ResourceEntry'
          description: |-
            The request successfully returned completed and returned is the
            Resource.
          headers:
            ETag:
              description: |-
                The (current server-side) ETag for this (sub-)resource. For top-level resources it is in the format
                "rev:[revision]", for sub-resources it has the format "hash:[calculated-hash]".
              explode: false
              schema:
                type: string
              style: simple
        "304":
          description: |-
            The (sub-)resource has not been modified. This happens if you specified a If-None-Match header, which
             matches the current ETag of the (sub-)resource.
          headers:
            ETag:
              description: |-
                The (current server-side) ETag for this (sub-)resource. For top-level resources it is in the format
                "rev:[revision]", for sub-resources it has the format "hash:[calculated-hash]".
              explode: false
              schema:
                type: string
              style: simple
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. Possible reasons:

              * the `policyId` does not conform to the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id))
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to missing authentication.
        "402":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to exceeded transaction
            count.
        "403":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to a missing or invalid
            API Token.
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. The policy with the given ID,
            the policy entry or the Resource was not found in the context of the
            authenticated user.
        "412":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            A precondition for reading or writing the (sub-)resource failed. This will happen for write requests, if you
            specified an If-Match or If-None-Match header, which fails the precondition check against the current ETag of
            the (sub-)resource. For read requests, this error may only happen for a failing If-Match header. In case of a
            failing If-None-Match header for a read request, status 304 will be returned instead.
          headers:
            ETag:
              description: |-
                The (current server-side) ETag for this (sub-)resource. For top-level resources it is in the format
                "rev:[revision]", for sub-resources it has the format "hash:[calculated-hash]".
              explode: false
              schema:
                type: string
              style: simple
      summary: Retrieve one specific Resource for a specific Label of a specific policy
      tags:
      - Policies
    put:
      description: |-
        Create or modify the Resource with path `resourcePath` of the policy
        entry identified by the `label` path parameter belonging to the policy
        identified by the `policyId` path parameter.
      parameters:
      - description: |-
          The ID of the policy needs to follow the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).

          The namespace needs to:
          * conform to the reverse domain name notation
          * be registered for your solution
        explode: false
        in: path
        name: policyId
        required: true
        schema:
          type: string
        style: simple
      - description: The label of a policy entry
        explode: false
        in: path
        name: label
        required: true
        schema:
          type: string
        style: simple
      - description: The path of an (Authorization) Resource
        explode: false
        in: path
        name: resourcePath
        required: true
        schema:
          type: string
        style: simple
      - description: |-
          The `If-Match` header which has to conform to RFC-7232 (Conditional Requests). Common usages are:
            * optimistic locking by specifying the `ETag` from a previous HTTP response, e.g. `If-Match: "hash:a75ece4e"`
            * retrieving or modifying a resource only if it already exists, e.g. `If-Match: *`
        explode: false
        in: header
        name: If-Match
        required: false
        schema:
          type: string
        style: simple
      - description: 'The `If-None-Match` header, which has to conform to RFC-7232
          (Conditional Requests). A common usage scenario is to modify a resource
          only if it does not yet exist, thus to create it, by specifying `If-None-Match:
          *`.'
        explode: false
        in: header
        name: If-None-Match
        required: false
        schema:
          type: string
        style: simple
      - description: |-
          Defines how long the backend should wait for completion of the request, e.g. applied when waiting for requested
          acknowledgements via the `requested-acks` param. Can be specified without unit (then seconds are assumed) or
          together with `s`, `ms` or `m` unit. Example: `42s`, `1m`.

          The default (if omitted) timeout is `10s`. Maximum value: `60s`.

          A value of `0` applies fire and forget semantics for the command resulting in setting `response-required=false`.
        explode: true
        in: query
        name: timeout
        required: false
        schema:
          type: string
        style: form
      - description: |-
          Defines whether a response is required to the API call or not - if set to `false` the response will directly
          sent back with a status code of `202` (Accepted).

          The default (if ommited) response is `true`.
        explode: true
        in: query
        name: response-required
        required: false
        schema:
          type: boolean
        style: form
      requestBody:
        content:
          application/json:
            example: {}
            schema:
              $ref: '#/components/schemas/ResourceEntry'
        description: JSON representation of the Resource
        required: true
      responses:
        "201":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ResourceEntry'
          description: The Resource was successfully created.
          headers:
            ETag:
              description: |-
                The (current server-side) ETag for this (sub-)resource. For top-level resources it is in the format
                "rev:[revision]", for sub-resources it has the format "hash:[calculated-hash]".
              explode: false
              schema:
                type: string
              style: simple
            Location:
              description: The location of the created Resource
              explode: false
              schema:
                type: string
              style: simple
        "204":
          description: The Resource was successfully updated.
          headers:
            ETag:
              description: |-
                The (current server-side) ETag for this (sub-)resource. For top-level resources it is in the format
                "rev:[revision]", for sub-resources it has the format "hash:[calculated-hash]".
              explode: false
              schema:
                type: string
              style: simple
        "304":
          description: |-
            The (sub-)resource has not been modified. This happens if you specified a If-None-Match header, which
             matches the current ETag of the (sub-)resource.
          headers:
            ETag:
              description: |-
                The (current server-side) ETag for this (sub-)resource. For top-level resources it is in the format
                "rev:[revision]", for sub-resources it has the format "hash:[calculated-hash]".
              explode: false
              schema:
                type: string
              style: simple
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. Possible reasons:

             * the `policyId` does not conform to the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id))
              * the JSON is invalid, or no valid Resource JSON object.
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to missing authentication.
        "402":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to exceeded data volume
            or exceeded transaction count.
        "403":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. Possible reasons:

              * the API Token is missing or invalid
              * the caller has insufficient permissions.
                You need `WRITE` permission on the `policy:/entries/{label}/resources/{resourcePath}` resource,
                without any revoke in a deeper path of the policy resource.
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. The policy with the given ID or
            the policy entry was not found in the context of the authenticated
            user.
        "412":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            A precondition for reading or writing the (sub-)resource failed. This will happen for write requests, if you
            specified an If-Match or If-None-Match header, which fails the precondition check against the current ETag of
            the (sub-)resource. For read requests, this error may only happen for a failing If-Match header. In case of a
            failing If-None-Match header for a read request, status 304 will be returned instead.
          headers:
            ETag:
              description: |-
                The (current server-side) ETag for this (sub-)resource. For top-level resources it is in the format
                "rev:[revision]", for sub-resources it has the format "hash:[calculated-hash]".
              explode: false
              schema:
                type: string
              style: simple
        "413":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The created or modified entity is larger than the accepted
            limit of 100 kB.
      summary: Create or modify one specific Resource for a specific Label of a specific
        policy
      tags:
      - Policies
  /whoami:
    get:
      description: Get information about the current caller, e.g. the auth subjects
        that are generated for the caller.
      responses:
        "200":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/WhoAmI'
          description: The request successfully returned information about the caller.
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to missing authentication.
        "402":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to exceeded transaction
            count.
      summary: Retrieve information about the current caller
      tags:
      - Policies
  /search/things:
    get:
      description: |-
        This resource can be used to search for things.

        * The query parameter `filter` is not mandatory. If it is not set, the
          result contains all things which the logged in user is allowed to read.

        * The search is case sensitive. In case you don't know how exactly the
          spelling of the namespace, name, attribute, feature etc. is, use the *like*
          notation for filtering

        * The search result is limited to the things within the namespace (or namespaces)
          the solution is configured for. You can explicitly search in specific namespaces
          by including them in the query via the *namespaces* parameter.

        * The resource supports sorting and paging. If paging is not explicitly
          specified by means of the `size` option, a default count of `25`
          documents is returned.

        * The internal search index is "eventually consistent".  Consistency with the latest
          thing updates should recover within milliseconds.
      parameters:
      - description: |2-

          #### Filter predicates:

          * ```eq({property},{value})```  (i.e. equal to the given value)

          * ```ne({property},{value})```  (i.e. not equal to the given value)

          * ```gt({property},{value})```  (i.e. greater than the given value)

          * ```ge({property},{value})```  (i.e. equal to the given value or greater than it)

          * ```lt({property},{value})```  (i.e. lower than the given value or equal to it)

          * ```le({property},{value})```  (i.e. lower than the given value)

          * ```in({property},{value},{value},...)```  (i.e. contains at least one of the values listed)

          * ```like({property},{value})```  (i.e. contains values similar to the expressions listed)

          * ```exists({property})```  (i.e. all things in which the given path exists)


          Note: When using filter operations, only things with the specified properties are returned.
          For example, the filter `ne(attributes/owner, "SID123")` will only return things that do have
          the `owner` attribute.


          #### Logical operations:


          * ```and({query},{query},...)```

          * ```or({query},{query},...)```

          * ```not({query})```


          #### Examples:

          * ```eq(attributes/location,"kitchen")```

          * ```ge(thingId,"myThing1")```

          * ```exists(features/featureId)```

          * ```and(eq(attributes/location,"kitchen"),eq(attributes/color,"red"))```

          * ```or(eq(attributes/location,"kitchen"),eq(attributes/location,"living-room"))```

          * ```like(attributes/key1,"known-chars-at-start*")```

          * ```like(attributes/key1,"*known-chars-at-end")```

          * ```like(attributes/key1,"*known-chars-in-between*")```

          * ```like(attributes/key1,"just-som?-char?-unkn?wn")```

          The `like` filters with the wildcard `*` at the beginning can slow down your search request.
        explode: true
        in: query
        name: filter
        required: false
        schema:
          type: string
        style: form
      - description: |-
          A comma-separated list of namespaces. This list is used to limit the query to things in the given namespaces
          only.
          If this parameter is omitted, all registered namespaces of your solution will be queried. The solution is
          determined by the API token sent with the request.


          #### Examples:

          * `?namespaces=com.example.namespace`

          * `?namespaces=com.example.namespace1,com.example.namespace2`
        explode: true
        in: query
        name: namespaces
        required: false
        schema:
          type: string
        style: form
      - description: |-
          Contains a comma-separated list of fields to be included in the returned
          JSON. attributes can be selected in the same manner.

          #### Selectable fields

          * `thingId`
          * `policyId`
          * `definition`
          * `attributes`

             Supports selecting arbitrary sub-fields by using a comma-separated list:
              * several attribute paths can be passed as a comma-separated list of JSON pointers (RFC-6901)

                For example:
                  * `?fields=attributes/model` would select only `model` attribute value (if present)
                  * `?fields=attributes/model,attributes/location` would select only `model` and
                     `location` attribute values (if present)

            Supports selecting arbitrary sub-fields of objects by wrapping sub-fields inside parentheses `( )`:
              * a comma-separated list of sub-fields (a sub-field is a JSON pointer (RFC-6901)
                separated with `/`) to select

              * sub-selectors can be used to request only specific sub-fields by placing expressions
                in parentheses `( )` after a selected subfield

                For example:
                 * `?fields=attributes(model,location)` would select only `model`
                    and `location` attribute values (if present)
                 * `?fields=attributes(coffeemaker/serialno)` would select the `serialno` value
                    inside the `coffeemaker` object
                 * `?fields=attributes/address/postal(city,street)` would select the `city` and
                    `street` values inside the `postal` object inside the `address` object

          * `features`

            Supports selecting arbitrary fields in features similar to `attributes` (see also features documentation for more details)

          * `_namespace`

            Specifically selects the namespace also contained in the `thingId`

          * `_revision`

            Specifically selects the revision of the thing. The revision is a counter, which is incremented on each modification of a thing.

          * `_modified`

            Specifically selects the modified timestamp of the thing in ISO-8601 UTC format. The timestamp is set on each modification of a thing.

          * `_policy`

            Specifically selects the content of the policy associated to the thing. (By default, only the policyId is returned.)

          #### Examples

          * `?fields=thingId,attributes,features`
          * `?fields=attributes(model,manufacturer),features`
        explode: true
        in: query
        name: fields
        required: false
        schema:
          type: string
        style: form
      - description: |-
          Defines how long the backend should wait for completion of the request, e.g. applied when waiting for requested
          acknowledgements via the `requested-acks` param. Can be specified without unit (then seconds are assumed) or
          together with `s`, `ms` or `m` unit. Example: `42s`, `1m`.

          The default (if omitted) timeout is `10s`. Maximum value: `60s`.

          A value of `0` applies fire and forget semantics for the command resulting in setting `response-required=false`.
        explode: true
        in: query
        name: timeout
        required: false
        schema:
          type: string
        style: form
      - description: |-
          Possible values for the parameter:

          #### Sort operations

          * ```sort([+|-]{property})```
          * ```sort([+|-]{property},[+|-]{property},...)```

          #### Paging operations

          * ```size({page-size})```  Maximum allowed page size is `200`. Default page size is `25`.
          * ```cursor({cursor-id})```  Start the search from the cursor location. Specify the cursor ID without
          quotation marks. Cursor IDs are given in search responses and mark the position after the last entry of
          the previous search. The meaning of cursor IDs is unspecified and may change without notice.

          The paging option `limit({offset},{count})` is deprecated.
          It may result in slow queries or timeouts and will be removed eventually.

          #### Examples:

          * ```sort(+thingId)```
          * ```sort(-attributes/manufacturer)```
          * ```sort(+thingId,-attributes/manufacturer)```
          * ```size(10)``` return 10 results
          * ```cursor(LOREMIPSUM)```  return results after the position of the cursor `LOREMIPSUM`.

          #### Combine:

          If you need to specify multiple options, when using the swagger UI just write each option in a new line.
          When using the plain REST API programmatically,
          you will need to separate the options using a comma (,) character.

          ```size(200),cursor(LOREMIPSUM)```

          The deprecated paging option `limit` may not be combined with the other paging options `size` and `cursor`.
        explode: true
        in: query
        name: option
        required: false
        schema:
          type: string
        style: form
      responses:
        "200":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/SearchResultThings'
          description: An array of the matching things.
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. A provided parameter is in a
            wrong format.
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to missing authentication.
        "402":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to exceeded transaction
            count.
        "403":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to an invalid authentication.
        "504":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request ran out of time to execute on the the back-end.
            Optimize your query and try again.
      summary: Search for things
      tags:
      - Things-Search
  /search/things/count:
    get:
      description: |-
        This resource can be used to count things.

        The query parameter `filter` is not mandatory. If it is not set there is
        returned the total amount of things which the logged in user is allowed
        to read.

        To search for nested properties, we use JSON Pointer notation
        (RFC-6901). See the following example how to search for the sub property
        `location` of the parent property `attributes` with a forward slash as
        separator:

        ```eq(attributes/location,"kitchen")```

        The search result is limited to the things within the namespace (or namespaces) the solution is configured
        for. You can explicitly search in other namespaces by including them in the query via the `namespaces`
        parameter.
      parameters:
      - description: |2-

          #### Filter predicates:

          * ```eq({property},{value})```  (i.e. equal to the given value)

          * ```ne({property},{value})```  (i.e. not equal to the given value)

          * ```gt({property},{value})```  (i.e. greater than the given value)

          * ```ge({property},{value})```  (i.e. equal to the given value or greater than it)

          * ```lt({property},{value})```  (i.e. lower than the given value or equal to it)

          * ```le({property},{value})```  (i.e. lower than the given value)

          * ```in({property},{value},{value},...)```  (i.e. contains at least one of the values listed)

          * ```like({property},{value})```  (i.e. contains values similar to the expressions listed)

          * ```exists({property})```  (i.e. all things in which the given path exists)


          Note: When using filter operations, only things with the specified properties are returned.
          For example, the filter `ne(attributes/owner, "SID123")` will only return things that do have
          the `owner` attribute.


          #### Logical operations:


          * ```and({query},{query},...)```

          * ```or({query},{query},...)```

          * ```not({query})```


          #### Examples:

          * ```eq(attributes/location,"kitchen")```

          * ```ge(thingId,"myThing1")```

          * ```exists(features/featureId)```

          * ```and(eq(attributes/location,"kitchen"),eq(attributes/color,"red"))```

          * ```or(eq(attributes/location,"kitchen"),eq(attributes/location,"living-room"))```

          * ```like(attributes/key1,"known-chars-at-start*")```

          * ```like(attributes/key1,"*known-chars-at-end")```

          * ```like(attributes/key1,"*known-chars-in-between*")```

          * ```like(attributes/key1,"just-som?-char?-unkn?wn")```

          The `like` filters with the wildcard `*` at the beginning can slow down your search request.
        explode: true
        in: query
        name: filter
        required: false
        schema:
          type: string
        style: form
      - description: |-
          A comma-separated list of namespaces. This list is used to limit the query to things in the given namespaces
          only.
          If this parameter is omitted, all registered namespaces of your solution will be queried. The solution is
          determined by the API token sent with the request.


          #### Examples:

          * `?namespaces=com.example.namespace`

          * `?namespaces=com.example.namespace1,com.example.namespace2`
        explode: true
        in: query
        name: namespaces
        required: false
        schema:
          type: string
        style: form
      - description: |-
          Defines how long the backend should wait for completion of the request, e.g. applied when waiting for requested
          acknowledgements via the `requested-acks` param. Can be specified without unit (then seconds are assumed) or
          together with `s`, `ms` or `m` unit. Example: `42s`, `1m`.

          The default (if omitted) timeout is `10s`. Maximum value: `60s`.

          A value of `0` applies fire and forget semantics for the command resulting in setting `response-required=false`.
        explode: true
        in: query
        name: timeout
        required: false
        schema:
          type: string
        style: form
      responses:
        "200":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/SearchResultThingsCount'
          description: A number indicating the amount of matched things
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. A provided parameter is in a
            wrong format.
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to missing authentication.
        "402":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to exceeded transaction
            count.
        "403":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to an invalid authentication.
        "504":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request ran out of time to execute on the the back-end.
            Optimize your query and try again.
      summary: Count things
      tags:
      - Things-Search
  /solutions/{solutionId}:
    get:
      description: Returns the complete solution entity identified by the `solutionId`
        path parameter.
      parameters:
      - description: The ID of the Solution
        explode: false
        in: path
        name: solutionId
        required: true
        schema:
          type: string
        style: simple
      responses:
        "200":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Solution'
          description: The request successfully returned the specific Solution.
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed. The `solutionId` must be
            an URI.
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to missing authentication.
        "402":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to exceeded transaction
            count.
        "403":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to an invalid authentication.
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. The solution with the given ID
            was not found.
      summary: Retrieve a specific Solution
      tags:
      - Solutions
  /solutions/{solutionId}/usage:
    get:
      description: |-
        Returns the last calculated usage of the solution identified by the `solutionId` path parameter.

        The numbers might differ from the effective number reported for billing purposes. Please note however, that quota usage requests and all responses will also count as transactions.
      parameters:
      - description: The ID of the Solution
        explode: false
        in: path
        name: solutionId
        required: true
        schema:
          type: string
        style: simple
      responses:
        "200":
          content:
            application/json:
              example:
                dataVolume:
                  size: 4711
                  unit: BYTE
                transactionCount:
                  value: 1337
                timeOfCalculation: 2019-11-13T15:45:29.069Z
              schema:
                $ref: '#/components/schemas/Usage'
          description: The request successfully returned the last calculated usage
            of the specific Solution.
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed. The `solutionId` must be
            an URI.
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to missing authentication.
        "402":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to exceeded transaction
            count.
        "403":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to an invalid authentication.
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed. The Solution with the given
            ID was not found there was no usage calculated for the given solution.
      summary: Retrieve the last calculated usage of a specific Solution
      tags:
      - Solutions
  /solutions/{solutionId}/key:
    put:
      deprecated: true
      description: |-
        Updates the public key of the solution identified by the `solutionId` path parameter.

        A public key can be used by a technical client to communicate
        with the Bosch IoT Things backend.

        The request body must be a JSON string beginning and ending with double
        quotes.
      parameters:
      - description: The ID of the Solution
        explode: false
        in: path
        name: solutionId
        required: true
        schema:
          type: string
        style: simple
      requestBody:
        content:
          application/json:
            schema:
              example: '"-----BEGIN PUBLIC KEY-----\n BASE64 ENCODED KEY -----END
                PUBLIC KEY-----"'
              type: string
        description: |-
          The public key file in PKCS#8 format or a X.509 certificate as JSON
          string representation. We only accept keys that were created using the
          elliptic curve algorithm "EC" at the moment.
        required: true
      responses:
        "204":
          description: The public key was successfully updated.
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. The body was no valid JSON
            string or the encoded key is in a wrong format.
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to missing authentication.
        "402":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to exceeded transaction
            count.
        "403":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to an invalid authentication.
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. The solution with the given ID
            was not found.
      summary: Update the public key of a specific Solution
      tags:
      - Solutions
  /solutions/{solutionId}/namespaces:
    get:
      description: |-
        Returns all namespaces registered for the solution identified by the `solutionId` path parameter.

        A namespace is necessary to link things and policies
        to the specific solution.
      parameters:
      - description: The ID of the Solution
        explode: false
        in: path
        name: solutionId
        required: true
        schema:
          type: string
        style: simple
      responses:
        "200":
          content:
            application/json:
              example:
                defaultNamespace:
                  default: true
                  state: CREATED
                yetAnotherNamespace:
                  default: false
                  state: CREATED
              schema:
                $ref: '#/components/schemas/Namespaces'
          description: |-
            The request successfully returned the namespace of the specific
            solution.
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed. The `solutionId` must be
            an URI.
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to missing authentication.
        "402":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to exceeded transaction
            count.
        "403":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to an invalid authentication.
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. The solution with the given ID
            was not found.
      summary: Retrieve all Namespaces registered for a specific Solution
      tags:
      - Solutions
  /solutions/{solutionId}/namespaces/{namespaceId}:
    delete:
      description: |-
        Deletes the namespace identified by the `namespaceId` path parameter
        registered for the Solution identified by the `solutionId` path parameter.

        ### Note: By deleting a namespace you automatically delete multiple entities
        Entities like things and policies, that are part of the namespace,
        are **deleted permanently** as part of the deletion process.
      parameters:
      - description: The ID of the Solution
        explode: false
        in: path
        name: solutionId
        required: true
        schema:
          type: string
        style: simple
      - description: The ID of the Namespace
        explode: false
        in: path
        name: namespaceId
        required: true
        schema:
          type: string
        style: simple
      responses:
        "204":
          description: The namespace was successfully deleted.
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed. The `solutionId` must be
            an URI.
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to missing authentication.
        "402":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to exceeded transaction
            count.
        "403":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to an invalid authentication.
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. The solution with the given ID
            or the namespace was not found.
      summary: Delete a specific Namespace - and all its associated entities - registered
        for a specific Solution
      tags:
      - Solutions
    get:
      description: |-
        Returns the namespace identified by the `namespaceId` path parameter
        registered for the solution identified by the `solutionId` path parameter.
      parameters:
      - description: The ID of the Solution
        explode: false
        in: path
        name: solutionId
        required: true
        schema:
          type: string
        style: simple
      - description: The ID of the Namespace
        explode: false
        in: path
        name: namespaceId
        required: true
        schema:
          type: string
        style: simple
      responses:
        "200":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/NamespaceEntry'
          description: |-
            The request successfully returned the entries of a the specific
            namespace of a solution.
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed. The `solutionId` must be
            an URI.
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to missing authentication.
        "402":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to exceeded transaction
            count.
        "403":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to an invalid authentication.
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. The solution with the given ID
            was not found.
      summary: Retrieve a specific Namespace registered for a specific Solution
      tags:
      - Solutions
    put:
      description: |-
        Create or update a namespace specified by the `namespaceId` path parameter, and the JSON body.
        * If you set a new `namespaceId` in the path, a namespace will be created.
        * If you set an existing `namespaceId` in the path, the namespace will be updated.

        A namespace is necessary to link things and policies to the specific solution.

        The request body must be a JSON object containing a namespace entry.

        The namespace entry contains the information if the namespaceId is used as
        default namespace.
         ```{"default": true}```
        Note: Only one namespace can be the default.

        **Restriction**: If your solution is based on a Free and Starter plan only **one namespace** is allowed.
      parameters:
      - description: The ID of the Solution
        explode: false
        in: path
        name: solutionId
        required: true
        schema:
          type: string
        style: simple
      - description: The ID of the Namespace
        explode: false
        in: path
        name: namespaceId
        required: true
        schema:
          type: string
        style: simple
      requestBody:
        content:
          application/json:
            example:
              default: false
            schema:
              $ref: '#/components/schemas/NamespaceEntry'
        description: JSON representation of the namespace to be modified.
        required: true
      responses:
        "201":
          description: The namespace was successfully created.
        "204":
          description: The namespace was successfully updated.
        "400":
          description: The request could not be completed. The body was no valid JSON.
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to missing authentication.
        "402":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to namespace restriction
            or due to exceeded transaction count.
        "403":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to an invalid authentication.
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. The solution with the given ID
            was not found.
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The namespace is already used by another solution.
      summary: Create or update a specific Namespace registered for a specific Solution
      tags:
      - Solutions
  /solutions/{solutionId}/namespaces/{namespaceId}/deletion:
    get:
      description: |-
        Returns a status report of the namespace deletion process including the current step number and the amount of
        total steps as indication of progress.
      parameters:
      - description: The ID of the Solution
        explode: false
        in: path
        name: solutionId
        required: true
        schema:
          type: string
        style: simple
      - description: The ID of the Namespace
        explode: false
        in: path
        name: namespaceId
        required: true
        schema:
          type: string
        style: simple
      responses:
        "200":
          content:
            application/json:
              example:
                type: solutions.responses:retrieveNamespacePurgingState
                status: 200
                namespaceName: namespaceId
                currentStep: 5
                totalSteps: 29
                description: Purging 3 of 5 resources (iteration 1 of 2)
              schema:
                $ref: '#/components/schemas/NamespacePurgingState'
          description: Status report of the namespace deletion process is retrieved
            successfully.
        "402":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to exceeded transaction
            count.
        "404":
          description: The namespace is not being deleted.
      summary: Retrieve the deletion status report of a specific Namespace registered
        for a specific Solution
      tags:
      - Solutions
  /solutions/{solutionId}/connections:
    get:
      description: |-
        Returns all connections of a solution specified by the `solutionId` parameter.

        Tip: If you subscribe to the 'Bosch IoT Suite for Asset Communication' package,
        the connection between Hub and things is created automatically.
      parameters:
      - description: The ID of the Solution
        explode: false
        in: path
        name: solutionId
        required: true
        schema:
          type: string
        style: simple
      responses:
        "200":
          content:
            application/json:
              schema:
                items:
                  $ref: '#/components/schemas/Connection'
                type: array
          description: The request successfully returned the connections.
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed. The `solutionId` must be
            an URI.
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to missing authentication.
        "402":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to exceeded transaction
            count.
        "403":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to an invalid authentication.
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed. The solution with ID `solutionId`
            was not found.
      summary: Retrieve all Connections registered for a specific Solution
      tags:
      - Solutions
    post:
      description: |-
        Creates the connection defined in the JSON body for the solution specified by the `solutionId` parameter.

        The ID of the connection will be generated by the backend. Any `ID` specified in the request body is therefore
        ignored.

        All other IDs can be looked up from the credentials section available after a successful service subscription
        see https://accounts.bosch-iot-suite.com/subscriptions.

        Supported connection types are `amqp-091`, `amqp-10`, `mqtt`, `kafka` and `http`.

        The connection defines a `ConnectionStatus` mapping and references it by its ID `status` in the
        telemetry/event source.

        Tip: If you subscribe to the 'Bosch IoT Suite for Asset Communication' package,
        the connection between Hub and things is created automatically.
      parameters:
      - description: The ID of the Solution
        explode: false
        in: path
        name: solutionId
        required: true
        schema:
          type: string
        style: simple
      - description: |-
          When set to true, the request will not try to create the connection, but only try to connect it.
          You can use this parameter to verify that the given connection is able to communicate with your external
          system.
        explode: true
        in: query
        name: dry-run
        required: false
        schema:
          type: boolean
        style: form
      requestBody:
        content:
          application/json:
            example:
              name: Devices via Bosch IoT Hub
              connectionType: amqp-10
              connectionStatus: open
              uri: amqps://messaging-username@messaging.bosch-iot-hub.com:5671
              sources:
              - addresses:
                - event/your-Hub-tenant-ID
                - telemetry/your-Hub-tenant-ID
                consumerCount: 1
                authorizationContext:
                - integration:your-Things-solution-ID:hub
                enforcement:
                  input: '{{ header:device_id }}'
                  filters:
                  - '{{ thing:id }}'
                payloadMapping:
                - Ditto
                - status
              - addresses:
                - control/your-Hub-tenant-ID/replies
                consumerCount: 1
                authorizationContext:
                - integration:your-Things-solution-ID:hub
                headerMapping:
                  message-id: '{{ header:correlation-id }}'
                  content-type: '{{ header:content-type }}'
                  status: '{{ header:status }}'
              targets:
              - address: control/your-Hub-tenant-ID/{{fn:default(thing:name) }}
                topics:
                - _/_/things/live/commands
                - _/_/things/twin/events
                - _/_/things/live/events
                - _/_/things/live/messages
                authorizationContext:
                - integration:your-Things-solution-ID:hub
                headerMapping:
                  message-id: '{{ header:correlation-id }}'
                  content-type: application/vnd.eclipse.ditto+json
                  reply-to: control/your-Hub-tenant-ID/replies
                  subject: '{{ topic:action-subject }}'
              clientCount: 1
              failoverEnabled: true
              validateCertificates: true
              mappingDefinitions:
                status:
                  mappingEngine: ConnectionStatus
                  options:
                    thingId: '{{ header:device_id }}'
              tags:
              - bosch-iot-hub
            schema:
              $ref: '#/components/schemas/NewConnection'
        description: The example below shows a connection to Bosch IoT Hub.
        required: true
      responses:
        "200":
          description: |-
            Will be returned when a dry-run succeeded (see description of the dry-run query parameter for further
            information).
        "201":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Connection'
          description: The connection was successfully created.
          headers:
            Location:
              description: The location of the created connection resource.
              explode: false
              schema:
                type: string
              style: simple
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. Possible reasons:

            * the `ID` was wrongly set in the request body,
            * the JSON of the connection to be created is invalid.
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to missing authentication.
        "402":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to exceeded transaction
            count.
        "403":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to invalid authentication.
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed. The solution with ID `solutionId`
            was not found.
      summary: Create a new Connection for a specific Solution
      tags:
      - Solutions
  /solutions/{solutionId}/connections/{connectionId}:
    delete:
      description: Delete the connection identified by the `solutionId` and `connectionId`
        path parameter.
      parameters:
      - description: The ID of the Solution
        explode: false
        in: path
        name: solutionId
        required: true
        schema:
          type: string
        style: simple
      - description: The ID of the connection
        explode: false
        in: path
        name: connectionId
        required: true
        schema:
          type: string
        style: simple
      responses:
        "204":
          description: The connection was successfully deleted.
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed. The `solutionId` or `connectionId`
            must be an URI.
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to missing authentication.
        "402":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to exceeded transaction
            count.
        "403":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to an invalid authentication.
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. The solution with ID `solutionId` or the connection with ID
            `connectionId` was not found.
      summary: Delete a specific Connection registered for a specific Solution
      tags:
      - Solutions
    get:
      description: |-
        Returns the connection identified by the `solutionId` and `connectionId` path parameter.

        Tip: If you subscribe to the 'Bosch IoT Suite for Asset Communication' package,
        the connection between Hub and things is created automatically.
      parameters:
      - description: The ID of the Solution
        explode: false
        in: path
        name: solutionId
        required: true
        schema:
          type: string
        style: simple
      - description: The ID of the connection
        explode: false
        in: path
        name: connectionId
        required: true
        schema:
          type: string
        style: simple
      responses:
        "200":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Connection'
          description: The request successfully returned the connection.
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed. The `solutionId` or `connectionId`
            must be an URI.
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to missing authentication.
        "402":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to exceeded transaction
            count.
        "403":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to invalid authentication.
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. The solution with ID `solutionId` or the connection with ID
            `connectionId` was not found.
      summary: Retrieve a specific Connection registered for a specific Solution
      tags:
      - Solutions
    put:
      description: Update the connection identified by the `solutionId` and `connectionId`
        path parameter.
      parameters:
      - description: The ID of the Solution
        explode: false
        in: path
        name: solutionId
        required: true
        schema:
          type: string
        style: simple
      - description: The ID of the connection
        explode: false
        in: path
        name: connectionId
        required: true
        schema:
          type: string
        style: simple
      requestBody:
        content:
          application/json:
            example:
              id: lookup-the-generated-UUID-at-the-UI
              name: Devices via Bosch IoT Hub
              connectionType: amqp-10
              connectionStatus: open
              uri: amqps://messaging-username@messaging.bosch-iot-hub.com:5671
              sources:
              - addresses:
                - event/your-Hub-tenant-ID
                - telemetry/your-Hub-tenant-ID
                consumerCount: 1
                authorizationContext:
                - integration:your-Things-solution-ID:hub
                enforcement:
                  input: '{{ header:device_id }}'
                  filters:
                  - '{{ thing:id }}'
                payloadMapping:
                - Ditto
                - status
              - addresses:
                - control/your-Hub-tenant-ID/replies
                consumerCount: 1
                authorizationContext:
                - integration:your-Things-solution-ID:hub
                headerMapping:
                  message-id: '{{ header:correlation-id }}'
                  content-type: '{{ header:content-type }}'
                  status: '{{ header:status }}'
              targets:
              - address: control/your-Hub-tenant-ID/{{fn:default(thing:name) }}
                topics:
                - _/_/things/live/commands
                - _/_/things/twin/events
                - _/_/things/live/events
                - _/_/things/live/messages
                authorizationContext:
                - integration:your-Things-solution-ID:hub
                headerMapping:
                  message-id: '{{ header:correlation-id }}'
                  content-type: application/vnd.eclipse.ditto+json
                  reply-to: control/your-Hub-tenant-ID/replies
                  subject: '{{ topic:action-subject }}'
              clientCount: 1
              failoverEnabled: true
              validateCertificates: true
              mappingDefinitions:
                status:
                  mappingEngine: ConnectionStatus
                  options:
                    thingId: '{{ header:device_id }}'
              tags:
              - bosch-iot-hub
            schema:
              $ref: '#/components/schemas/Connection'
        required: true
      responses:
        "204":
          description: The connection was successfully updated.
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. Possible reasons:

              * the `solutionId` or `connectionId` must be an URI,
              * the `ID` was wrongly set in the request body,
              * the JSON of the connection to be created is invalid.
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to missing authentication.
        "402":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to exceeded transaction
            count.
        "403":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to invalid authentication.
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. The solution with ID `solutionId` or the connection with ID
            `connectionId` was not found.
      summary: Update a specific Connection registered for a specific Solution
      tags:
      - Solutions
  /solutions/{solutionId}/connections/{connectionId}/command:
    post:
      description: |-
        Sends the command specified in the body to the connection identified by the `solutionId` and `connectionId`
        path parameter.
      parameters:
      - description: The ID of the Solution
        explode: false
        in: path
        name: solutionId
        required: true
        schema:
          type: string
        style: simple
      - description: The ID of the connection
        explode: false
        in: path
        name: connectionId
        required: true
        schema:
          type: string
        style: simple
      requestBody:
        content:
          text/plain:
            schema:
              example: <commmand>
              type: string
        description: |-
          The command to send. Supported commands are
            * `connectivity.commands:openConnection`
            * `connectivity.commands:closeConnection`
            * `connectivity.commands:resetConnectionMetrics`
            * `connectivity.commands:enableConnectionLogs`
            * `connectivity.commands:resetConnectionLogs`
        required: true
      responses:
        "200":
          description: The command was sent to the connection successfully.
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed. The `solutionId` or `connectionId`
            must be an URI.
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to missing authentication.
        "402":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to exceeded transaction
            count.
        "403":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to invalid authentication.
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed. The solution with ID `solutionId`
            was not found.
      summary: Send a command to a specific Connection.
      tags:
      - Solutions
  /solutions/{solutionId}/connections/{connectionId}/status:
    get:
      description: Returns the status of the connection identified by the `solutionId`
        and `connectionId` path parameter.
      parameters:
      - description: The ID of the Solution
        explode: false
        in: path
        name: solutionId
        required: true
        schema:
          type: string
        style: simple
      - description: The ID of the connection
        explode: false
        in: path
        name: connectionId
        required: true
        schema:
          type: string
        style: simple
      responses:
        "200":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ConnectionStatus'
          description: The request successfully returned the connection status.
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed. The `solutionId` or `connectionId`
            must be an URI.
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to missing authentication.
        "402":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to exceeded transaction
            count.
        "403":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to invalid authentication.
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. The solution with ID `solutionId` or the connection with ID
            `connectionId` was not found.
      summary: Retrieve status of a specific Connection
      tags:
      - Solutions
  /solutions/{solutionId}/connections/{connectionId}/metrics:
    get:
      description: Returns the metrics of the connection identified by the `solutionId`
        and `connectionId` path parameter.
      parameters:
      - description: The ID of the Solution
        explode: false
        in: path
        name: solutionId
        required: true
        schema:
          type: string
        style: simple
      - description: The ID of the connection
        explode: false
        in: path
        name: connectionId
        required: true
        schema:
          type: string
        style: simple
      responses:
        "200":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ConnectionMetrics'
          description: The request successfully returned the connection metrics.
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed. The `solutionId` or `connectionId`
            must be an URI.
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to missing authentication.
        "402":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to exceeded transaction
            count.
        "403":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to invalid authentication.
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. The solution with ID `solutionId` or the connection with ID
            `connectionId` was not found.
      summary: Retrieve metrics of a specific Connection
      tags:
      - Solutions
  /solutions/{solutionId}/connections/{connectionId}/logs:
    get:
      description: |-
        Returns the logs of the connection identified by the `solutionId` and `connectionId` path parameter.

        **Before** log entries are generated and returned, logging needs be enabled with the `command`
        `connectivity.commands:enableConnectionLogs`.
      parameters:
      - description: The ID of the Solution
        explode: false
        in: path
        name: solutionId
        required: true
        schema:
          type: string
        style: simple
      - description: The ID of the connection
        explode: false
        in: path
        name: connectionId
        required: true
        schema:
          type: string
        style: simple
      responses:
        "200":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ConnectionLogs'
          description: The request successfully returned the connection logs.
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed. The `solutionId` or `connectionId`
            must be an URI.
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to missing authentication.
        "402":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to exceeded transaction
            count.
        "403":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to invalid authentication.
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: |-
            The request could not be completed. The solution with ID `solutionId` or the connection with ID
            `connectionId` was not found.
      summary: Retrieve logs of a specific Connection
      tags:
      - Solutions
  /solutions/{solutionId}/clients:
    delete:
      description: Deletes all authorized clients (e.g. OAuth2) of the solution identified
        by the `solutionId` path parameter.
      parameters:
      - description: The ID of the Solution
        explode: false
        in: path
        name: solutionId
        required: true
        schema:
          type: string
        style: simple
      responses:
        "204":
          description: The clients were successfully deleted.
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed. The `solutionId` must be
            an URI.
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to missing authentication.
        "402":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to exceeded transaction
            count.
        "403":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to an invalid authentication.
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed. The Solution or the client
            with the given ID was not found.
      summary: Delete all authorized authorized clients (e.g. OAuth2) of a specific
        Solution
      tags:
      - Solutions
    get:
      description: |-
        Returns all authorized clients (e.g. OAuth2) of the solution.

        Clients registered here are authorized to make requests
        in the context of the solution identified by the `solutionId` path parameter.
      parameters:
      - description: The ID of the Solution
        explode: false
        in: path
        name: solutionId
        required: true
        schema:
          type: string
        style: simple
      responses:
        "200":
          content:
            application/json:
              example:
                clientId1:
                  clientId: clientId1
                  subjectIssuer: my-issuer-1
                clientId2:
                  clientId: clientId2
                  subjectIssuer: my-issuer-2
              schema:
                $ref: '#/components/schemas/Clients'
          description: The request successfully returned the clients of the specific
            Solution.
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed. The `solutionId` must be
            an URI.
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to missing authentication.
        "402":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to exceeded transaction
            count.
        "403":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to an invalid authentication.
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed. The Solution with the given
            ID was not found.
      summary: Retrieve the authorized authorized clients (e.g. OAuth2) of a specific
        Solution.
      tags:
      - Solutions
    put:
      description: |-
        Create or update all authorized clients (e.g. OAuth2) at once.

        These clients - specified in the request body - will be authorized to make requests
        in the context of the solution identified by the `solutionId` path parameter.

        The request body must be a JSON object containing one or more clients.
      parameters:
      - description: The ID of the Solution
        explode: false
        in: path
        name: solutionId
        required: true
        schema:
          type: string
        style: simple
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/Clients'
        description: JSON representation of the clients to be modified.
        required: true
      responses:
        "201":
          description: The clients were successfully created.
        "204":
          description: The clients were successfully updated.
        "400":
          description: The request could not be completed. Either the body was no
            valid JSON or it did not contain an accepted subjectIssuer
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to missing authentication.
        "402":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to exceeded transaction
            count.
        "403":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to an invalid authentication.
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed. The Solution with the given
            ID was not found.
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: One of the client ID and subject issuer combination is already
            used.
      summary: Create or update all authorized authorized clients (e.g. OAuth2) of
        a specific Solution
      tags:
      - Solutions
  /solutions/{solutionId}/clients/{clientId}:
    delete:
      description: |-
        Deletes an authorized client (e.g. OAuth2) specified by the `clientId` path parameter, of the solution identified by
        the `solutionId` path parameter.
      parameters:
      - description: The ID of the Solution
        explode: false
        in: path
        name: solutionId
        required: true
        schema:
          type: string
        style: simple
      - description: The ID of the client
        explode: false
        in: path
        name: clientId
        required: true
        schema:
          type: string
        style: simple
      responses:
        "204":
          description: The client was successfully deleted.
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed. The `solutionId` must be
            an URI.
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to missing authentication.
        "402":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to exceeded transaction
            count.
        "403":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to an invalid authentication.
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed. The Solution or the client
            with the given ID was not found.
      summary: Delete a specific authorized client (e.g. OAuth2) of a specific Solution
      tags:
      - Solutions
    get:
      description: |-
        Returns the authorized client (e.g. OAuth2) specified by the `clientId` path parameter,
        of the solution identified by the `solutionId` path parameter.
      parameters:
      - description: The ID of the Solution
        explode: false
        in: path
        name: solutionId
        required: true
        schema:
          type: string
        style: simple
      - description: The ID of the client
        explode: false
        in: path
        name: clientId
        required: true
        schema:
          type: string
        style: simple
      responses:
        "200":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Client'
          description: The request successfully returned the specific client of a
            Solution.
        "400":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed. The `solutionId` must be
            an URI.
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to missing authentication.
        "402":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to exceeded transaction
            count.
        "403":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to an invalid authentication.
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed. The Solution or the client
            with the given ID was not found.
      summary: Retrieve a specific authorized client (e.g. OAuth2) of a specific Solution
      tags:
      - Solutions
    put:
      description: |-
        Create or update an authorized client (e.g. OAuth2) specified by the `clientId` path parameter,
        of the solution identified by the `solutionId` path parameter.

        The client will be authorized to make requests in the context of the solution.
        The request body must be a JSON object containing the entries for one client.
      parameters:
      - description: The ID of the Solution
        explode: false
        in: path
        name: solutionId
        required: true
        schema:
          type: string
        style: simple
      - description: The ID of the client
        explode: false
        in: path
        name: clientId
        required: true
        schema:
          type: string
        style: simple
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/Client'
        description: JSON representation of the client to be modified.
        required: true
      responses:
        "201":
          description: The client was successfully created.
        "204":
          description: The client was successfully updated.
        "400":
          description: The request could not be completed. Either the body was no
            valid JSON or it did not contain an accepted subjectIssuer
        "401":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to missing authentication.
        "402":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to exceeded transaction
            count.
        "403":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed due to an invalid authentication.
        "404":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The request could not be completed. The Solution with the given
            ID was not found.
        "409":
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AdvancedError'
          description: The client ID and subject issuer combination is already used.
      summary: Create or update a specific authorized client (e.g. OAuth2) of a specific
        Solution
      tags:
      - Solutions
components:
  parameters:
    ifMatchHeaderParamHash:
      description: |-
        The `If-Match` header which has to conform to RFC-7232 (Conditional Requests). Common usages are:
          * optimistic locking by specifying the `ETag` from a previous HTTP response, e.g. `If-Match: "hash:a75ece4e"`
          * retrieving or modifying a resource only if it already exists, e.g. `If-Match: *`
      explode: false
      in: header
      name: If-Match
      required: false
      schema:
        type: string
      style: simple
    ifMatchHeaderParam:
      description: |-
        The `If-Match` header, which has to conform to RFC-7232 (Conditional Requests). Common usages are:
          * optimistic locking by specifying the `ETag` from a previous GET response, e.g. `If-Match: "rev:4711"`
          * retrieving or modifying a resource only if it already exists, e.g. `If-Match: *`
      explode: false
      in: header
      name: If-Match
      required: false
      schema:
        type: string
      style: simple
    ifNoneMatchHeaderParam:
      description: 'The `If-None-Match` header, which has to conform to RFC-7232 (Conditional
        Requests). A common usage scenario is to modify a resource only if it does
        not yet exist, thus to create it, by specifying `If-None-Match: *`.'
      explode: false
      in: header
      name: If-None-Match
      required: false
      schema:
        type: string
      style: simple
    featureIdPathPathParam:
      description: The ID of the feature - has to conform to RFC-3986 (URI)
      explode: false
      in: path
      name: featureId
      required: true
      schema:
        type: string
      style: simple
    attributePathPathParam:
      description: The path to the attribute, e.g. **manufacturer/name**
      explode: false
      in: path
      name: attributePath
      required: true
      schema:
        type: string
      style: simple
    thingIdPathParam:
      description: |-
        The ID of a thing needs to follow the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).

        The namespace needs to be registered for your solution
      explode: false
      in: path
      name: thingId
      required: true
      schema:
        type: string
      style: simple
    policyIdPathParam:
      description: |-
        The ID of the policy needs to follow the namespaced entity ID notation (see [Ditto documentation on namespaced entity IDs](https://www.eclipse.org/ditto/basic-namespaces-and-names.html#namespaced-id)).

        The namespace needs to:
        * conform to the reverse domain name notation
        * be registered for your solution
      explode: false
      in: path
      name: policyId
      required: true
      schema:
        type: string
      style: simple
    messageSubjectPathParam:
      description: The subject of the Message - has to conform to RFC-3986 (URI)
      explode: false
      in: path
      name: messageSubject
      required: true
      schema:
        type: string
      style: simple
    messageClaimTimeoutParam:
      description: |-
        Contains an optional timeout (in seconds) of how long to wait for the Claim response and therefore block the
        HTTP request. Default value (if omitted): 60 seconds. Maximum value: 600 seconds. A value of 0 seconds applies
        fire and forget semantics for the message.
      explode: true
      in: query
      name: timeout
      required: false
      schema:
        type: integer
      style: form
    messageTimeoutParam:
      description: |-
        Contains an optional timeout (in seconds) of how long to wait for the message response and therefore block the
        HTTP request. Default value (if omitted): 10 seconds. Maximum value: 60 seconds. A value of 0 seconds applies
        fire and forget semantics for the message.
      explode: true
      in: query
      name: timeout
      required: false
      schema:
        type: integer
      style: form
    requestedAcksParam:
      description: |-
        Contains the "requested acknowledgements" for this modifying request as comma separated list. The HTTP call will
        block until all requested acknowledgements were aggregated or will time out based on the specified `timeout`
        parameter.

        The default (if omitted) requested acks is `requested-acks=twin-persisted` which will block the
        HTTP call until the change was persited to the twin.
      explode: true
      in: query
      name: requested-acks
      required: false
      schema:
        type: string
      style: form
    timeoutParam:
      description: |-
        Defines how long the backend should wait for completion of the request, e.g. applied when waiting for requested
        acknowledgements via the `requested-acks` param. Can be specified without unit (then seconds are assumed) or
        together with `s`, `ms` or `m` unit. Example: `42s`, `1m`.

        The default (if omitted) timeout is `10s`. Maximum value: `60s`.

        A value of `0` applies fire and forget semantics for the command resulting in setting `response-required=false`.
      explode: true
      in: query
      name: timeout
      required: false
      schema:
        type: string
      style: form
    responseRequiredParam:
      description: |-
        Defines whether a response is required to the API call or not - if set to `false` the response will directly
        sent back with a status code of `202` (Accepted).

        The default (if ommited) response is `true`.
      explode: true
      in: query
      name: response-required
      required: false
      schema:
        type: boolean
      style: form
    labelPathParam:
      description: The label of a policy entry
      explode: false
      in: path
      name: label
      required: true
      schema:
        type: string
      style: simple
    subjectIdPathParam:
      description: The ID of an (Authorization) Subject
      explode: false
      in: path
      name: subjectId
      required: true
      schema:
        type: string
      style: simple
    resourcePathPathParam:
      description: The path of an (Authorization) Resource
      explode: false
      in: path
      name: resourcePath
      required: true
      schema:
        type: string
      style: simple
    propertyPathPathParam:
      description: The path to the property
      explode: false
      in: path
      name: propertyPath
      required: true
      schema:
        type: string
      style: simple
    thingFieldsQueryParam:
      description: |-
        Contains a comma-separated list of fields to be included in the returned
        JSON. attributes can be selected in the same manner.

        #### Selectable fields

        * `thingId`
        * `policyId`
        * `definition`
        * `attributes`

           Supports selecting arbitrary sub-fields by using a comma-separated list:
            * several attribute paths can be passed as a comma-separated list of JSON pointers (RFC-6901)

              For example:
                * `?fields=attributes/model` would select only `model` attribute value (if present)
                * `?fields=attributes/model,attributes/location` would select only `model` and
                   `location` attribute values (if present)

          Supports selecting arbitrary sub-fields of objects by wrapping sub-fields inside parentheses `( )`:
            * a comma-separated list of sub-fields (a sub-field is a JSON pointer (RFC-6901)
              separated with `/`) to select

            * sub-selectors can be used to request only specific sub-fields by placing expressions
              in parentheses `( )` after a selected subfield

              For example:
               * `?fields=attributes(model,location)` would select only `model`
                  and `location` attribute values (if present)
               * `?fields=attributes(coffeemaker/serialno)` would select the `serialno` value
                  inside the `coffeemaker` object
               * `?fields=attributes/address/postal(city,street)` would select the `city` and
                  `street` values inside the `postal` object inside the `address` object

        * `features`

          Supports selecting arbitrary fields in features similar to `attributes` (see also features documentation for more details)

        * `_namespace`

          Specifically selects the namespace also contained in the `thingId`

        * `_revision`

          Specifically selects the revision of the thing. The revision is a counter, which is incremented on each modification of a thing.

        * `_modified`

          Specifically selects the modified timestamp of the thing in ISO-8601 UTC format. The timestamp is set on each modification of a thing.

        * `_policy`

          Specifically selects the content of the policy associated to the thing. (By default, only the policyId is returned.)

        #### Examples

        * `?fields=thingId,attributes,features`
        * `?fields=attributes(model,manufacturer),features`
      explode: true
      in: query
      name: fields
      required: false
      schema:
        type: string
      style: form
    attributesFieldsQueryParam:
      description: |-
        Contains a comma-separated list of fields from the attributes to be
        included in the returned JSON.

        #### Selectable fields

        Supports selecting arbitrary sub-fields as defined in the attributes by
        using a comma-separated list:
          * several properties paths can be passed as a comma-separated list of JSON pointers (RFC-6901)

            For example:
              * `?fields=model` would select only `model` attribute value (if present)
              * `?fields=model,make` would select `model` and `make` attribute values (if present)

        Supports selecting arbitrary sub-fields of objects by wrapping sub-fields
        inside parentheses `( )`:
          * a comma-separated list of sub-fields (a sub-field is a JSON pointer (RFC-6901) separated with `/`) to select
          * sub-selectors can be used to request only specific sub-fields by placing expressions in parentheses `( )` after a selected subfield

            For example:
             * `?fields=location(longitude,latitude)` would select the `longitude` and `latitude` value inside the `location` attribute

        #### Examples

        * `?fields=model,make,location(longitude,latitude)`

        * `?fields=listOfAddresses/postal(city,street))`
      explode: true
      in: query
      name: fields
      required: false
      schema:
        type: string
      style: form
    propertiesFieldsQueryParam:
      description: |-
        Contains a comma-separated list of fields from the properties to be
        included in the returned JSON.

        #### Selectable fields

        Supports selecting arbitrary sub-fields as defined in the properties by
        using a comma-separated list:
          * several properties paths can be passed as a comma-separated list of JSON pointers (RFC-6901)

            For example:
              * `?fields=temperature` would select only `temperature` property value (if present)
              * `?fields=temperature,humidity` would select only `temperature` and `humidity` property values (if present)

        Supports selecting arbitrary sub-fields of objects by wrapping sub-fields
        inside parentheses `( )`:
          * a comma-separated list of sub-fields (a sub-field is a JSON pointer (RFC-6901) separated with `/`) to select
          * sub-selectors can be used to request only specific sub-fields by placing expressions in parentheses `( )` after a selected subfield

            For example:
             * `?fields=location(longitude,latitude)` would select the `longitude` and `latitude` value inside the `location` property

        #### Examples

        * `?fields=temperature,humidity,location(longitude,latitude)`

        * `?fields=configuration,status(powerConsumption/watts)`
      explode: true
      in: query
      name: fields
      required: false
      schema:
        type: string
      style: form
    featuresFieldsQueryParam:
      description: |-
        Contains a comma-separated list of fields from one or more features to be
        included in the returned JSON.

        #### Selectable fields

        * `{featureId}` The ID of the feature to select properties in
          * `properties`
            Supports selecting arbitrary sub-fields by using a comma-separated list:
              * several properties paths can be passed as a comma-separated list of JSON pointers (RFC-6901)
                For example:
                  * `?fields={featureId}/properties/color` would select only `color` property value (if present) of the feature identified with `{featureId}`
                  * `?fields={featureId}/properties/color,properties/brightness` would select only `color` and `brightness` property values (if present) of the feature identified with `{featureId}`
            Supports selecting arbitrary sub-fields of objects by wrapping sub-fields inside parentheses `( )`:
              * a comma-separated list of sub-fields (a sub-field is a JSON pointer (RFC-6901) separated with `/`) to select
              * sub-selectors can be used to request only specific sub-fields by placing expressions in parentheses `( )` after a selected subfield
                For example:
                 * `?fields={featureId}/properties(color,brightness)` would select only `color` and `brightness` property values (if present) of the feature identified with `{featureId}`
                 * `?fields={featureId}/properties(location/longitude)` would select the `longitude` value inside the `location` object of the feature identified with `{featureId}`


        #### Examples
        * `?fields=EnvironmentScanner/properties(temperature,humidity)`
        * `?fields=EnvironmentScanner/properties(temperature,humidity),Vehicle/properties/configuration`
      explode: true
      in: query
      name: fields
      required: false
      schema:
        type: string
      style: form
    featureFieldsQueryParam:
      description: |-
        Contains a comma-separated list of fields from the selected feature to be
        included in the returned JSON.

        #### Selectable fields

        * `properties`

          Supports selecting arbitrary sub-fields by using a comma-separated list:
            * several properties paths can be passed as a comma-separated list of JSON pointers (RFC-6901)

              For example:
                * `?fields=properties/color` would select only `color` property value (if present)
                * `?fields=properties/color,properties/brightness` would select only `color` and `brightness` property values (if present)

          Supports selecting arbitrary sub-fields of objects by wrapping sub-fields inside parentheses `( )`:
            * a comma-separated list of sub-fields (a sub-field is a JSON pointer (RFC-6901) separated with `/`) to select
            * sub-selectors can be used to request only specific sub-fields by placing expressions in parentheses `( )` after a selected subfield

              For example:
               * `?fields=properties(color,brightness)` would select only `color` and `brightness` property values (if present)
               * `?fields=properties(location/longitude)` would select the `longitude` value inside the `location` object

        #### Examples

        * `?fields=properties(color,brightness)`
      explode: true
      in: query
      name: fields
      required: false
      schema:
        type: string
      style: form
    solutionIdPathParam:
      description: The ID of the Solution
      explode: false
      in: path
      name: solutionId
      required: true
      schema:
        type: string
      style: simple
    clientIdPathParam:
      description: The ID of the client
      explode: false
      in: path
      name: clientId
      required: true
      schema:
        type: string
      style: simple
    connectionIdPathParam:
      description: The ID of the connection
      explode: false
      in: path
      name: connectionId
      required: true
      schema:
        type: string
      style: simple
    namespaceIdPathParam:
      description: The ID of the Namespace
      explode: false
      in: path
      name: namespaceId
      required: true
      schema:
        type: string
      style: simple
    searchFilter:
      description: |2-

        #### Filter predicates:

        * ```eq({property},{value})```  (i.e. equal to the given value)

        * ```ne({property},{value})```  (i.e. not equal to the given value)

        * ```gt({property},{value})```  (i.e. greater than the given value)

        * ```ge({property},{value})```  (i.e. equal to the given value or greater than it)

        * ```lt({property},{value})```  (i.e. lower than the given value or equal to it)

        * ```le({property},{value})```  (i.e. lower than the given value)

        * ```in({property},{value},{value},...)```  (i.e. contains at least one of the values listed)

        * ```like({property},{value})```  (i.e. contains values similar to the expressions listed)

        * ```exists({property})```  (i.e. all things in which the given path exists)


        Note: When using filter operations, only things with the specified properties are returned.
        For example, the filter `ne(attributes/owner, "SID123")` will only return things that do have
        the `owner` attribute.


        #### Logical operations:


        * ```and({query},{query},...)```

        * ```or({query},{query},...)```

        * ```not({query})```


        #### Examples:

        * ```eq(attributes/location,"kitchen")```

        * ```ge(thingId,"myThing1")```

        * ```exists(features/featureId)```

        * ```and(eq(attributes/location,"kitchen"),eq(attributes/color,"red"))```

        * ```or(eq(attributes/location,"kitchen"),eq(attributes/location,"living-room"))```

        * ```like(attributes/key1,"known-chars-at-start*")```

        * ```like(attributes/key1,"*known-chars-at-end")```

        * ```like(attributes/key1,"*known-chars-in-between*")```

        * ```like(attributes/key1,"just-som?-char?-unkn?wn")```

        The `like` filters with the wildcard `*` at the beginning can slow down your search request.
      explode: true
      in: query
      name: filter
      required: false
      schema:
        type: string
      style: form
    namespacesFilter:
      description: |-
        A comma-separated list of namespaces. This list is used to limit the query to things in the given namespaces
        only.
        If this parameter is omitted, all registered namespaces of your solution will be queried. The solution is
        determined by the API token sent with the request.


        #### Examples:

        * `?namespaces=com.example.namespace`

        * `?namespaces=com.example.namespace1,com.example.namespace2`
      explode: true
      in: query
      name: namespaces
      required: false
      schema:
        type: string
      style: form
  requestBodies:
    Payload:
      content:
        application/json:
          schema:
            type: string
        application/octet-stream:
          schema:
            type: string
        text/plain:
          schema:
            type: string
      description: |-
        Payload of the message with max size of 250 kB. It can be any HTTP
        supported content, including binary content.
    Definition:
      content:
        application/json:
          example: '"example:test:definition"'
          schema:
            $ref: '#/components/schemas/Definition'
      description: |-
        JSON string of the definition to be modified. Consider that the
        value has to be a JSON string or `null`, examples:

          * an string: `{ ""value"}` -}. Currently the definition should follow the pattern: [_a-zA-Z0-9\-]:[_a-zA-Z0-9\-]:[_a-zA-Z0-9\-]
          * an empty string: `""`
    Attributes:
      content:
        application/json:
          example:
            manufacturer:
              name: ACME demo corp.
              location: Berlin, main floor
            coffeemaker:
              serialno: "42"
              model: Speaking coffee machine
          schema:
            $ref: '#/components/schemas/Attributes'
      description: |-
        JSON object of all attributes to be modified at once. Consider that the
        value has to be a JSON object or `null`.

        Examples:
         * an empty object: `{}` - would just delete all old attributes
         * a simple object: `{ "key": "value"}` - We strongly recommend to use a restricted set of characters for the key (identifier), as the key might be needed for the (URL) path later.<br> Currently these identifiers should follow the pattern: [_a-zA-Z][_a-zA-Z0-9\-]*
         * a nested object as shown in the example value
      required: true
    Value:
      content:
        application/json:
          schema:
            example: {}
            type: object
      description: |-
        JSON representation of the value to be created/updated. This may be as
        well `null` or an empty object.

        Consider that the value has to be a JSON value, examples:

          * for a number, the JSON value is the number: `42`

          * for a string, the JSON value must be quoted: `"aString"`

          * for a boolean, the JSON value is the boolean: `true`

          * for an object, the JSON value is the object: `{ "key": "value"}` -} We strongly recommend to use a restricted set of characters for the key (identifier). Currently these identifiers should follow the pattern: [_a-zA-Z][_a-zA-Z0-9\-]*

          * for an list, the JSON value is the list: `[ 1,2,3 ]`
      required: true
  responses:
    entityTooLarge:
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/AdvancedError'
      description: The created or modified entity is larger than the accepted limit
        of 100 kB.
    messageTooLarge:
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/AdvancedError'
      description: The size of the send message is larger than the accepted limit
        of 250 kB.
    messageTimeout:
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/AdvancedError'
      description: The request could not be completed as there is no consumer for
        this message connected.
    notModified:
      description: |-
        The (sub-)resource has not been modified. This happens if you specified a If-None-Match header, which
         matches the current ETag of the (sub-)resource.
      headers:
        ETag:
          description: |-
            The (current server-side) ETag for this (sub-)resource. For top-level resources it is in the format
            "rev:[revision]", for sub-resources it has the format "hash:[calculated-hash]".
          explode: false
          schema:
            type: string
          style: simple
    preconditionFailed:
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/AdvancedError'
      description: |-
        A precondition for reading or writing the (sub-)resource failed. This will happen for write requests, if you
        specified an If-Match or If-None-Match header, which fails the precondition check against the current ETag of
        the (sub-)resource. For read requests, this error may only happen for a failing If-Match header. In case of a
        failing If-None-Match header for a read request, status 304 will be returned instead.
      headers:
        ETag:
          description: |-
            The (current server-side) ETag for this (sub-)resource. For top-level resources it is in the format
            "rev:[revision]", for sub-resources it has the format "hash:[calculated-hash]".
          explode: false
          schema:
            type: string
          style: simple
  schemas:
    Error:
      properties:
        status:
          description: The HTTP status of the error
          type: integer
        message:
          description: The message of the error - what went wrong
          type: string
        description:
          description: A description how to fix the error or more details
          type: string
        href:
          description: A link to further information about the error and how to fix
            it
          type: string
      required:
      - message
      - status
    AdvancedError:
      properties:
        status:
          description: The HTTP status of the error
          type: integer
        error:
          description: The error code of the occurred exception
          type: string
        message:
          description: The message of the error - what went wrong
          type: string
        description:
          description: A description how to fix the error or more details
          type: string
        href:
          description: A link to further information about the error and how to fix
            it
          type: string
      required:
      - error
      - message
      - status
    Attributes:
      description: An arbitrary JSON object describing the attributes of a thing.
      type: object
    Definition:
      description: A single fully qualified identifier of a definition in the form
        'namespace:name:version'
      pattern: ([_a-zA-Z0-9\-.]+):([_a-zA-Z0-9\-.]+):([_a-zA-Z0-9\-.]+)
      type: string
    FeatureDefinition:
      description: The definitions of a feature.
      items:
        description: A single fully qualified identifier of a feature definition in
          the form 'namespace:name:version'
        pattern: ([_a-zA-Z0-9\-.]+):([_a-zA-Z0-9\-.]+):([_a-zA-Z0-9\-.]+)
        type: string
      type: array
    FeatureProperties:
      description: An arbitrary JSON object describing the properties of a feature.
      type: object
    Feature:
      example:
        definition:
        - definition
        - definition
        properties: '{}'
      properties:
        definition:
          description: The definitions of a feature.
          items:
            description: A single fully qualified identifier of a feature definition
              in the form 'namespace:name:version'
            pattern: ([_a-zA-Z0-9\-.]+):([_a-zA-Z0-9\-.]+):([_a-zA-Z0-9\-.]+)
            type: string
          type: array
        properties:
          description: An arbitrary JSON object describing the properties of a feature.
          type: object
      type: object
    Clients:
      description: Map of all authorized clients of a Solution.
      example:
        additionalClient:
          subjectIssuer: subjectIssuer
          clientId: clientId
        clientId1:
          subjectIssuer: subjectIssuer
          clientId: clientId
      properties:
        clientId1:
          $ref: '#/components/schemas/Client'
        additionalClient:
          $ref: '#/components/schemas/Client'
      type: object
    Client:
      description: An OAuth 2.0 client which is authorized to perform requests on
        behalf of the solution.
      example:
        subjectIssuer: subjectIssuer
        clientId: clientId
      properties:
        clientId:
          description: The ID of the OAuth client. The ID must be provided in the
            "azp" claim of a JWT.
          type: string
        subjectIssuer:
          description: Issuer for authorization subjects which identifies the associated
            OAuth 2.0 authorization server.
          type: string
      required:
      - default
      type: object
    Namespaces:
      additionalProperties:
        $ref: '#/components/schemas/NamespaceEntry'
      description: |-
        List of namespaces where the key represents the `namespaceId` of each
        namespace. The `namespaceId` key must be unique in the list.
      example:
        namespaceId1:
          default: true
          state: CREATED
      properties:
        namespaceId1:
          $ref: '#/components/schemas/DefaultNamespaceEntry'
      type: object
    DefaultNamespaceEntry:
      description: A default namespace entry.
      example:
        default: true
        state: CREATED
      properties:
        default:
          default: true
          description: Describes whether the namespace is the default for the Solution
          type: boolean
        state:
          default: CREATED
          description: Current state of the namespace (read-only).
          enum:
          - CREATED
          - PURGING
          type: string
      required:
      - default
      type: object
    NamespaceEntry:
      description: A namespace entry.
      example:
        default: false
        state: CREATED
      properties:
        default:
          default: false
          description: Describes whether the namespace is the default for the Solution
          type: boolean
        state:
          default: CREATED
          description: Current state of the namespace (read-only).
          enum:
          - CREATED
          - PURGING
          type: string
      required:
      - default
      type: object
    NamespacePurgingState:
      description: Status report of a namespace deletion process.
      example:
        currentStep: 6
        totalSteps: 1
        description: description
        type: solutions.responses:retrieveNamespacePurgingState
        namespaceName: namespaceName
        status: 0
      properties:
        type:
          default: solutions.responses:retrieveNamespacePurgingState
          description: Type of the status report.
          type: string
        status:
          default: 200
          description: HTTP status code of the status report.
          type: integer
        namespaceName:
          description: The namespace being deleted permanently.
          type: string
        currentStep:
          description: Ordinal number of the current step in the namespace deletion
            process.
          type: integer
        totalSteps:
          description: Amount of steps in the namespace deletion process.
          type: integer
        description:
          description: Description of the current step in the namespace deletion process.
          type: string
      type: object
    Usage:
      description: Object holding the data volume, transaction count and the time
        when this data was calculated.
      example:
        dataVolume:
          unit: unit
          size: 0
        timeOfCalculation: 2019-11-13T15:45:29.069Z
        transactionCount:
          value: 6
      properties:
        dataVolume:
          $ref: '#/components/schemas/DataVolume'
        transactionCount:
          $ref: '#/components/schemas/TransactionCount'
        timeOfCalculation:
          description: the time when this usage was calculated. Format of the string
            complies with ISO-8601.
          example: 2019-11-13T15:45:29.069Z
          type: string
      type: object
    DataVolume:
      description: Object holding the data volume of a solution.
      example:
        unit: unit
        size: 0
      properties:
        size:
          description: the amount of data dolume.
          type: integer
        unit:
          description: the unit to interpret the size.
          type: string
      type: object
    TransactionCount:
      description: Object holding the transaction count of a solution.
      example:
        value: 6
      properties:
        value:
          description: the amount of transactions performed with a solution.
          type: integer
      type: object
    PlanType:
      description: The type of the booked plan.
      enum:
      - Free
      - Starter
      - Starter1
      - Standard
      - Standard1
      type: string
    UsageLimits:
      example:
        transactionCount: 6.027456183070403
        dataVolumeInBytes: 0.8008281904610115
      properties:
        dataVolumeInBytes:
          description: The maximum data volume that is allowed to be used for the
            booked plan.
          type: number
        transactionCount:
          description: The maximum number of transactions that is allowed to be used
            for the booked plan.
          type: number
      type: object
    Solution:
      example:
        apiToken: apiToken
        clients:
          additionalClient:
            subjectIssuer: subjectIssuer
            clientId: clientId
          clientId1:
            subjectIssuer: subjectIssuer
            clientId: clientId
        policyId: policyId
        solutionId: solutionId
        serviceName: serviceName
        planObject:
          usageLimits:
            transactionCount: 6.027456183070403
            dataVolumeInBytes: 0.8008281904610115
        status:
          dataVolume: within plan
          transactionCount: within plan
        customer:
          name: name
          email: email
          info: info
        namespaces:
          namespaceId1:
            default: true
            state: CREATED
        effectiveUsageLimits:
          transactionCount: 6.027456183070403
          dataVolumeInBytes: 0.8008281904610115
      properties:
        solutionId:
          description: Unique identifier representing a specific Solution
          type: string
        apiToken:
          description: A token to identify requests of users associated with the solution
          type: string
        plan:
          $ref: '#/components/schemas/PlanType'
        planObject:
          $ref: '#/components/schemas/Solution_planObject'
        serviceName:
          description: The name of the service
          type: string
        status:
          $ref: '#/components/schemas/Solution_status'
        customer:
          $ref: '#/components/schemas/Solution_customer'
        namespaces:
          $ref: '#/components/schemas/Namespaces'
        effectiveUsageLimits:
          $ref: '#/components/schemas/UsageLimits'
        clients:
          $ref: '#/components/schemas/Clients'
        policyId:
          description: The policy ID used for controlling access to this solution,
            managed by resource `/policies/{policyId}`
          type: string
      required:
      - apiToken
      - customer
      - effectiveUsageLimits
      - plan
      - planObject
      - policyId
      - serviceName
      - solutionId
      - status
      type: object
    Connection:
      example:
        sources:
        - payloadMapping:
          - '["Ditto","status"]'
          - '["Ditto","status"]'
          addresses:
          - addresses
          - addresses
          consumerCount: 0
          enforcement:
            input: '{{ header:device_id }}'
            filters:
            - '["{{ thing:id }}","{{ thing:namespace }}/{{ thing:name }}"]'
            - '["{{ thing:id }}","{{ thing:namespace }}/{{ thing:name }}"]'
          authorizationContext:
          - '["ditto:myAuthorizationSubject","device:{{ header:device_id }}"]'
          - '["ditto:myAuthorizationSubject","device:{{ header:device_id }}"]'
        - payloadMapping:
          - '["Ditto","status"]'
          - '["Ditto","status"]'
          addresses:
          - addresses
          - addresses
          consumerCount: 0
          enforcement:
            input: '{{ header:device_id }}'
            filters:
            - '["{{ thing:id }}","{{ thing:namespace }}/{{ thing:name }}"]'
            - '["{{ thing:id }}","{{ thing:namespace }}/{{ thing:name }}"]'
          authorizationContext:
          - '["ditto:myAuthorizationSubject","device:{{ header:device_id }}"]'
          - '["ditto:myAuthorizationSubject","device:{{ header:device_id }}"]'
        mappingContext:
          outgoingScript: outgoingScript
          loadLongJS: true
          incomingScript: incomingScript
          loadBytebufferJS: true
        uri: uri
        targets:
        - payloadMapping:
          - '["javascript"]'
          - '["javascript"]'
          address: address
          topics:
          - _/_/things/twin/events
          - _/_/things/twin/events
          authorizationContext:
          - '["ditto:myAuthorizationSubject"]'
          - '["ditto:myAuthorizationSubject"]'
        - payloadMapping:
          - '["javascript"]'
          - '["javascript"]'
          address: address
          topics:
          - _/_/things/twin/events
          - _/_/things/twin/events
          authorizationContext:
          - '["ditto:myAuthorizationSubject"]'
          - '["ditto:myAuthorizationSubject"]'
        tags:
        - tags
        - tags
        validateCertificates: true
        name: name
        connectionStatus:
          sourceStatus:
          - address: address
            client: client
            statusDetails: statusDetails
            inStateSince: inStateSince
            type: client
          - address: address
            client: client
            statusDetails: statusDetails
            inStateSince: inStateSince
            type: client
          connectedSince: 2019-01-21T08:57:24.710Z
          connectionStatus: ""
          connectionId: connectionId
          clientStatus:
          - address: address
            client: client
            statusDetails: statusDetails
            inStateSince: inStateSince
            type: client
          - address: address
            client: client
            statusDetails: statusDetails
            inStateSince: inStateSince
            type: client
          targetStatus:
          - address: address
            client: client
            statusDetails: statusDetails
            inStateSince: inStateSince
            type: client
          - address: address
            client: client
            statusDetails: statusDetails
            inStateSince: inStateSince
            type: client
          liveStatus: ""
        failoverEnabled: true
        id: id
        specificConfig: '{}'
        clientCount: 6.027456183070403
        mappingDefinitions:
          key:
            options: '{}'
            mappingEngine: mappingEngine
      properties:
        id:
          description: The generated unique identifier of the connection
          type: string
        name:
          description: The name of the connection
          type: string
        connectionType:
          $ref: '#/components/schemas/ConnectionType'
        connectionStatus:
          $ref: '#/components/schemas/ConnectionStatus'
        uri:
          description: The URI of the connection
          type: string
        sources:
          description: The subscription sources of this connection
          items:
            $ref: '#/components/schemas/Source'
          title: The subscription sources of this connection
          type: array
          uniqueItems: true
        targets:
          description: The publish targets of this connection
          items:
            $ref: '#/components/schemas/Target'
          title: The publish targets of this connection
          type: array
          uniqueItems: true
        specificConfig:
          description: Configuration which is only applicable for a specific connection
            type
          type: object
        clientCount:
          description: How many clients on different cluster nodes should establish
            the connection
          type: number
        failoverEnabled:
          description: Whether or not failover is enabled for this connection
          type: boolean
        validateCertificates:
          description: Whether or not to validate server certificates on connection
            establishment
          type: boolean
        mappingDefinitions:
          additionalProperties:
            $ref: '#/components/schemas/PayloadMappingDefinition'
          description: |-
            List of mapping definitions where the key represents the ID of each mapping that can be used in sources and
            targets to reference a mapping.
          type: object
        mappingContext:
          $ref: '#/components/schemas/MappingContext'
        tags:
          description: The tags of the connection
          items:
            type: string
          type: array
      required:
      - connectionStatus
      - connectionType
      - sources
      - targets
      - uri
      type: object
    NewConnection:
      example:
        sources:
        - payloadMapping:
          - '["Ditto","status"]'
          - '["Ditto","status"]'
          addresses:
          - addresses
          - addresses
          consumerCount: 0
          enforcement:
            input: '{{ header:device_id }}'
            filters:
            - '["{{ thing:id }}","{{ thing:namespace }}/{{ thing:name }}"]'
            - '["{{ thing:id }}","{{ thing:namespace }}/{{ thing:name }}"]'
          authorizationContext:
          - '["ditto:myAuthorizationSubject","device:{{ header:device_id }}"]'
          - '["ditto:myAuthorizationSubject","device:{{ header:device_id }}"]'
        - payloadMapping:
          - '["Ditto","status"]'
          - '["Ditto","status"]'
          addresses:
          - addresses
          - addresses
          consumerCount: 0
          enforcement:
            input: '{{ header:device_id }}'
            filters:
            - '["{{ thing:id }}","{{ thing:namespace }}/{{ thing:name }}"]'
            - '["{{ thing:id }}","{{ thing:namespace }}/{{ thing:name }}"]'
          authorizationContext:
          - '["ditto:myAuthorizationSubject","device:{{ header:device_id }}"]'
          - '["ditto:myAuthorizationSubject","device:{{ header:device_id }}"]'
        mappingContext:
          outgoingScript: outgoingScript
          loadLongJS: true
          incomingScript: incomingScript
          loadBytebufferJS: true
        uri: uri
        targets:
        - payloadMapping:
          - '["javascript"]'
          - '["javascript"]'
          address: address
          topics:
          - _/_/things/twin/events
          - _/_/things/twin/events
          authorizationContext:
          - '["ditto:myAuthorizationSubject"]'
          - '["ditto:myAuthorizationSubject"]'
        - payloadMapping:
          - '["javascript"]'
          - '["javascript"]'
          address: address
          topics:
          - _/_/things/twin/events
          - _/_/things/twin/events
          authorizationContext:
          - '["ditto:myAuthorizationSubject"]'
          - '["ditto:myAuthorizationSubject"]'
        tags:
        - tags
        - tags
        validateCertificates: true
        name: name
        connectionStatus:
          sourceStatus:
          - address: address
            client: client
            statusDetails: statusDetails
            inStateSince: inStateSince
            type: client
          - address: address
            client: client
            statusDetails: statusDetails
            inStateSince: inStateSince
            type: client
          connectedSince: 2019-01-21T08:57:24.710Z
          connectionStatus: ""
          connectionId: connectionId
          clientStatus:
          - address: address
            client: client
            statusDetails: statusDetails
            inStateSince: inStateSince
            type: client
          - address: address
            client: client
            statusDetails: statusDetails
            inStateSince: inStateSince
            type: client
          targetStatus:
          - address: address
            client: client
            statusDetails: statusDetails
            inStateSince: inStateSince
            type: client
          - address: address
            client: client
            statusDetails: statusDetails
            inStateSince: inStateSince
            type: client
          liveStatus: ""
        failoverEnabled: true
        specificConfig: '{}'
        clientCount: 0.8008281904610115
        mappingDefinitions:
          key:
            options: '{}'
            mappingEngine: mappingEngine
      properties:
        name:
          description: The name of the connection
          type: string
        connectionType:
          $ref: '#/components/schemas/ConnectionType'
        connectionStatus:
          $ref: '#/components/schemas/ConnectionStatus'
        uri:
          description: The URI of the connection
          type: string
        sources:
          description: The subscription sources of this connection
          items:
            $ref: '#/components/schemas/Source'
          title: The subscription sources of this connection
          type: array
          uniqueItems: true
        targets:
          description: The publish targets of this connection
          items:
            $ref: '#/components/schemas/Target'
          title: The publish targets of this connection
          type: array
          uniqueItems: true
        specificConfig:
          description: Configuration which is only applicable for a specific connection
            type
          type: object
        clientCount:
          description: How many clients on different cluster nodes should establish
            the connection
          type: number
        failoverEnabled:
          description: Whether or not failover is enabled for this connection
          type: boolean
        validateCertificates:
          description: Whether or not to validate server certificates on connection
            establishment
          type: boolean
        mappingDefinitions:
          additionalProperties:
            $ref: '#/components/schemas/PayloadMappingDefinition'
          description: |-
            List of mapping definitions where the key represents the ID of each mapping that can be used in sources and
            targets to reference a mapping.
          type: object
        mappingContext:
          $ref: '#/components/schemas/MappingContext'
        tags:
          description: The tags of the connection
          items:
            type: string
          type: array
      required:
      - connectionStatus
      - connectionType
      - sources
      - targets
      - uri
      type: object
    Sources:
      description: The subscription sources of this connection
      items:
        $ref: '#/components/schemas/Source'
      title: The subscription sources of this connection
      type: array
      uniqueItems: true
    Source:
      description: A subscription source subscribed by this connection
      example:
        payloadMapping:
        - '["Ditto","status"]'
        - '["Ditto","status"]'
        addresses:
        - addresses
        - addresses
        consumerCount: 0
        enforcement:
          input: '{{ header:device_id }}'
          filters:
          - '["{{ thing:id }}","{{ thing:namespace }}/{{ thing:name }}"]'
          - '["{{ thing:id }}","{{ thing:namespace }}/{{ thing:name }}"]'
        authorizationContext:
        - '["ditto:myAuthorizationSubject","device:{{ header:device_id }}"]'
        - '["ditto:myAuthorizationSubject","device:{{ header:device_id }}"]'
      properties:
        addresses:
          description: The source addresses this connection consumes messages from
          items:
            description: A source address to consume messages from
            title: Source address
            type: string
          title: Array of source addresses
          type: array
          uniqueItems: true
        consumerCount:
          default: 1
          description: The number of consumers that should be attached to each source
            address
          title: Consumer count
          type: integer
        authorizationContext:
          description: The authorization context defines all authorization subjects
            associated for this source
          items:
            description: |-
              An authorization subject associated with this source.
              You can either use a fixed subject or use a placeholder that resolves header values from incoming messages.
              For example to use the `device_id` header in the subject, you can specify the placeholder
              `{{ header:device_id }}` which is then replaced by Ditto when a message from this source is processed.
              By using a placeholder you can access any header value: `{{ header:<any-header-name> }}`
            example: '["ditto:myAuthorizationSubject","device:{{ header:device_id
              }}"]'
            title: Authorization Subject
            type: string
          title: The authorization context
          type: array
          uniqueItems: true
        enforcement:
          $ref: '#/components/schemas/Enforcement_configuration'
        payloadMapping:
          description: A list of payload mappings that are applied to messages received
            via this source. If no payload mapping is specified the standard Ditto
            mapping is used as default.
          items:
            description: References a payload mapping definition by its ID (the key
              of the PayloadMappingDefinition)
            example: '["Ditto","status"]'
            title: Payload Mapping
            type: string
          title: The payload mappings
          type: array
      title: Source
      type: object
    Targets:
      description: The publish targets of this connection
      items:
        $ref: '#/components/schemas/Target'
      title: The publish targets of this connection
      type: array
      uniqueItems: true
    Target:
      description: A publish target served by this connection
      example:
        payloadMapping:
        - '["javascript"]'
        - '["javascript"]'
        address: address
        topics:
        - _/_/things/twin/events
        - _/_/things/twin/events
        authorizationContext:
        - '["ditto:myAuthorizationSubject"]'
        - '["ditto:myAuthorizationSubject"]'
      properties:
        address:
          description: |-
            The target address where events, commands and messages are published to.
            The following placeholders are allowed within the target address:

            * Thing ID: `{{ thing:id }}`

            * Thing Namespace: `{{ thing:namespace }}`

            * Thing Name: `{{ thing:name }}` (the part of the ID without the namespace)
          title: Target address
          type: string
        topics:
          description: The topics to which this target is registered for
          items:
            description: |-
              Contains the type of messages that are delivered to this target. You can receive

              * Thing events: `_/_/things/twin/events` (notification about twin change)

              * Live events: `_/_/things/live/events`

              * Live commands: `_/_/things/live/commands`

              * Live messages: `_/_/things/live/messages`
            enum:
            - _/_/things/twin/events
            - _/_/things/live/commands
            - _/_/things/live/events
            - _/_/things/live/messages
            title: Subscribed topics
            type: string
          title: Topics
          type: array
          uniqueItems: true
        authorizationContext:
          description: The authorization context defines all authorization subjects
            associated for this target
          items:
            description: An authorization subject associated with this target
            example: '["ditto:myAuthorizationSubject"]'
            title: Authorization Subject
            type: string
          title: The authorisation context
          type: array
          uniqueItems: true
        payloadMapping:
          description: A list of payload mappings that are applied to messages sent
            via this target. If no payload mapping is specified the standard Ditto
            mapping is used as default.
          items:
            description: References a payload mapping definition by its ID (the key
              of the PayloadMappingDefinition)
            example: '["javascript"]'
            title: Payload Mapping
            type: string
          title: The payload mappings
          type: array
      title: Target
      type: object
    ConnectionType:
      description: The type of a connection
      enum:
      - amqp-091
      - amqp-10
      - mqtt
      - kafka
      type: string
    ConnectivityStatus:
      description: The status of a connection or resource
      enum:
      - open
      - closed
      - failed
      - unknown
      type: string
    PayloadMappingDefinitions:
      additionalProperties:
        $ref: '#/components/schemas/PayloadMappingDefinition'
      description: |-
        List of mapping definitions where the key represents the ID of each mapping that can be used in sources and
        targets to reference a mapping.
      type: object
    PayloadMappingDefinition:
      description: A mapping definition consisting of the used mappingEngine and the
        options required by this engine.
      example:
        options: '{}'
        mappingEngine: mappingEngine
      properties:
        mappingEngine:
          description: |-
            The mapping engine used to process incoming and outgoing messages. Available mapping engines are
            `JavaScript`, `Normalized`, `ConnectionStatus`, `Ditto`.
          type: string
        options:
          description: |-
            Configuration options specific to the used mapping engine:

            #### JavaScript
              * `incomingScript` (`string`, required): The mapping script for incoming messages
              * `outgoingScript` (`string`, required): The mapping script for outgoing messages
              * `loadBytebufferJS` (`boolean`, optional): Whether or not ByteBufferJS library should be included
                (default: `false`)
              * `loadLongJS` (`boolean`, optional): Whether or not LongJS library should be included (default: `false`)

            #### Normalized
              * `fields` (`string`, optional): Comma separated list of fields included in the normalized message
                (default: all fields included)

            #### ConnectionStatus
              * `thingId` (`string`, required): The ID of the thing
              * `featureId` (`string`, optional): The ID of the modified feature (default: `ConnectionStatus`)

            #### Ditto
              * no options required
          type: object
      required:
      - mappingEngine
      - options
      type: object
    MappingContext:
      deprecated: true
      description: |-
        MappingContext to apply in this connection containing JavaScript scripts mapping from external messages to
        internal Ditto Protocol messages. Usage of MappingContext is deprecated, use PayloadMappingDefinitions instead.
      example:
        outgoingScript: outgoingScript
        loadLongJS: true
        incomingScript: incomingScript
        loadBytebufferJS: true
      properties:
        incomingScript:
          description: The mapping script for incoming messages
          type: string
        outgoingScript:
          description: The mapping script for outgoing messages
          type: string
        loadBytebufferJS:
          description: Whether or not ByteBufferJS library should be included
          type: boolean
        loadLongJS:
          description: Whether or not LongJS library should be included
          type: boolean
      required:
      - incomingScript
      - loadBytebufferJS
      - loadLongJS
      - outgoingScript
      type: object
    ConnectionStatus:
      description: Status of a connection and its resources
      example:
        sourceStatus:
        - address: address
          client: client
          statusDetails: statusDetails
          inStateSince: inStateSince
          type: client
        - address: address
          client: client
          statusDetails: statusDetails
          inStateSince: inStateSince
          type: client
        connectedSince: 2019-01-21T08:57:24.710Z
        connectionStatus: ""
        connectionId: connectionId
        clientStatus:
        - address: address
          client: client
          statusDetails: statusDetails
          inStateSince: inStateSince
          type: client
        - address: address
          client: client
          statusDetails: statusDetails
          inStateSince: inStateSince
          type: client
        targetStatus:
        - address: address
          client: client
          statusDetails: statusDetails
          inStateSince: inStateSince
          type: client
        - address: address
          client: client
          statusDetails: statusDetails
          inStateSince: inStateSince
          type: client
        liveStatus: ""
      properties:
        connectionId:
          description: The connection ID
          type: string
        connectionStatus:
          allOf:
          - $ref: '#/components/schemas/ConnectivityStatus'
          description: The desired/target status of the connection
        liveStatus:
          allOf:
          - $ref: '#/components/schemas/ConnectivityStatus'
          description: The current/actual status of the connection
        connectedSince:
          description: The timestamp since when the connection is connected
          example: 2019-01-21T08:57:24.710Z
          type: string
        clientStatus:
          description: The client states of the of the connection
          items:
            $ref: '#/components/schemas/ResourceStatus'
          type: array
        sourceStatus:
          description: The states of the sources the of the connection
          items:
            $ref: '#/components/schemas/ResourceStatus'
          type: array
        targetStatus:
          description: The states of the targets the of the connection
          items:
            $ref: '#/components/schemas/ResourceStatus'
          type: array
      required:
      - clientStatus
      - connectedSince
      - connectionId
      - connectionStatus
      - liveStatus
      - sourceStatus
      - targetStatus
      type: object
    ResourceStatus:
      description: The status of a single resource (e.g. a client or a source/target
        resource)
      example:
        address: address
        client: client
        statusDetails: statusDetails
        inStateSince: inStateSince
        type: client
      properties:
        type:
          description: The type of the resource
          enum:
          - client
          - source
          - target
          type: string
        client:
          description: A client identifier where the resource is held (e.g. a cluster
            instance ID)
          type: string
        address:
          description: The address information of the resource (optional)
          type: string
        status:
          $ref: '#/components/schemas/ConnectivityStatus'
        statusDetails:
          description: Details to the status of the resource
          type: string
        inStateSince:
          description: Date since when the resource is in the present state
          type: string
      required:
      - client
      - status
      - type
      type: object
    ConnectionMetrics:
      description: Metrics of a connection
      example:
        sourceMetrics:
          addressMetrics:
            key:
              consumed: ""
              enforced: ""
              mapped: ""
              dropped: ""
        connectionId: connectionId
        containsFailures: false
        connectionMetrics:
          inbound:
            consumed: ""
            enforced: ""
            mapped: ""
            dropped: ""
          outbound:
            dispatched: ""
            filtered: ""
            mapped: ""
            dropped: ""
            published: ""
        targetMetrics:
          addressMetrics:
            key:
              dispatched: ""
              filtered: ""
              mapped: ""
              dropped: ""
              published: ""
      properties:
        connectionId:
          description: The connection ID
          type: string
        containsFailures:
          description: Whether the connection metrics contains any failures
          example: false
          type: boolean
        connectionMetrics:
          $ref: '#/components/schemas/OverallConnectionMetrics'
        sourceMetrics:
          $ref: '#/components/schemas/SourceMetrics'
        targetMetrics:
          $ref: '#/components/schemas/TargetMetrics'
      required:
      - connectionId
      - connectionMetrics
      - containsFailures
      - sourceMetrics
      - targetMetrics
      type: object
    OverallConnectionMetrics:
      description: Overall metrics of the connection
      example:
        inbound:
          consumed: ""
          enforced: ""
          mapped: ""
          dropped: ""
        outbound:
          dispatched: ""
          filtered: ""
          mapped: ""
          dropped: ""
          published: ""
      properties:
        inbound:
          $ref: '#/components/schemas/InboundMetrics'
        outbound:
          $ref: '#/components/schemas/OutboundMetrics'
      required:
      - inbound
      - outbound
      type: object
    SourceMetrics:
      description: Source metrics of the connection
      example:
        addressMetrics:
          key:
            consumed: ""
            enforced: ""
            mapped: ""
            dropped: ""
      properties:
        addressMetrics:
          additionalProperties:
            $ref: '#/components/schemas/InboundMetrics'
          description: Contains "inbound" from external sources consumed metric counts
          type: object
      required:
      - addressMetrics
      type: object
    TargetMetrics:
      description: Target metrics of the connection
      example:
        addressMetrics:
          key:
            dispatched: ""
            filtered: ""
            mapped: ""
            dropped: ""
            published: ""
      properties:
        addressMetrics:
          additionalProperties:
            $ref: '#/components/schemas/OutboundMetrics'
          description: Contains "outbound" towards external targets messages metric
            counts
          type: object
      required:
      - addressMetrics
      type: object
    InboundMetrics:
      description: Metrics of an inbound (e.g. a Source) resource
      example:
        consumed: ""
        enforced: ""
        mapped: ""
        dropped: ""
      properties:
        consumed:
          allOf:
          - $ref: '#/components/schemas/TypedMetric'
          description: Contains from external sources consumed metric counts
        mapped:
          allOf:
          - $ref: '#/components/schemas/TypedMetric'
          description: Contains mapped (payload mapping) messages metric counts
        dropped:
          allOf:
          - $ref: '#/components/schemas/TypedMetric'
          description: Contains dropped (in the payload mapping) messages metric counts
        enforced:
          allOf:
          - $ref: '#/components/schemas/TypedMetric'
          description: Contains enforced (e.g. source address enforcement) messages
            metric counts
      required:
      - consumed
      - dropped
      - enforced
      - mapped
      type: object
    OutboundMetrics:
      description: Metrics of an outbound (e.g. a Target) resource
      example:
        dispatched: ""
        filtered: ""
        mapped: ""
        dropped: ""
        published: ""
      properties:
        dispatched:
          allOf:
          - $ref: '#/components/schemas/TypedMetric'
          description: Contains internally dispatched (e.g. a Ditto event) metric
            counts
        filtered:
          allOf:
          - $ref: '#/components/schemas/TypedMetric'
          description: Contains the metric counts for messages which passed the filter
            (e.g. namespace or RQL filter for events)
        mapped:
          allOf:
          - $ref: '#/components/schemas/TypedMetric'
          description: Contains mapped (payload mapping) messages metric counts
        dropped:
          allOf:
          - $ref: '#/components/schemas/TypedMetric'
          description: Contains dropped (in the payload mapping) messages metric counts
        published:
          allOf:
          - $ref: '#/components/schemas/TypedMetric'
          description: Contains published messages metric counts meaning those messages
            were published to the external source
      required:
      - dispatched
      - dropped
      - filtered
      - mapped
      - published
      type: object
    TypedMetric:
      description: Metrics of a single metric `type` containing "success" and "failure"
        metrics
      properties:
        success:
          allOf:
          - $ref: '#/components/schemas/SingleMetric'
          description: Contains the successfully processed message counts
        failure:
          allOf:
          - $ref: '#/components/schemas/SingleMetric'
          description: Contains the failed processed message counts
      required:
      - failure
      - success
      type: object
    SingleMetric:
      description: Contains a single metric consisting of several time intervals and
        counter values for those intervals including the last message date.
      properties:
        PT1M:
          description: The counter containing how many messages were processed in
            the last minute
          example: 0
          type: integer
        PT1H:
          description: The counter containing how many messages were processed in
            the last hour
          example: 42
          type: integer
        PT24H:
          description: The counter containing how many messages were processed in
            the last 24 hours / last day
          example: 46346
          type: integer
        lastMessageAt:
          description: The timestamp when the last message was processed
          example: 2019-01-21T08:57:24.710Z
          type: string
      required:
      - PT1H
      - PT1M
      - PT24H
      - lastMessageAt
      type: object
    ConnectionLogs:
      description: Log entries of a connection.
      example:
        enabledSince: 2019-01-21T08:57:24.710Z
        enabledUntil: 2019-01-22T08:57:24.710Z
        connectionId: 759304b8-8056-11e9-bc42-526af7764f64
        connectionLogs:
        - address: telemetry/the_hub
          correlationId: 759304b8-8056-11e9-bc42-526af7764f64
          message: Successfully connected to ... at ...
          timestamp: 2019-01-21T08:57:24.710Z
          thingId: com.bosch.iot.things:theThing
        - address: telemetry/the_hub
          correlationId: 759304b8-8056-11e9-bc42-526af7764f64
          message: Successfully connected to ... at ...
          timestamp: 2019-01-21T08:57:24.710Z
          thingId: com.bosch.iot.things:theThing
      properties:
        connectionId:
          description: ID of the connection for which the log entries were logged.
          example: 759304b8-8056-11e9-bc42-526af7764f64
          type: string
        connectionLogs:
          description: Log entries for the connection.
          items:
            $ref: '#/components/schemas/LogEntry'
          type: array
        enabledSince:
          description: Since when logging is enabled. Might be missing / null if logging
            is not enabled.
          example: 2019-01-21T08:57:24.710Z
          type: string
        enabledUntil:
          description: Until when logging is enabled. Might be missing / null if logging
            is not enabled.
          example: 2019-01-22T08:57:24.710Z
          type: string
      required:
      - connectionId
      - connectionLogs
      type: object
    LogEntry:
      description: Represents a log entry for a connection.
      example:
        address: telemetry/the_hub
        correlationId: 759304b8-8056-11e9-bc42-526af7764f64
        message: Successfully connected to ... at ...
        timestamp: 2019-01-21T08:57:24.710Z
        thingId: com.bosch.iot.things:theThing
      properties:
        timestamp:
          description: Timestamp of the log entry.
          example: 2019-01-21T08:57:24.710Z
          type: string
        correlationId:
          description: Correlation ID that is associated with the log entry.
          example: 759304b8-8056-11e9-bc42-526af7764f64
          type: string
        message:
          description: The log message.
          example: Successfully connected to ... at ...
          type: string
        category:
          $ref: '#/components/schemas/LogCategory'
        type:
          $ref: '#/components/schemas/LogType'
        level:
          $ref: '#/components/schemas/LogLevel'
        address:
          description: Connection address on which the log occured.
          example: telemetry/the_hub
          type: string
        thingId:
          description: The thing for which the log entry was created.
          example: com.bosch.iot.things:theThing
          type: string
      required:
      - category
      - correlationId
      - level
      - message
      - timestamp
      - type
      type: object
    LogCategory:
      description: A category to which the log entry can be referred to.
      enum:
      - source
      - target
      - response
      - connection
      type: string
    LogType:
      description: The type of a log entry describing during what kind of activity
        the entry was created.
      enum:
      - consumed
      - dispatched
      - filtered
      - mapped
      - dropped
      - enforced
      - published
      - other
      type: string
    LogLevel:
      description: Escalation level of a log entry.
      enum:
      - success
      - failure
      type: string
    SearchResultThings:
      example:
        cursor: cursor
        items:
        - features:
            key:
              definition:
              - definition
              - definition
              properties: '{}'
          policyId: policyId
          definition: definition
          attributes: '{}'
          thingId: thingId
        - features:
            key:
              definition:
              - definition
              - definition
              properties: '{}'
          policyId: policyId
          definition: definition
          attributes: '{}'
          thingId: thingId
      properties:
        items:
          items:
            $ref: '#/components/schemas/Thing'
          type: array
        cursor:
          type: string
    SearchResultThingsCount:
      type: integer
    NewThing:
      example:
        features:
          key:
            definition:
            - definition
            - definition
            properties: '{}'
        policyId: policyId
        _copyPolicyFrom: _copyPolicyFrom
        definition: definition
        attributes: '{}'
        _policy: ""
      properties:
        _policy:
          allOf:
          - $ref: '#/components/schemas/Policy'
          description: |-
            The initial policy to create for this thing. This will create a separate policy entity managed by resource `/policies/{thingId}`.


            Use the placeholder `{{ request:subjectId }}` in order to let the backend insert the authenticated subjectId of the HTTP request.
        _copyPolicyFrom:
          description: |-
            This field may contain the policy ID of an existing policy.
            The policy is copied and used for this newly created thing. This field may also contain a placeholder
            reference to a thing in the format `{{ ref:things/[thingId]/policyId }}` where you need to replace `[thingId]`
            with a valid thing ID. The newly created thing will then obtain a copy of the policy of the referenced thing.
            In the case of using a reference, the caller needs to have READ access to both the thing and the policy of the thing.
            In the case of using an explicit policy id to copy from, the caller needs to have READ access to the policy.
            If you want to specify a policy ID for the copied policy, use the policyId field.
            This field must not be used together with the field `_policy`. If you specify both `_policy` and
            `_copyPolicyFrom` this will lead to an error response.
          type: string
        policyId:
          description: |-
            The policy ID used for controlling access to this thing. Managed by
            resource `/policies/{policyId}`.
          type: string
        definition:
          description: A single fully qualified identifier of a definition in the
            form 'namespace:name:version'
          pattern: ([_a-zA-Z0-9\-.]+):([_a-zA-Z0-9\-.]+):([_a-zA-Z0-9\-.]+)
          type: string
        attributes:
          description: An arbitrary JSON object describing the attributes of a thing.
          type: object
        features:
          additionalProperties:
            $ref: '#/components/schemas/Feature'
          description: |-
            List of features where the key represents the `featureId` of each feature.
            The `featureId` key must be unique in the list.
          type: object
      type: object
    Thing:
      example:
        features:
          key:
            definition:
            - definition
            - definition
            properties: '{}'
        policyId: policyId
        definition: definition
        attributes: '{}'
        thingId: thingId
      properties:
        thingId:
          description: Unique identifier representing the thing
          type: string
        policyId:
          description: The ID of the policy which controls the access to this thing.
            policies are managed by resource `/policies/{policyId}`
          type: string
        definition:
          description: A single fully qualified identifier of a definition in the
            form 'namespace:name:version'
          pattern: ([_a-zA-Z0-9\-.]+):([_a-zA-Z0-9\-.]+):([_a-zA-Z0-9\-.]+)
          type: string
        attributes:
          description: An arbitrary JSON object describing the attributes of a thing.
          type: object
        features:
          additionalProperties:
            $ref: '#/components/schemas/Feature'
          description: |-
            List of features where the key represents the `featureId` of each feature.
            The `featureId` key must be unique in the list.
          type: object
      required:
      - attributes
      - definition
      - features
      - policyId
      - thingId
      type: object
    Policy:
      description: Policy consisting of policy entries
      example:
        entries:
          labelN:
            subjects:
              iot-permissions:subjectId1:
                type: type
              iot-permissions:subjectIdN:
                type: type
            resources:
              solution:/:
                revoke:
                - null
                - null
                grant:
                - null
                - null
              thing:/:
                revoke:
                - null
                - null
                grant:
                - null
                - null
              message:/:
                revoke:
                - null
                - null
                grant:
                - null
                - null
              policy:/:
                revoke:
                - null
                - null
                grant:
                - null
                - null
              thing:/attributes/some/path:
                revoke:
                - null
                - null
                grant:
                - null
                - null
          label1:
            subjects:
              iot-permissions:subjectId1:
                type: type
              iot-permissions:subjectIdN:
                type: type
            resources:
              solution:/:
                revoke:
                - null
                - null
                grant:
                - null
                - null
              thing:/:
                revoke:
                - null
                - null
                grant:
                - null
                - null
              message:/:
                revoke:
                - null
                - null
                grant:
                - null
                - null
              policy:/:
                revoke:
                - null
                - null
                grant:
                - null
                - null
              thing:/attributes/some/path:
                revoke:
                - null
                - null
                grant:
                - null
                - null
      properties:
        entries:
          $ref: '#/components/schemas/PolicyEntries'
      type: object
    PolicyEntries:
      description: Policy entries containing one policy entry for each arbitrary `label`
        key
      example:
        labelN:
          subjects:
            iot-permissions:subjectId1:
              type: type
            iot-permissions:subjectIdN:
              type: type
          resources:
            solution:/:
              revoke:
              - null
              - null
              grant:
              - null
              - null
            thing:/:
              revoke:
              - null
              - null
              grant:
              - null
              - null
            message:/:
              revoke:
              - null
              - null
              grant:
              - null
              - null
            policy:/:
              revoke:
              - null
              - null
              grant:
              - null
              - null
            thing:/attributes/some/path:
              revoke:
              - null
              - null
              grant:
              - null
              - null
        label1:
          subjects:
            iot-permissions:subjectId1:
              type: type
            iot-permissions:subjectIdN:
              type: type
          resources:
            solution:/:
              revoke:
              - null
              - null
              grant:
              - null
              - null
            thing:/:
              revoke:
              - null
              - null
              grant:
              - null
              - null
            message:/:
              revoke:
              - null
              - null
              grant:
              - null
              - null
            policy:/:
              revoke:
              - null
              - null
              grant:
              - null
              - null
            thing:/attributes/some/path:
              revoke:
              - null
              - null
              grant:
              - null
              - null
      properties:
        label1:
          $ref: '#/components/schemas/PolicyEntry'
        labelN:
          $ref: '#/components/schemas/PolicyEntry'
      type: object
    PolicyEntry:
      description: Single policy entry containing Subjects and Resources.
      example:
        subjects:
          iot-permissions:subjectId1:
            type: type
          iot-permissions:subjectIdN:
            type: type
        resources:
          solution:/:
            revoke:
            - null
            - null
            grant:
            - null
            - null
          thing:/:
            revoke:
            - null
            - null
            grant:
            - null
            - null
          message:/:
            revoke:
            - null
            - null
            grant:
            - null
            - null
          policy:/:
            revoke:
            - null
            - null
            grant:
            - null
            - null
          thing:/attributes/some/path:
            revoke:
            - null
            - null
            grant:
            - null
            - null
      properties:
        subjects:
          $ref: '#/components/schemas/Subjects'
        resources:
          $ref: '#/components/schemas/Resources'
      required:
      - resources
      - subjects
      type: object
    Subjects:
      description: |-
        A SubjectEntry defines who is addressed.
        Example: iot-permissions:some-user-id.
        See all supported types at [policy > Who can be addressed](https://docs.bosch-iot-suite.com/things/basic-concepts/auth/auth_policy/#who-can-be-addressed)
      example:
        iot-permissions:subjectId1:
          type: type
        iot-permissions:subjectIdN:
          type: type
      properties:
        iot-permissions:subjectId1:
          $ref: '#/components/schemas/SubjectEntry'
        iot-permissions:subjectIdN:
          $ref: '#/components/schemas/SubjectEntry'
      type: object
    SubjectEntry:
      description: Single (Authorization) Subject entry holding its type.
      example:
        type: type
      properties:
        type:
          description: The type is offered only for documentation purposes. You are
            not restricted to any specific types, but we recommend to use it to specify
            the kind of the subject as shown in our examples.
          type: string
      required:
      - type
      type: object
    Resources:
      description: |-
        (Authorization) Resources containing one ResourceEntry for each
        `type:path` key, `type` being one of the following `thing`, `policy`, `message` and `solution`

         Note: The solution resources can be addressed ONLY within a special policy per solution.
         See [policy of a solution](https://docs.bosch-iot-suite.com/things/basic-concepts/auth/auth-policy-solution/)
      example:
        solution:/:
          revoke:
          - null
          - null
          grant:
          - null
          - null
        thing:/:
          revoke:
          - null
          - null
          grant:
          - null
          - null
        message:/:
          revoke:
          - null
          - null
          grant:
          - null
          - null
        policy:/:
          revoke:
          - null
          - null
          grant:
          - null
          - null
        thing:/attributes/some/path:
          revoke:
          - null
          - null
          grant:
          - null
          - null
      properties:
        thing:/:
          $ref: '#/components/schemas/ResourceEntry'
        thing:/attributes/some/path:
          $ref: '#/components/schemas/ResourceEntryRestricted'
        policy:/:
          $ref: '#/components/schemas/ResourceEntry'
        message:/:
          $ref: '#/components/schemas/ResourceEntry'
        solution:/:
          $ref: '#/components/schemas/ResourceEntry'
      type: object
    ResourceEntry:
      description: |-
        Single (Authorization) Resource entry defining permissions per effect.
        Allowed effects are `grant` and `revoke`.
      example:
        revoke:
        - null
        - null
        grant:
        - null
        - null
      properties:
        grant:
          items:
            $ref: '#/components/schemas/Permission'
          type: array
        revoke:
          items:
            $ref: '#/components/schemas/Permission'
          type: array
      type: object
    ResourceEntryRestricted:
      description: |-
        Single (Authorization) Resource entry defining permissions per effect.
        Allowed effects are `grant` and `revoke`.
      example:
        revoke:
        - null
        - null
        grant:
        - null
        - null
      properties:
        grant:
          items:
            $ref: '#/components/schemas/Permission'
          type: array
        revoke:
          items:
            $ref: '#/components/schemas/Permission'
          type: array
      type: object
    Permission:
      description: A Permission allows a certain action on an entity
      enum:
      - READ
      - WRITE
      type: string
    Features:
      additionalProperties:
        $ref: '#/components/schemas/Feature'
      description: |-
        List of features where the key represents the `featureId` of each feature.
        The `featureId` key must be unique in the list.
      type: object
    WhoAmI:
      description: Contains information about the current user and the auth subjects
        available for the used authentication.
      example:
        defaultSubject: iot-suite:/service-instance.8e3b9fea-0fa8-47b0-8db4-8b6379bf8ae2.iot-things@bc3dd223-3da4-4dfd-b03e-0deaa2fdef12
        subjects:
        - iot-suite:/service-instance.8e3b9fea-0fa8-47b0-8db4-8b6379bf8ae2.iot-things@bc3dd223-3da4-4dfd-b03e-0deaa2fdef12
        - iot-suite:/service-instance.8e3b9fea-0fa8-47b0-8db4-8b6379bf8ae2.iot-things@bc3dd223-3da4-4dfd-b03e-0deaa2fdef12
      properties:
        defaultSubject:
          description: An auth subject that can be used to provide access for a caller
            (e.g. in subject entries of policies).
          example: iot-suite:/service-instance.8e3b9fea-0fa8-47b0-8db4-8b6379bf8ae2.iot-things@bc3dd223-3da4-4dfd-b03e-0deaa2fdef12
          type: string
        subjects:
          items:
            $ref: '#/components/schemas/WhoAmISubject'
          type: array
      type: object
    WhoAmISubject:
      description: An auth subject that can be used to provide access for a caller
        (e.g. in subject entries of policies).
      example: iot-suite:/service-instance.8e3b9fea-0fa8-47b0-8db4-8b6379bf8ae2.iot-things@bc3dd223-3da4-4dfd-b03e-0deaa2fdef12
      type: string
    Solution_planObject:
      description: The booked plan as object representation.
      example:
        usageLimits:
          transactionCount: 6.027456183070403
          dataVolumeInBytes: 0.8008281904610115
      properties:
        type:
          $ref: '#/components/schemas/PlanType'
        usageLimits:
          $ref: '#/components/schemas/UsageLimits'
    Solution_status:
      example:
        dataVolume: within plan
        transactionCount: within plan
      properties:
        dataVolume:
          description: The status of the Managed Data Volume.
          enum:
          - within plan
          - exceeds plan
          type: string
        transactionCount:
          description: The status of the used Transaction Count quota.
          enum:
          - within plan
          - exceeds plan
          type: string
      required:
      - dataVolume
      - transactionCount
    Solution_customer:
      example:
        name: name
        email: email
        info: info
      properties:
        name:
          description: The name of the customer
          type: string
        email:
          description: The email address of the customer
          type: string
        info:
          description: Additional information about the customer
          type: string
      required:
      - email
      - info
      - name
    Enforcement_configuration:
      description: Defines an enforcement for this source to make sure that a device
        can only access its associated Thing.
      example:
        input: '{{ header:device_id }}'
        filters:
        - '["{{ thing:id }}","{{ thing:namespace }}/{{ thing:name }}"]'
        - '["{{ thing:id }}","{{ thing:namespace }}/{{ thing:name }}"]'
      properties:
        input:
          description: |-
            The input value of the enforcement that should identify the origin of the message (e.g. a
            device id). You can use placeholders within this field depending on the connection type. E.g. for AMQP
            1.0 connections you can use `{{ header:[any-header-name] }}` to resolve the value from a message header.
          example: '{{ header:device_id }}'
          title: Input value of enforcement
          type: string
        filters:
          description: An array of filters. One of the defined filters must match
            the input value from the message otherwise the message is rejected.
          items:
            description: |-
              A filter that must match the input value for a message to be accepted. You can use the placeholders
               `{{ thing:id }}`, `{{ thing:name }}` or `{{ thing:namespace }}` in a filter.
            example: '["{{ thing:id }}","{{ thing:namespace }}/{{ thing:name }}"]'
            title: Enforcement filter
            type: string
          title: The enforcement filters
          type: array
          uniqueItems: true
      required:
      - filters
      - input
  securitySchemes:
    bearerAuth:
      bearerFormat: JWT
      description: A JSON Web Token issued by a supported OAuth 2.0 Identity Provider.
      scheme: bearer
      type: http
    thingsApiToken:
      description: |-
        The API Token which associates the HTTP request with a specific IoT
        Things service solution.
      in: header
      name: x-cr-api-token
      type: apiKey
    BoschID:
      description: |-
        Use either "OAuth2.0" with your Bosch-ID or the "Basic authentication"
        below with a Demo user. Select the following checkbox in order to grant
        Bosch IoT Things to access your Bosch-ID.
      flows:
        authorizationCode:
          authorizationUrl: https://things.s-apps.de1.bosch-iot-cloud.com/oauth2/bosch-id/authorize
          scopes:
            openid: Access your Bosch-ID
          tokenUrl: https://things.s-apps.de1.bosch-iot-cloud.com/oauth2/bosch-id/token
      type: oauth2
      x-tokenName: id_token
    SuiteAuth:
      description: Use OAuth2 clients from https://accounts.bosch-iot-suite.com/oauth2-clients/
      flows:
        clientCredentials:
          authorizationUrl: https://access.bosch-iot-suit.com/v2/token
          scopes: {}
          tokenUrl: https://access.bosch-iot-suit.com/v2/token
      type: oauth2
      x-tokenName: id_token
    basicAuth:
      description: |-
        Your own Bosch IoT Permissions
        tenant and user in the form "TENANTNAME\username".
      scheme: basic
      type: http
